<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[柯小小西の小水滴]]></title>
  <link href="http://kxcoder.github.io/atom.xml" rel="self"/>
  <link href="http://kxcoder.github.io/"/>
  <updated>2015-10-07T00:51:06+08:00</updated>
  <id>http://kxcoder.github.io/</id>
  <author>
    <name><![CDATA[柯小小西]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Zookeeper 编程指南]]></title>
    <link href="http://kxcoder.github.io/blog/2015/09/05/zookeeper-programmer-guide/"/>
    <updated>2015-09-05T20:52:39+08:00</updated>
    <id>http://kxcoder.github.io/blog/2015/09/05/zookeeper-programmer-guide</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Introduction">前言</a></li>
  <li><a href="#The_ZooKeeper_Data_Model">Zookeeper 数据模型</a></li>
  <li><a href="#ZooKeeper_Sessions">Zookeeper 会话</a></li>
  <li><a href="#ZooKeeper_Watches">Zookeeper 监听</a></li>
  <li><a href="#ZooKeeper_ACL">ZooKeeper 使用 ACL 访问控制</a></li>
</ol>

<h2 id="a-idintroduction1-a"><a id="Introduction">1 前言</a></h2>

<p>该文档是提供给期望使用 <code>Zookeeper</code>协作服务功能的开发者创建分布式应用的。文档内部包含了一些概念上和实践应用上的资料信息。</p>

<p>在指南的前四节主要讨论了 <code>Zookeeper</code> 各方面的概念。这些东西对于理解 <code>Zookeeper</code>如何工作以及如何去使用 <code>Zookeeper</code> 是非常必要的。它虽然没有包含源代码，但是它是假设读者对于分布式计算相关的问题是很熟悉的。它们主要如下介绍：</p>

<ul>
  <li><a href="#The_ZooKeeper_Data_Model">Zookeeper 数据模型</a></li>
  <li><a href="#ZooKeeper_Sessions">Zookeeper 会话</a></li>
  <li><a href="#ZooKeeper_Watches">Zookeeper 监听</a></li>
  <li><a href="#Consistency_Guarantees">Zookeeper 一致性保证</a></li>
</ul>

<!--more-->

<p>后面四节主要提供了一些实践编程相关的资料。主要是：</p>

<ul>
  <li><a href="#A_Guide_to_ZooKeeper_Operations">Zookeeper 操作指南</a></li>
  <li><a href="#Bindings">Zookeeper Bindings</a></li>
  <li><a href="#Program_Structure">Zookeeper 程序结构简单示例（待定）</a></li>
  <li><a href="#Gotchas">Zookeeper 性能和可伸缩性</a></li>
</ul>

<p>文档最后的附录部分包含了一些有用的，Zookeeper 相关的链接。</p>

<p>虽然，该指南中的很多资料在其他一些独立的文章博客中都已经存在了，但是对于开始第一个 <code>Zookeeper</code> 应用的你来说，还是最后阅读完<code>Zookeeper 数据模型</code> 和 <code>Zookeeper 操作指南</code>。</p>

<h2 id="a-idthezookeeperdatamodel-2-zookeeper-a"><a id="The_ZooKeeper_Data_Model"> 2 Zookeeper 数据模型</a></h2>

<p><code>Zookeeper</code> 有一个分级的命名空间，类似于一个分布式的文件系统。唯一不同的是命名空间中每个节点可以有对应的数据关联它，就像孩子一样。这一点类似于文件系统中允许一个文件也可以成为目录一样。到节点的路径常常表示成正则的，绝对的，斜线分隔的路径；它们没有相对的引用。在路径上使用的任何编码需要满足以下限制：</p>

<ul>
  <li><code>null</code>字符不可以成为路径名字的一部分。</li>
  <li>由于显示的问题，如下字符不能使用：<code>\u0001</code>-<code>\u001F</code> 和 <code>\u007F</code>-<code>\u009F</code>.</li>
  <li>下面字符同样不被允许：<code>\ud800</code>-<code>\u0F8FF</code> 和 <code>\uFFF0</code>-<code>\uFFFF</code>.</li>
  <li><code>.</code>字符可以作为路径名字中某块名的一部分，但是<code>.</code>和<code>..</code>不能单独作为路径的一块，因为在 Zookeeper 中不允许相对路径。因此，如下是非法的：<code>/a/b/./c</code>或者<code>/a/b/../c</code>.</li>
  <li><code>zookeeper</code>字符串保留。</li>
</ul>

<h3 id="znodes">2.1 ZNodes</h3>

<p>ZooKeeper 树上的每一个节点都称之为<code>znode</code>。Znodes 维护了一个包含数据变化和acl变化版本号的状态结构体。这个结构体也包含时间戳。因此，版本号和时间戳一起确保Zookeeper验证缓存和协调更新。每一次znode的数据变化，版本号也会对应增长。例如，当一个客户端检索数据时，它也会获得该数据的版本号，然后当一个客户端执行更新或者删除时，它必须提供对应变化的znode的数据版本。如果它提供的版本不能够匹配到实际的数据版本时，更新将会失败。</p>

<blockquote>
  <blockquote>
    <p>Note:
在分布式应用工程中，<code>node</code>常常被看做一个主机，一台服务器，一组中的一个成员等等。在Zookeeper文档中，<code>znodes</code>称为数据节点；<code>Servers</code>则是标记为Zookeeper服务的机器；<code>quorum peers</code>是标记为一个集群的所有服务器；<code>client</code>是任何使用Zookeeper服务的机器或者进程。</p>

  </blockquote>
</blockquote>

<p>Znodes是开发者访问的最主要的实体。它们有一些值得去关注的特征：</p>

<h4 id="watches">2.1.1 Watches</h4>

<p>客户端可以在 znodes 上设置监听。znode 的改变将会触发监听器，然后清理监听。当一个监听器被触发时，Zookeeper 会发送对应客户端一个通知。更新的信息可以参考 <a href="#ZooKeeper_Watches">Zookeeper 监听</a>。</p>

<h4 id="section-1">2.1.2 数据访问</h4>

<p>保存在一个命名空间里的每个节点上的数据都可以被原子的读和写。读，获取对应znode上所有的数据字节；然后一个写，替换所有的数据。每个节点上的ACL(访问控制列表)可以限制<code>who can do what</code>。</p>

<p>Zookeeper 不是被设计用来作为一个通用的数据库或者大对象的存储。相反，它是用来管理协调数据的。这个数据来源于配置，状态信息，集结地点等形式中。一般，协调的数据相对来说是很小的：几千字节计算。Zookeeper 客户端和服务器实现的时候会确保znode的数据小于1M，但是通常数据会比那个小得多。操作相对大的数据将会导致一些操作会花费更对的时间，从而一些操作的延迟性，这主要是因为一些额外的时间需要被用来在网络上移动更多的数据，存储起来。如果一定需要大数据的存储，通常的处理方式是将数据存储在大容量存储系统上，比如 NFS 或者 HDFS ，然后再Zookeeper里保持存储位置的指针。</p>

<h4 id="section-2">2.1.3 短暂节点</h4>

<p>Zookeeper 也有短暂节点的概念。在会话创建时，znode存活；当会话结束时，znode删除。由于这个特性，所以其不允许有孩子。</p>

<h4 id="section-3">2.1.4 顺序节点-唯一命名</h4>

<p>当创建一个znode时，你也可以请求Zookeeper在路径的末尾增加一个单调递增的计算器。这个计算器对父节点来说是唯一的。计算器有一个<code>%010d</code>格式化–表示10个数字0补全。比如：<code>&lt;path&gt;0000000001</code>。Notes：计数器用来保存下一个顺序数字是一个有符号整形，由父节点保存，当增长到<code>2147483647</code>将会溢出。</p>

<h3 id="zookeeper--time">2.2 Zookeeper 中的 Time</h3>

<p>Zookeeper 追踪 time的多种方式如下：</p>

<ul>
  <li>
    <p>Zxid<br />
Zookeeper状态的每次改变，在<code>zxid</code>(ZooKeeper Transaction Id)里都会获取到一个时间戳。这意味着在ZooKeeper中所有都变化都是有序的。每次改变都将会有一个<code>zxid</code>，如果 zxid1 小于 zxid2，则 zxid1 一定在 zxid2 之前发生。</p>
  </li>
  <li>
    <p>版本号<br />
一个节点的每次改变都会导致对应节点的其中一个版本号递增。节点对应的三个版本号是：version(znode 数据改变对应的编号)；cversion(znode 的孩子改变对应的编号)；aversion(znode 的ACL改变对应的编号)。</p>
  </li>
  <li>
    <p>Ticks<br />
当使用多服务器的 ZooKeeper 时，服务器使用 <code>ticks</code> 来定义事件的时间，比如，状态上传，会话超时，连接超时等。tick 时间只能间接地表示最小的会话超时（每tick时间内2次）；如果一个客户端请求的会话超时小于最小的会话超时，则服务器将会告诉客户端它请求的会话超时实际上是最小的会话超时。</p>
  </li>
  <li>
    <p>真实时间<br />
ZooKeeper 不使用真实时间或者时钟时间，即使在所有我们期望把时间戳放入znode创建和修改的状态结构体里面。</p>
  </li>
</ul>

<h3 id="zookeeper-">2.3 ZooKeeper 状态结构体</h3>

<p>ZooKeeper 里每个 znode 的状态结构体都包括下面这些字段：</p>

<ul>
  <li>czxid<br />
导致znode被创建的zxid。</li>
  <li>mzxid<br />
对应znode最后一次改变的zxid。</li>
  <li>ctime<br />
当该znode创建开始的毫秒数。</li>
  <li>mtime<br />
当该znode最后一次更改开始的毫秒数。</li>
  <li>version<br />
znode数据改变的编号。</li>
  <li>cversion</li>
  <li>aversion</li>
  <li>ephemeralOwner<br />
如果该znode是临时节点，则为该节点owner的 会话id；如果不是临时节点，则为0。</li>
  <li>dataLength<br />
znode 数据字段的长度。</li>
  <li>numChildren<br />
znode对应孩子的个数。</li>
</ul>

<h2 id="a-idzookeepersessions-3-zookeeper-a"><a id="ZooKeeper_Sessions"> 3 Zookeeper 会话</a></h2>

<p>ZooKeeper 客户端通过绑定的编程语言创建一个 <code>handle</code>从而和ZooKeeper服务建立会话。一旦创建完成，<code>handle</code>开始处在  <code>CONNECTING</code> 状态，然后客户端将会和ZooKeeper服务中某个服务器连接上，然后其会切换到 <code>CONNECTED</code>状态。在通常的操作过程中，会处在这两张状态中的一种。如果发生了一个不可恢复的错误，比如会话过期或者认证失败，再或者如果应用显示地关闭 <code>handle</code>，则该 <code>handle</code> 将会转变为 <code>CLOSE</code> 状态。</p>

<p>下面的图展示了一个 ZooKeeper 客户端可能的状态流转情形：</p>

<p><img src="http://kxcoder.github.io/images/2015/09/zookeeper_stat.png" /></p>

<p>为了创建一个客户端会话，应用代码必须提供一个连接字符串，包含一个以逗号分隔的 <code>host:pair</code>列表, 每个<code>host:pair</code> 对应的是一台 ZooKeeper服务器（比如，”127.0.0.1:4545” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002”）。ZooKeeper 客户端会挑选任务的服务器，然后尝试去连接它。如果这个连接失败，或者这个客户端因为任何原因导致和这个服务器断开连接，客户端都将会自动尝试列表中的下一台服务器，知道一个连接被(重新)建立起来。</p>

<p><em>3.2.0 新特性</em>：一个可选择的”chroot”后缀也可能会添加到连接字符串中。和linux中的<code>chroot</code>命令相似，运行客户端的所有命令中的路径都是相对这个root来确定的。比如我们如果使用：”127.0.0.1:4545/app/a” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a”，则客户端将会以”/app/a” 为root，然后所有路径都是相对这个root而言的–例如，我们获取 “/foo/bar” 下面的文件，则实际上将会在 “app/a/foo/bar” 下面执行。这个特性对于多租户环境下是很有用的，这样每个用户在 ZooKeeper服务上其root都可以不同。因此，对于每个用户如果编码他们的应用中以”/”为root情况下，重复使用ZooKeeper服务将非常简单。</p>

<p>当一个客户端获取到ZooKeeper服务的一个<code>handle</code>，ZooKeeper 创建一个ZooKeeper 会话，以 64位数字表示。如果客户端连接到一台不同的 ZooKeeper服务器，它将会发送一个会话id作为连接握手的一部分。作为一个安全手段，服务器为该会话id创建一个任何ZooKeeper服务器都可以验证的password。当客户端建立完会话之后，password 将会和会话id一起发送给客户端。当客户端需要和新的服务器重新建立连接时，则发送该password 和 会话id。</p>

<p>ZooKeeper 客户端库调用创建一个ZooKeeper会话时，其中有一个参数是毫秒数的会话超时。客户端发送一个请求超时，服务器将响应从客户端获取的超时。当前的时候要求超时时间最小为 2 个 tckTime，并且最大为 20 个 tickTime。ZooKeeper 客户端API 运行访问协商的超时。</p>

<p>当一个客户端（会话）从ZK服务集群里分隔开，它将会开始搜素我们在创建会话时候指定的服务器列表。最后，当客户端和至少服务器中的一台重新建立连接后，会话将会要么转化为 <code>connected</code>状态（如果会话重连接在超时值之内），要么转化为<code>expired</code>状态（如果重连在会话超时之后）。为断开连接的客户端创建一个新的会话对象是不明智的。ZK 客户端库将会为你处理重连。在实践中，我们在客户端库中会有一些启发式的算法构建来处理像”羊群效应”等事情。只有在收到会话过期通过时，才会去创建一个新的会话。</p>

<p>会话过期由ZooKeeper集群自己管理，而不是客户端。当ZK客户端和集群建立会话时，其提供一个超时值。集群使用这个值来决定客户端会话是否超时。当集群没有在超时时间内收到返回，则发送会话过期。在会话过期的时候，集群将会删除该会话拥有的所有的临时节点，然后立即通知监听该变化的所有连接状态的客户端。在这个时间点，超时会话的客户端仍然和集群断开连接，在重新和集群建立连接之前，它将不会收到会话超时的通知。客户端将会一直带着断开连接的状态，知道TCP连接被重新建立起来，然后 超时会话的<code>watcher</code>将会接收到”会话超时”的通知。</p>

<p>一个超时的会话状态流转的过程示例：</p>

<ol>
  <li>connected：会话建立连接，客户端和集群处于通信中。</li>
  <li>客户端从集群中分割开…</li>
  <li>disconnected：客户端丢失和集群之间的连接</li>
  <li>… 时间过去了，在 超时区间之后，集群过期了会话，客户端由于和集群断开了所以看不到任何东西。</li>
  <li>… 时间进行走着，客户端恢复了和集群的网络层连接、</li>
  <li>expired：最终，客户端重新连接上集群，然后被通知过期。</li>
</ol>

<p>ZooKeeper 建立会话调用的另一个蚕食是默认的 <code>watcher</code>。当在客户端上的状态发送变更，watcher 将会被通知到。例如，如果一个客户端丢失了和服务器之间的连接，则客户端将会收到通知，或者如果客户端会话过期了。watcher 应该认为初始状态是 断开连接的。在一个新连接的case里面，发送给 watcher 的第一个通知就是会话连接事件。</p>

<p>会话通过客户端发送请求保持alive。如果会话空闲了会话超时时间段时，客户端将会发送 <code>PING</code>请求来保持会话alive。<code>PING</code>请求不仅允许 ZooKeeper服务器知道 客户端仍然活跃，也允许客户端通过连接验证 ZooKeeper服务器仍然活跃。<code>PING</code>的时间很充足，从而确保有在检测到死连接，然后重新连接到新的server的操作有足够的时间。</p>

<p>一旦一个到服务器的连接成功的建立了，客户端 lib 有两个基本的case 导致 连接丢失，当执行一个同步或者异步操作，然后出现如下情况：</p>

<ol>
  <li>在一个不再活跃/有效的会话上调用一个操作。</li>
  <li>当ZooKeeper客户端挂起一个操作时，断开和服务器之间的连接。</li>
</ol>

<p><em>3.2.0 新特性–SessionMovedException</em>：这是一个内部的异常。这个异常一般发生在一个会话和不同的服务器重新建立连接后接收到请求的时候。正常导致这个错误的原因是一个哭护短发生一个请求给一个服务器，但是网络包延迟，所以客户端超时，然后和新的服务器建立间接。当延迟的包被第一台服务器收到时，老的服务器检测到会话已经被移开，然后关闭客户端连接。客户端正常下不会看着这个错误，因为他不会从老的连接中读数据。出现这种情况的一个条件是当两个客户端尝试使用 password 和 会话id 重新建立相同的连接，其中一个客户端将重新建立连接，第二个客户端将会断开连接。</p>

<p><em>更新服务器列表</em>：我们允许客户端通过提供一组新的逗号分隔的<code>host:port</code>对列表来更新连接字符串。这个函数调用一个基于概率的负载均衡算法导致客户端断开和当前host的连接，从而达到服务器列表中连接的平均数。万一当前客户端连接的host不在新的列表中，这个调用将会导致连接被丢弃。另外，决定服务器数量的增加或者减少以及多少。</p>

<p>例如：如果前面的连接字符串包含 3 host，然后现在列表包含这 3 个 host和 2 个新加的 host，40%的客户端原来对应的连接将会迁移到新的hosts中的一个来确保均衡负载。这个方案将会导致客户端丢弃他的连接，然后0.4的概率连接到其他2台机器，在这种情况下，导致客户端随机选择连接 2 个新的host中的一台。</p>

<p>另一个例子–假设我们有5 台host，现在我们更新服务器列表移走 2 台host，然后客户端连接剩下 3 台host的依然连接，然后 移除的2台 host上的连接将被移动到剩下 3 台host的其中一台。如果连接丢弃，客户端移动到指定的模式，其可以选择一个新的服务器去根据概率算法连接服务器，而不是 RR。</p>

<p>在第一个例子中，每个客户端决定以0.4的概率来断开连接，但是一旦做完决定，它将尝试随机连接到一个新的服务器，仅仅在不能连接到新的服务器中的任何一台时，它才会尝试连接老的服务器。在找到一个服务器，或者尝试列表中所有的服务器，仍然连接失败的时候，客户端回退到正常的操作模式(从概率模式回到轮询RR模式)，即从连接字符串中选择任意的服务器，然后尝试连接它。如果失败，它将以RR模式尝试不同随机服务器。</p>

<h2 id="a-idzookeeperwatches-4-zookeeper-a"><a id="ZooKeeper_Watches"> 4 Zookeeper 监听</a></h2>

<p>在 ZooKeeper 里所有的读操作（getData()，getChildren()和 exists()）都可以将设置一个 <code>watch</code> 作为附加功能。ZooKeeper 对 <code>watch</code>的定义是：一个监听事件是一次性的 <code>trigger</code>，当监听的数据发送变化的时候，发送给设置监听的客户端们。对于这个定义，有三个关键点：</p>

<ul>
  <li>
    <p>One-time trigger<br />
当监听数据发送变化的时候，一个监听事件将会发送给客户端。例如，一个客户端使用 <code>getData("/znode1", true)</code>，然后<code>/znode1</code>的数据发送变化或者删除，客户端将会获得一个对应 <code>/znode1</code>的监听事件。<em>但是，如果<code>/znode1</code>再次改变，就不会再有监听事件发送出去，除非客户端通过另一个读操作来设置监听watch</em></p>
  </li>
  <li>
    <p>Sent to client<br />
这意味着一个正发送给客户端的事件，可能在发送修改操作的客户端完成操作返回成功 code 之前不会到达客户端。监听事件是异步发送给监听客户端的。ZooKeeper 提供一个有序的保证：一个客户端永远只有在看到一个watch事件之后才会看到这个watch对应的改变。网络延迟或者其他原因可能导致不同的客户端看到watch和更新返回code的时间不同。其关键之处在于不同客户端看到的所有事情都是有一致性的顺序的。</p>
  </li>
  <li>
    <p>The data for which the watch was set<br />
这指的是节点改变的不同方式。你可以认为 ZooKeeper 维护 watch的两个列表：数据watch 和 孩子watch。<code>getData()</code>和<code>exists()</code>设置数据watch；<code>getChildren()</code> 设置child监听。此外，你也可以认为 watch 可以根据数据返回的类型来设置。<code>getData()</code>和<code>exists()</code> 返回节点数据的信息，然而<code>getChildren()</code> 返回 孩子列表。因此，<code>setData()</code>将触发节点的数据watch 设置。一个成功的<code>create()</code>将会触发znode的数据watch 以及 父节点的child watch。一个成功的 <code>delete()</code>将会触发节点的数据watch和child watch（因为将不会再有children了）。</p>
  </li>
</ul>

<p>watch 由与对应client连接的ZooKeeper服务器负责维护。因此，这可以使得 watch 可以轻量级地设置，维护和分发。当一个客户端连接到一个新的server，watch将会出现会话时间。当和server断开连接后，将不会收到watch。当一个客户端重新连接，任务先前注册的watch将会被重新注册，然后当需要的时候触发。一般情况下，这都是显示地发生的。有一个case就是一个watch可能被丢失：一个人还未创建的znode的 existence watch 将会被丢失，如果这个znode 创建，然后当断开连接的时候又被删除了。</p>

<h3 id="watch-">4.1 watch 语义</h3>

<p>我们可以通过读ZooKeeper的三种状态来设置 watch：exists, getData, 和
getChildren。下面的列表展示了一个watch 触发和调用激活的方式：</p>

<ul>
  <li>Created event:<br />
通过 exist调用激活。</li>
  <li>Deleted event:<br />
通过调用 exists, getData, 和 getChildren 激活</li>
  <li>Changed event:<br />
通过调用 exists, getData 激活。</li>
  <li>Child event:<br />
通过调用 getChildren 激活。</li>
</ul>

<h3 id="watch--1">4.2 watch 移除</h3>

<p>我们可以调用 removeWatches 方法移除在 znode 注册的 watch。一个客户端可以本地移除watch操作，即使没有连接ZooKeeper服务器，只是本地设置标识为true。下面的列表详细说明了在成功移除watch 之后会触发什么事件：</p>

<ul>
  <li>Child Remove event:<br />
在调用getChildren的时候添加 watcher。</li>
  <li>Data Remove event:<br />
在调用 exists 或者 getData 的时候添加 watcher。</li>
</ul>

<h3 id="watch--2">4.4 关于 watch 需要记住的事情</h3>

<ul>
  <li>Watches 是一次性触发器。如果你获取了一个 watch 事件，然后你还想在未来更改的时候也获得通知，则你必须要设置另外的watch。</li>
  <li>由于watch是一次性的触发器，并且在获取时间和发送新的请求去获取watch 这段之间的延迟，所看到的发生在 ZooKeeper Znode 上的所有改变都是不可信的。需要准备好处理在获取事件和设置watch之间znode改变多次的case。</li>
  <li>一个watch对象，或者 function/context对，对于给定的通知只会被触发一次。例如，如果一个相同的watch对象被一个<code>exists 或者 getData</code> 文件file调用操作注册，然后这个文件file被删除了，这个watch对象将和这个文件file的删除通知一起，仅仅被调用一次。</li>
  <li>当你从服务器上断开连接，你将不能获得任何watch 直到连接被重新建立起来。基于这个原因，会话事件将被发生给所有突出的watch处理器。使用会话事件会进入一个安全模式：你将不能接收事件指导断开连接，所以你的处理处理这种模式下需要谨慎。</li>
</ul>

<h2 id="a-idzookeeperacl-5-zookeeper--acl-a"><a id="ZooKeeper_ACL"> 5 ZooKeeper 使用 ACL 访问控制</a></h2>

<p>（待定….）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 反向代理配置和工作原理]]></title>
    <link href="http://kxcoder.github.io/blog/2015/08/30/nginx-proxy-configure-and-sduty/"/>
    <updated>2015-08-30T18:52:03+08:00</updated>
    <id>http://kxcoder.github.io/blog/2015/08/30/nginx-proxy-configure-and-sduty</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Proxy">Nginx 反向代理配置说明</a></li>
  <li><a href="#ProcessRequest">Nginx 架构和请求处理流程</a></li>
  <li><a href="#ImplementationStudy">Nginx Upstream模块和Location配置</a></li>
  <li><a href="#End">后记</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p><code>Nginx</code>是一款面向性能设计的HTTP服务器，其性能相对于其他服务器表现优异。内部使用异步的事件处理模型，比如linux平台的<code>epoll</code>事件模型，unix平台的<code>kqueue</code>事件模型等。在Nginx源码的<code>src/event/modules</code>目录下，其对各个平台不同的异步模型进行了二次封装。此外，Nginx在代码实现的时候，会考虑到众多细节优化。比如：根据CPU亲缘性来分配进程和事件，避免CPU级的缓存失效；比如字符串比较时，四字节转换为整数来进行快速指令级比较，等等。</p>

<p>本博文主要目的不是Nginx源码分析，所以，对源码及其独特优秀的代码设计不会去详细介绍。</p>

<p>在最近的一些项目中，涉及到nginx的反向代理配置，然后花了一些时间了解下关于Nginx的整体请求处理流程和返现代理的实现机制。</p>

<p>Nginx虽然代码整洁，模块清晰，但是代码量毕竟还是很多，而且注释实在是太少，所以把一些学习的资料和心得整理一下，以便以后查看。</p>

<!--more-->

<h2 id="a-idproxynginx-a"><a id="Proxy">Nginx 反向代理配置说明</a></h2>

<p>反向代理指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接到客户端，此时代理服务器对外就表现为一个服务器，而此种工作模式类似于LVS-NET模型。</p>

<p>反向代理也可以理解为web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加的 一个高速web缓冲服务器，用来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，所有外部网络要访问服务器时的所有请求都要通过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存在本地，以便日后再收到同样的信息请求时，它会将本地缓存里的内容直接发给用户，已减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</p>

<p>了解nginx的反向代理如何实现之前，先看看我们一般配置nginx反向代理的设置：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>nginx反向代理的设置 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class="nginx"><span class="line">    <span class="k">upstream</span> <span class="s">cc_001</span> <span class="p">{</span>
</span><span class="line">        <span class="kn">server</span> <span class="n">192.168.1.101</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class="line">        <span class="kn">server</span> <span class="n">192.168.1.102</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="kn">healthcheck_enabled</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_delay</span> <span class="mi">3000</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_timeout</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_failcount</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_send</span> <span class="s">&#39;GET</span> <span class="s">/healthcheck.html</span> <span class="s">HTTP/1.0&#39;</span> <span class="s">&#39;Host:</span> <span class="s">local.com&#39;</span> <span class="s">&#39;Connection:</span> <span class="s">close&#39;</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">server</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="kn">listen</span>       <span class="n">192.168.1.100</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class="line">        <span class="kn">server_name</span>  <span class="s">cc.local.com</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="kn">proxy_buffers</span> <span class="mi">64</span> <span class="mi">4k</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="kn">location</span> <span class="p">=</span> <span class="s">/</span> <span class="p">{</span>
</span><span class="line">            <span class="kn">proxy_pass</span> <span class="s">http://cc_001/bm/index.htm</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
</span><span class="line">            <span class="kn">proxy_pass</span> <span class="s">http://cc_001</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的code主要列出来nginx 反向代理基本配置。</p>

<blockquote>
  <blockquote>
    <p>Tips：上面的配置选项都是最最基本的，一般涉及到反向代理都会使用到这些配置。对于其中的设置项，理解起来也很简单。</p>
  </blockquote>
</blockquote>

<p><em>upstream配置块</em></p>

<p>其实在nginx中，<code>upstream</code>是一个非常重要的配置。nginx所有对于动态请求的处理，基本上都需要使用<code>upstream</code>配置模块。nginx的两个很重要的功能，反向代理和负载均衡，都需要通过配置对应的<code>upstream</code>来完成。</p>

<blockquote>
  <blockquote>
    <p>其实在nginx中，有一个基础模块叫handler，这个模块可以接受来自客户端/用户端的请求，然后处理并产生对应的响应内容返回过去。因此，我们那些静态资源，前端页面什么的，都是使用handler模块来完成响应的。但是，众所知周，一般的核心服务都是后台动态产生的，这些资源就不可以方便使用handler去完成内容的生成和响应动作（当然也是可以使用开发自定义handler来完成的，比如各种xxxcgi之流，但是一般还是用来处理静态资源）。</p>

    <p>那么，upstream就出现了。其接收到用户的请求，然后转发到后端服务器拿到对应的响应资源，再返回给请求端。在整个处理过程中，其本身不会产生自己的响应内容，这是和<code>handler</code>模块唯一的区别。</p>

    <p>upstream的特性，决定了在其配置块中，设置一些后端服务器的地址和端口，就ok了。</p>

  </blockquote>
</blockquote>

<p>配置项说明：</p>

<ul>
  <li>
    <p>upstream中的server项：表明后台的一台服务器地址和端口。当客户端有请求到<code>nginx</code>服务器的时候，upstream模块根据这里配置的server，该对应的请求转发到这些server服务上，由这些server来处理请求，然后把响应结果告知upstream模块。</p>
  </li>
  <li>
    <p>healthcheck_enabled项：healthcheck健康监控功能，并不是原生nginx自带的。所以如果使用这个功能，必须要安装第三方插件：<code>ngx_http_healthcheck_module</code>。healthcheck_enabled表示启动健康检查模块功能。</p>
  </li>
  <li>
    <p>healthcheck_delay项：对同一台后端服务器两次检测之间的时间间隔，单位毫秒，默认为1000。</p>
  </li>
  <li>
    <p>healthcheck_timeout项：进行一次健康检测的超时时间，单位为毫秒，默认值2000。</p>
  </li>
  <li>
    <p>healthcheck_failcount项：对一台后端服务器检测成功或失败多少次之后方才确定其为成功或失败，并实现启用或禁用此服务器。</p>
  </li>
  <li>
    <p>healthcheck_send项：为了检测后端服务器的健康状态所发送的检测请求。然后根据各个服务器的响应情况来判断服务器是否存活。上面的配置表面，各个后台服务器上都存在<code>healthcheck.html</code>静态页面，然后nginx会get这个页面，根据是否status为200来判断是否服务器存活。</p>
  </li>
</ul>

<p><em>server配置块</em></p>

<p>在nginx中，不管怎么样的配置，都会有一个server配置块。http服务上支持若干虚拟主机。每个虚拟主机会有一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</p>

<blockquote>
  <blockquote>
    <p>Server其实就是一个虚拟主机。因为在nginx中可以配置多个server，这样就使得nginx可以在一台服务器上配置多个域名。</p>

    <p>在nginx的Server虚拟主机中，它只会处理与之对应的域名请求。并且，如果在listen中设置了ip地址，则该虚拟主机只会处理从该服务器的指定ip端口进来的请求，才会去处理。关于一台服务器设置多个别名ip地址的方式，可以参考博客<a href="http://www.cnblogs.com/mchina/archive/2012/05/21/2511824.html">在Nginx中部署基于IP的虚拟主机</a></p>
  </blockquote>
</blockquote>

<p>配置项说明：</p>

<ul>
  <li>
    <p>listen项：监听ip和端口。当nginx服务器的该ip端口有请求访问，则调用该server的配置来处理该请求。</p>
  </li>
  <li>
    <p>server_name项：域名。nginx对进入该虚拟主机的请求，检查其请求Host头是否匹配设置的server_name，如果是，则继续处理该请求。</p>
  </li>
  <li>
    <p>location块选项：Location在nginx中是一个非常重要的指令。对于HTTP请求，其被用来详细匹配URI和设置的location path。一般这个uri path会是字符串或者正则表达式形式。</p>
  </li>
</ul>

<blockquote>
  <blockquote>
    <p>: 关于location匹配，存在一些语法规则，如下：</p>

    <pre><code>  location [=|~|~*|^~|@] /uri/ { ... }
   =：表示精确匹配，如果找到，立即停止搜索并立即处理此请求。
   ~：表示区分大小写匹配。
   ~*：表示不区分大小写匹配。
   ^~：表示只匹配字符，串不查询正则表达式。
   @：指定一个命名的location，一般只用于内部重定向请求。
</code></pre>
  </blockquote>
</blockquote>

<ul>
  <li>
    <p>location中proxy_pass项：代理转发。配置了该项，当匹配location path的请求进来后，会根据upstream设置，请求后台服务器上的proxy_pass的请求。例如，上面的配置，当有请求<code>cc.local.com</code>时，由于精确匹配<code>=/</code>，则根据proxy_pass配置，则会反向代理，请求<code>192.168.1.101:80/bm/index.htm</code>。</p>
  </li>
  <li>
    <p>location中proxy_set_header项：设置代理请求头。由于经过了反向代理服务器，所以后台服务器不能获取真正的客户端请求地址等信息，这样，就需要把这些ip地址，设置回请求头部中。然后，我们在后台服务上，可以使用<code>request.get("X-Real-IP")</code>或者<code>request.get("X-Forwarded-For")</code>获取真实的请求ip地址。获取host也是如此。具体可以参考博文：<a href="http://gong1208.iteye.com/blog/1559835"> 使用nginx后如何在web应用中获取用户ip及原理解释</a>.</p>
  </li>
</ul>

<h2 id="a-idprocessrequestnginx-a"><a id="ProcessRequest">Nginx 架构和请求处理流程</a></h2>

<p>Nginx架构，在taobao的<a href="http://tengine.taobao.org/book/chapter_02.html">《Nginx开发从入门到精通》</a>电子书中，写的比较详细。这里记录一些核心的细节。</p>

<p>Nginx在启动会以daemon形式在后台运行，采用<code>多进程+异步非阻塞IO事件模型</code>来处理各种连接请求。</p>

<p>Nginx主要包含一个master进行和多个worker进行，一般worker进程个数是根据服务器CPU核数来决定的。如下图：</p>

<p><img src="http://kxcoder.github.io/images/2015/08/nginx_process.png" /></p>

<blockquote>
  <blockquote>
    <p>Notes：从上图中可以很明显地看到，4个worker进程的父进程都是master进程，表明worker进程都是从父进程fork出来的，并且父进程的ppid为1，表示其为daemon进程。</p>

    <p>需要说明的是，在nginx多进程中，每个worker都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p>

  </blockquote>
</blockquote>

<p>下面来介绍一个请求进来，进程模型的处理方式。</p>

<p><em>首先</em>，master进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。</p>

<p><em>其次</em>，根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</p>

<p><em>然后</em>，这个时候有多个worker进程都在监听同样设置的socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的<code>惊群现象</code>。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个<code>accept_mutex</code>类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</p>

<p><em>最后</em>，注册成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。</p>

<blockquote>
  <blockquote>
    <p>进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个worker进程出现异常退出，其他worker进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样子会提高处理效率，并且开发调试也更容易。</p>

    <p>如前文所述，<code>多进程模型+异步非阻塞模型</code>才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。</p>

    <p>关于异步非阻塞IO模型：linux的epoll介绍，可以参考：<a href="http://www.cppblog.com/deane/articles/165218.html">深入了解epoll </a></p>
  </blockquote>
</blockquote>

<h3 id="nginx-">Nginx 连接和请求处理</h3>

<p>上一节介绍了，worker进程会竞争客户端的连接请求，这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠web服务器环境下。</p>

<p>针对这种现象，Nginx采用了一个是否打开accept_mutex选项的值<code>ngx_accept_disabled</code>。标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件。</p>

<blockquote>
  <blockquote>
    <p>ngx_accept_disabled值，nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled。</p>

    <p>当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。</p>
  </blockquote>
</blockquote>

<p>接下来，看看连接处理流程（来自tengine.taobao.org）：</p>

<p><img src="http://kxcoder.github.io/images/2015/08/request_process.png" /></p>

<blockquote>
  <blockquote>
    <p>关于处理流程的说明，参考: <a href="http://tengine.taobao.org/book/chapter_02.html">http://tengine.taobao.org/book/chapter_02.html</a></p>

  </blockquote>
</blockquote>

<h2 id="a-idimplementationstudynginx-upstreamlocationa"><a id="ImplementationStudy">Nginx Upstream模块和Location配置</a></h2>

<p><em>Nginx Upstream</em></p>

<p>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。</p>

<p>从本质上说，upstream属于handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为upstream（上游）。请求并取得响应内容的整个过程已经被封装到nginx内部，所以upstream模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p>

<p><code>upstream</code>模块逻辑实现的十分复杂，对于其具体实现，不分析。</p>

<p><code>upstream</code>模块主要做两件事情：</p>

<ul>
  <li>
    <p>当外部的客户端发送一个http请求后，如果涉及更后台服务，则会创建一个到后端服务的request请求；</p>
  </li>
  <li>
    <p>请求到达后端，然后处理完成后，则upstream会将返回的数据接收过来，然后发送给外部请求的客户端。</p>
  </li>
</ul>

<p><em>Nginx Location</em></p>

<p>首先，介绍下存在的几种Location配置方式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>nginx Location配置方式 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="nginx"><span class="line"><span class="k">location</span>  <span class="p">=</span> <span class="s">/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches the query / only.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">A</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span>  <span class="s">/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any query, since all queries begin with /, but regular</span>
</span><span class="line">  <span class="c1"># expressions and any longer conventional blocks will be</span>
</span><span class="line">  <span class="c1"># matched first.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">B</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span> <span class="s">/documents/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any query beginning with /documents/ and continues searching,</span>
</span><span class="line">  <span class="c1"># so regular expressions will be checked. This will be matched only if</span>
</span><span class="line">  <span class="c1"># regular expressions don&#39;t find a match.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">C</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span> <span class="s">^~</span> <span class="s">/images/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any query beginning with /images/ and halts searching,</span>
</span><span class="line">  <span class="c1"># so regular expressions will not be checked.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">D</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span> <span class="p">~</span><span class="sr">*</span> <span class="s">\.(gif|jpg|jpeg)</span>$ <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any request ending in gif, jpg, or jpeg. However, all</span>
</span><span class="line">  <span class="c1"># requests to the /images/ directory will be handled by</span>
</span><span class="line">  <span class="c1"># Configuration D.   </span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">E</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>示例请求：</p>

<ul>
  <li>/ -&gt; configuration A</li>
  <li>/index.html -&gt; configuration B</li>
  <li>/documents/document.html -&gt; configuration C</li>
  <li>/images/1.gif -&gt; configuration D</li>
  <li>/documents/1.jpg -&gt; configuration E</li>
</ul>

<p>解析匹配规则为：</p>

<ol>
  <li>
    <p>字符串精确匹配到一个带 “=” 号前缀的location，则停止，且使用这个location的配置；</p>
  </li>
  <li>
    <p>字符串匹配剩下的非正则和非特殊location，如果匹配到某个带 “^~” 前缀的location，则停止；</p>
  </li>
  <li>
    <p>正则匹配，匹配顺序为location在配置文件中出现的顺序。如果匹配到某个正则location，则停止，并使用这个location的配置；否则，使用步骤2中得到的具有最大字符串匹配的location配置。</p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>Notes：需要注意的是：<code>~ 开头</code>表示区分大小写的正则匹配；而<code>~*  开头</code>表示不区分大小写的正则匹配。<code>!~和!~*</code>分别为区分大小写不匹配及不区分大小写不匹配的正则</p>
  </blockquote>
</blockquote>

<h2 id="a-idenda"><a id="End">后记</a></h2>

<p>Nginx 是一个十分优秀的服务器软件，其内部相当多的设计和实现都非常巧妙和高效。</p>

<p>关于Nginx的一些好的站点有：</p>

<ul>
  <li><a href="http://tengine.taobao.org/book/">http://tengine.taobao.org/book/</a></li>
  <li><a href="http://www.pagefault.info/?cat=7">http://www.pagefault.info/?cat=7</a></li>
  <li><a href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></li>
  <li><a href="http://kxcoder.github.io/images/2015/08/nginx_stream.png">http://kxcoder.github.io/images/2015/08/nginx_stream.png</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Java编程风格指南]]></title>
    <link href="http://kxcoder.github.io/blog/2014/04/16/google-java-style/"/>
    <updated>2014-04-16T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/04/16/google-java-style</id>
    <content type="html"><![CDATA[<p>说明：来自互联网，如有版权问题，请告知本人将其撤下。</p>

<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#SFBasic">源文件基础</a></li>
  <li><a href="#SFStruct">源文件结构</a></li>
  <li><a href="#Format">格式</a></li>
  <li><a href="#Naming">命名约定</a></li>
  <li><a href="#Practice">编程实践</a></li>
  <li><a href="#Javadoc">Javadoc</a></li>
  <li><a href="#End">后记</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，
我们才认为它符合Google的Java编程风格。</p>

<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，
同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，
对于那些不是明确强制要求的，我们尽量避免提供意见。</p>

<!--more-->

<h3 id="section-1">1.1 术语说明</h3>

<p>在本文档中，除非另有说明：</p>

<ol>
  <li>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)</li>
  <li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li>
</ol>

<p>其他的术语说明会偶尔在后面的文档出现。</p>

<h3 id="section-2">1.2 指南说明</h3>

<p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。
示例中的格式选择不应该被强制定为规则。</p>

<h2 id="a-idsfbasica"><a id="SFBasic">源文件基础</a></h2>

<h3 id="section-3">2.1 文件名</h3>

<p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>

<h3 id="utf-8">2.2 文件编码：UTF-8</h3>

<p>源文件编码格式为UTF-8。</p>

<h3 id="section-4">2.3 特殊字符</h3>

<h4 id="section-5">2.3.1 空白字符</h4>

<p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>

<ol>
  <li>所有其它字符串中的空白字符都要进行转义。</li>
  <li>制表符不用于缩进。</li>
</ol>

<h4 id="section-6">2.3.2 特殊转义序列</h4>

<p>对于具有特殊<a href="http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">转义序列</a>的任何字符(\b, \t, \n, \f, \r, ", '及\)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或Unicode(比如<code>\u000a</code>)转义。</p>

<h4 id="ascii">2.3.3 非ASCII字符</h4>

<p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>

<blockquote>
  <blockquote>
    <p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
  </blockquote>
</blockquote>

<p>例如：</p>

<pre><code>String unitAbbrev = "μs";                                 | 赞，即使没有注释也非常清晰
String unitAbbrev = "\u03bcs"; // "μs"                    | 允许，但没有理由要这样做
String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错
String unitAbbrev = "\u03bcs";                            | 很糟，读者根本看不出这是什么
return '\ufeff' + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释
</code></pre>

<blockquote>
  <blockquote>
    <p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，
你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p>
  </blockquote>
</blockquote>

<h2 id="a-idsfstructa"><a id="SFStruct">源文件结构</a></h2>

<p>一个源文件包含(按顺序地)：</p>

<ol>
  <li>许可证或版权信息(如有需要)</li>
  <li>package语句</li>
  <li>import语句</li>
  <li>一个顶级类(<strong>只有一个</strong>)</li>
</ol>

<p>以上每个部分之间用一个空行隔开。</p>

<h3 id="section-7">3.1 许可证或版权信息</h3>

<p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>

<h3 id="package">3.2 package语句</h3>

<p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>

<h3 id="import">3.3 import语句</h3>

<h4 id="import-1">3.3.1 import不要使用通配符</h4>

<p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>

<h4 id="section-8">3.3.2 不要换行</h4>

<p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p>

<h4 id="section-9">3.3.3 顺序和间距</h4>

<p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>

<ol>
  <li>所有的静态导入独立成组</li>
  <li><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)</li>
  <li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li>
  <li><code>java</code> imports</li>
  <li><code>javax</code> imports</li>
</ol>

<p>组内不空行，按字典序排列。</p>

<h3 id="section-10">3.4 类声明</h3>

<h4 id="section-11">3.4.1 只有一个顶级类声明</h4>

<p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>

<p>例外：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>

<h4 id="section-12">3.4.2 类成员顺序</h4>

<p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。
最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，
新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>

<h5 id="section-13">3.4.2.1 重载：永不分离</h5>

<p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>

<h2 id="a-idformata"><a id="Format">格式</a></h2>

<p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>

<h3 id="section-14">4.1 大括号</h3>

<h4 id="section-15">4.1.1 使用大括号(即使是可选的)</h4>

<p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>

<h4 id="k--r-">4.1.2 非空块：K &amp; R 风格</h4>

<p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格
(<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a>):</p>

<ul>
  <li>左大括号前不换行</li>
  <li>左大括号后换行</li>
  <li>右大括号前换行</li>
  <li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>

<p>示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>非空块：K &amp; R 风格 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">return</span> <span class="k">new</span> <span class="nf">MyClass</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">  <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">      <span class="k">try</span> <span class="o">{</span>
</span><span class="line">        <span class="n">something</span><span class="o">();</span>
</span><span class="line">      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ProblemException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">recover</span><span class="o">();</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.8.1节给出了enum类的一些例外。</p>

<h4 id="section-16">4.1.3 空块：可以用简洁版本</h4>

<p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally)
，即使大括号内没内容，右大括号也要换行。</p>

<p>示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>空块：可以用简洁版本 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kt">void</span> <span class="nf">doNothing</span><span class="o">()</span> <span class="o">{}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-17">4.2 块缩进：2个空格</h3>

<p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>

<h3 id="section-18">4.3 一行一个语句</h3>

<p>每个语句后要换行。</p>

<h3 id="section-19">4.4 列限制：80或100</h3>

<p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>

<p>例外：</p>

<ol>
  <li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li>
  <li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。</li>
  <li>注释中那些可能被剪切并粘贴到shell中的命令行。</li>
</ol>

<h3 id="section-20">4.5 自动换行</h3>

<p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>

<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>

<blockquote>
  <blockquote>
    <p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
  </blockquote>
</blockquote>

<h4 id="section-21">4.5.1 从哪里断开</h4>

<p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>

<ol>
  <li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。
这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
  <li>如果在<code>赋值运算符</code>处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>
  <li>方法名或构造函数名与左括号留在同一行。</li>
  <li>逗号(,)与其前面的内容留在同一行。</li>
</ol>

<h4 id="section-22">4.5.2 自动换行时缩进至少+4个空格</h4>

<p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>

<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>

<p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>

<h3 id="section-23">4.6 空白</h3>

<h4 id="section-24">4.6.1 垂直空白</h4>

<p>以下情况需要使用一个空行：</p>

<ol>
  <li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。
    <ul>
      <li><strong>例外</strong>：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
    </ul>
  </li>
  <li>在函数体内，语句的逻辑分组间使用空行。</li>
  <li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
  <li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
</ol>

<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>

<h4 id="section-25">4.6.2 水平空白</h4>

<p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>

<ol>
  <li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li>
  <li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>
  <li>在任何左大括号前(<code>{</code>)，两个例外：
    <ul>
      <li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
      <li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>
    </ul>
  </li>
  <li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：
    <ul>
      <li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
      <li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
      <li><code>foreach</code>语句中的分号。</li>
    </ul>
  </li>
  <li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
  <li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
  <li>类型和变量之间：List<string> list。</string></li>
  <li>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</li>
</ol>

<blockquote>
  <blockquote>
    <p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
  </blockquote>
</blockquote>

<h4 id="section-26">4.6.3 水平对齐：不做要求</h4>

<p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>

<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>

<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>水平对齐：不做要求 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// this is fine</span>
</span><span class="line"><span class="kd">private</span> <span class="n">Color</span> <span class="n">color</span><span class="o">;</span> <span class="c1">// this too</span>
</span><span class="line">
</span><span class="line"><span class="kd">private</span> <span class="kt">int</span>   <span class="n">x</span><span class="o">;</span>      <span class="c1">// permitted, but future edits</span>
</span><span class="line"><span class="kd">private</span> <span class="n">Color</span> <span class="n">color</span><span class="o">;</span>  <span class="c1">// may leave it unaligned</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。
这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，
这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
  </blockquote>
</blockquote>

<h3 id="section-27">4.7 用小括号来限定组：推荐</h3>

<p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。
我们没有理由假设读者能记住整个Java运算符优先级表。</p>

<h3 id="section-28">4.8 具体结构</h3>

<h4 id="section-29">4.8.1 枚举类</h4>

<p>枚举常量间用逗号隔开，换行可选。</p>

<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>枚举类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">private</span> <span class="kd">enum</span> <span class="n">Suit</span> <span class="o">{</span> <span class="n">CLUBS</span><span class="o">,</span> <span class="n">HEARTS</span><span class="o">,</span> <span class="n">SPADES</span><span class="o">,</span> <span class="n">DIAMONDS</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>

<h4 id="section-30">4.8.2 变量声明</h4>

<h5 id="section-31">4.8.2.1 每次只声明一个变量</h5>

<p>不要使用组合声明，比如<code>int a, b;</code>。</p>

<h5 id="section-32">4.8.2.2 需要时才声明，并尽快进行初始化</h5>

<p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。
局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>

<h4 id="section-33">4.8.3 数组</h4>

<h5 id="section-34">4.8.3.1 数组初始化：可写成块状结构</h5>

<p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>数组初始化：可写成块状结构</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
</span><span class="line">  <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
</span><span class="line">  <span class="mi">0</span><span class="o">,</span>
</span><span class="line">  <span class="mi">1</span><span class="o">,</span>
</span><span class="line">  <span class="mi">2</span><span class="o">,</span>
</span><span class="line">  <span class="mi">3</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
</span><span class="line">  <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
</span><span class="line">  <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span>
</span><span class="line">    <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="c">4.8.3.2 非C风格的数组声明</h5>

<p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p>

<h4 id="switch">4.8.4 switch语句</h4>

<p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>

<h5 id="section-35">4.8.4.1 缩进</h5>

<p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>

<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>

<h5 id="fall-through">4.8.4.2 Fall-through：注释</h5>

<p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，
任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Fall-through：注释</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">switch</span> <span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class="line">  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class="line">    <span class="n">prepareOneOrTwo</span><span class="o">();</span>
</span><span class="line">    <span class="c1">// fall through</span>
</span><span class="line">  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class="line">    <span class="n">handleOneTwoOrThree</span><span class="o">();</span>
</span><span class="line">    <span class="k">break</span><span class="o">;</span>
</span><span class="line">  <span class="k">default</span><span class="o">:</span>
</span><span class="line">    <span class="n">handleLargeNumber</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="default">4.8.4.3 default的情况要写出来</h5>

<p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>

<h4 id="annotations">4.8.5 注解(Annotations)</h4>

<p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注解 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="nd">@Override</span>
</span><span class="line"><span class="nd">@Nullable</span>
</span><span class="line"><span class="kd">public</span> <span class="n">String</span> <span class="nf">getNameIfPresent</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注解 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注解 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="nd">@Partial</span> <span class="nd">@Mock</span> <span class="n">DataLoader</span> <span class="n">loader</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>参数和局部变量注解没有特定规则。</p>

<h4 id="section-36">4.8.6 注释</h4>

<h5 id="section-37">4.8.6.1 块注释风格</h5>

<p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... */</code>风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<code>*</code>开始，
并且与前一行的<code>*</code>对齐。以下示例注释都是OK的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注释 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/*</span>
</span><span class="line"><span class="cm"> * This is          // And so           /* Or you can</span>
</span><span class="line"><span class="cm"> * okay.            // is this.          * even do this. */</span>
</span><span class="line"> <span class="o">*/</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>

<blockquote>
  <blockquote>
    <p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p>
  </blockquote>
</blockquote>

<h4 id="modifiers">4.8.7 Modifiers</h4>

<p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Modifiers </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">protected</span> <span class="kd">private</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kd">synchronized</span> <span class="kd">native</span> <span class="kd">strictfp</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idnaminga"><a id="Naming">命名约定</a></h2>

<h3 id="section-38">5.1 对所有标识符都通用的规则</h3>

<p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p>

<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>

<h3 id="section-39">5.2 标识符类型的规则</h3>

<h4 id="section-40">5.2.1 包名</h4>

<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>

<h4 id="section-41">5.2.2 类名</h4>

<p>类名都以<code>UpperCamelCase</code>风格编写。</p>

<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>

<p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>

<h4 id="section-42">5.2.3 方法名</h4>

<p>方法名都以<code>lowerCamelCase</code>风格编写。</p>

<p>方法名通常是动词或动词短语。</p>

<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。
并不存在唯一正确的方式来命名测试方法。</p>

<h4 id="section-43">5.2.4 常量名</h4>

<p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>

<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，
考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。
只是永远不<code>打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>常量名 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="c1">// Constants</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NUMBER</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">NAMES</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;Ed&quot;</span><span class="o">,</span> <span class="s">&quot;Ann&quot;</span><span class="o">);</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Joiner</span> <span class="n">COMMA_JOINER</span> <span class="o">=</span> <span class="n">Joiner</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="sc">&#39;,&#39;</span><span class="o">);</span>  <span class="c1">// because Joiner is immutable</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">SomeMutableType</span><span class="o">[]</span> <span class="n">EMPTY_ARRAY</span> <span class="o">=</span> <span class="o">{};</span>
</span><span class="line"><span class="kd">enum</span> <span class="n">SomeEnum</span> <span class="o">{</span> <span class="n">ENUM_CONSTANT</span> <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Not constants</span>
</span><span class="line"><span class="kd">static</span> <span class="n">String</span> <span class="n">nonFinal</span> <span class="o">=</span> <span class="s">&quot;non-final&quot;</span><span class="o">;</span>
</span><span class="line"><span class="kd">final</span> <span class="n">String</span> <span class="n">nonStatic</span> <span class="o">=</span> <span class="s">&quot;non-static&quot;</span><span class="o">;</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">mutableCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">SomeMutableType</span><span class="o">&gt;</span> <span class="n">mutableElements</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">mutable</span><span class="o">);</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">MyClass</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">nonEmptyArray</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;these&quot;</span><span class="o">,</span> <span class="s">&quot;can&quot;</span><span class="o">,</span> <span class="s">&quot;change&quot;</span><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这些名字通常是名词或名词短语。</p>

<h4 id="section-44">5.2.5 非常量字段名</h4>

<p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>

<p>这些名字通常是名词或名词短语。</p>

<h4 id="section-45">5.2.6 参数名</h4>

<p>参数名以<code>lowerCamelCase</code>风格编写。</p>

<p>参数应该避免用单个字符命名。</p>

<h4 id="section-46">5.2.7 局部变量名</h4>

<p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>

<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>

<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>

<h4 id="section-47">5.2.8 类型变量名</h4>

<p>类型变量可用以下两种风格之一进行命名：</p>

<ul>
  <li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
  <li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>

<h3 id="camelcase">5.3 驼峰式命名法(CamelCase)</h3>

<p><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。
有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>

<p>名字从<code>散文形式</code>(prose form)开始:</p>

<ol>
  <li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
  <li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。
    <ul>
      <li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。
 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
    </ul>
  </li>
  <li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：
    <ul>
      <li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
      <li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
    </ul>
  </li>
  <li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>

<p>示例：</p>

<pre><code>Prose form                Correct               Incorrect
------------------------------------------------------------------
"XML HTTP request"        XmlHttpRequest        XMLHTTPRequest
"new customer ID"         newCustomerId         newCustomerID
"inner stopwatch"         innerStopwatch        innerStopWatch
"supports IPv6 on iOS?"   supportsIpv6OnIos     supportsIPv6OnIOS
"YouTube importer"        YouTubeImporter
                          YoutubeImporter*
</code></pre>

<p>加星号处表示可以，但不推荐。</p>

<blockquote>
  <blockquote>
    <p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>
  </blockquote>
</blockquote>

<h2 id="a-idpracticea"><a id="Practice">编程实践</a></h2>

<h3 id="override">6.1 @Override：能用则用</h3>

<p>只要是合法的，就把<code>@Override</code>注解给用上。</p>

<h3 id="section-48">6.2 捕获的异常：不能忽视</h3>

<p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>

<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>捕获的异常 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">try</span> <span class="o">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
</span><span class="line">  <span class="k">return</span> <span class="nf">handleNumericResponse</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NumberFormatException</span> <span class="n">ok</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">  <span class="c1">// it&#39;s not numeric; that&#39;s fine, just continue</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line"><span class="k">return</span> <span class="nf">handleTextResponse</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>例外</strong>：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，
因此在这里就没有必要加注释。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>捕获的异常 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">try</span> <span class="o">{</span>
</span><span class="line">  <span class="n">emptyStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span><span class="line">  <span class="n">fail</span><span class="o">();</span>
</span><span class="line"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchElementException</span> <span class="n">expected</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-49">6.3 静态成员：使用类进行调用</h3>

<p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>静态成员 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">Foo</span> <span class="n">aFoo</span> <span class="o">=</span> <span class="o">...;</span>
</span><span class="line"><span class="n">Foo</span><span class="o">.</span><span class="na">aStaticMethod</span><span class="o">();</span> <span class="c1">// good</span>
</span><span class="line"><span class="n">aFoo</span><span class="o">.</span><span class="na">aStaticMethod</span><span class="o">();</span> <span class="c1">// bad</span>
</span><span class="line"><span class="n">somethingThatYieldsAFoo</span><span class="o">().</span><span class="na">aStaticMethod</span><span class="o">();</span> <span class="c1">// very bad</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="finalizers-">6.4 Finalizers: 禁用</h3>

<p>极少会去重载<code>Object.finalize</code>。</p>

<blockquote>
  <blockquote>
    <p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href="http://books.google.com/books?isbn=8131726592">Effective Java</a>
第7条款：“Avoid Finalizers”，然后不要使用它。</p>
  </blockquote>
</blockquote>

<h2 id="a-idjavadocjavadoca"><a id="Javadoc">Javadoc</a></h2>

<h3 id="section-50">7.1 格式</h3>

<h4 id="section-51">7.1.1 一般形式</h4>

<p>Javadoc块的基本格式如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Javadoc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * Multiple lines of Javadoc text are written here,</span>
</span><span class="line"><span class="cm"> * wrapped normally...</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">method</span><span class="o">(</span><span class="n">String</span> <span class="n">p1</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者是以下单行形式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Javadoc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/** An especially short bit of Javadoc. */</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>

<h4 id="section-52">7.1.2 段落</h4>

<p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。
除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p>

<h4 id="javadoc">7.1.3 Javadoc标记</h4>

<p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。
当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>

<h3 id="section-53">7.2 摘要片段</h3>

<p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>

<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头,
它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>

<blockquote>
  <blockquote>
    <p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>
  </blockquote>
</blockquote>

<h3 id="javadoc-1">7.3 哪里需要使用Javadoc</h3>

<p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>

<h4 id="section-54">7.3.1 例外：不言自明的方法</h4>

<p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>

<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>

<blockquote>
  <blockquote>
    <p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，
就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>
  </blockquote>
</blockquote>

<h4 id="section-55">7.3.2 例外：重载</h4>

<p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>

<h4 id="javadoc-2">7.3.3 可选的Javadoc</h4>

<p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，
那么这个注释应该写成Javadoc，这样更统一更友好。</p>

<h2 id="a-idenda"><a id="End">后记</a></h2>

<p>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a>，
译者<a href="http://weibo.com/hawstein">@Hawstein</a>。</p>
]]></content>
  </entry>
  
</feed>
