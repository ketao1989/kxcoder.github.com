<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[柯小小西の小水滴]]></title>
  <link href="http://kxcoder.github.io/atom.xml" rel="self"/>
  <link href="http://kxcoder.github.io/"/>
  <updated>2015-10-07T10:46:17+08:00</updated>
  <id>http://kxcoder.github.io/</id>
  <author>
    <name><![CDATA[柯小小西]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Zookeeper 编程指南]]></title>
    <link href="http://kxcoder.github.io/blog/2015/09/05/zookeeper-programmer-guide/"/>
    <updated>2015-09-05T20:52:39+08:00</updated>
    <id>http://kxcoder.github.io/blog/2015/09/05/zookeeper-programmer-guide</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Introduction">前言</a></li>
  <li><a href="#The_ZooKeeper_Data_Model">Zookeeper 数据模型</a></li>
  <li><a href="#ZooKeeper_Sessions">Zookeeper 会话</a></li>
  <li><a href="#ZooKeeper_Watches">Zookeeper 监听</a></li>
  <li><a href="#ZooKeeper_ACL">ZooKeeper 使用 ACL 访问控制</a></li>
</ol>

<h2 id="a-idintroduction1-a"><a id="Introduction">1 前言</a></h2>

<p>该文档是提供给期望使用 <code>Zookeeper</code>协作服务功能的开发者创建分布式应用的。文档内部包含了一些概念上和实践应用上的资料信息。</p>

<p>在指南的前四节主要讨论了 <code>Zookeeper</code> 各方面的概念。这些东西对于理解 <code>Zookeeper</code>如何工作以及如何去使用 <code>Zookeeper</code> 是非常必要的。它虽然没有包含源代码，但是它是假设读者对于分布式计算相关的问题是很熟悉的。它们主要如下介绍：</p>

<ul>
  <li><a href="#The_ZooKeeper_Data_Model">Zookeeper 数据模型</a></li>
  <li><a href="#ZooKeeper_Sessions">Zookeeper 会话</a></li>
  <li><a href="#ZooKeeper_Watches">Zookeeper 监听</a></li>
  <li><a href="#Consistency_Guarantees">Zookeeper 一致性保证</a></li>
</ul>

<!--more-->

<p>后面四节主要提供了一些实践编程相关的资料。主要是：</p>

<ul>
  <li><a href="#A_Guide_to_ZooKeeper_Operations">Zookeeper 操作指南</a></li>
  <li><a href="#Bindings">Zookeeper Bindings</a></li>
  <li><a href="#Program_Structure">Zookeeper 程序结构简单示例（待定）</a></li>
  <li><a href="#Gotchas">Zookeeper 性能和可伸缩性</a></li>
</ul>

<p>文档最后的附录部分包含了一些有用的，Zookeeper 相关的链接。</p>

<p>虽然，该指南中的很多资料在其他一些独立的文章博客中都已经存在了，但是对于开始第一个 <code>Zookeeper</code> 应用的你来说，还是最后阅读完<code>Zookeeper 数据模型</code> 和 <code>Zookeeper 操作指南</code>。</p>

<h2 id="a-idthezookeeperdatamodel-2-zookeeper-a"><a id="The_ZooKeeper_Data_Model"> 2 Zookeeper 数据模型</a></h2>

<p><code>Zookeeper</code> 有一个分级的命名空间，类似于一个分布式的文件系统。唯一不同的是命名空间中每个节点可以有对应的数据关联它，就像孩子一样。这一点类似于文件系统中允许一个文件也可以成为目录一样。到节点的路径常常表示成正则的，绝对的，斜线分隔的路径；它们没有相对的引用。在路径上使用的任何编码需要满足以下限制：</p>

<ul>
  <li><code>null</code>字符不可以成为路径名字的一部分。</li>
  <li>由于显示的问题，如下字符不能使用：<code>\u0001</code>-<code>\u001F</code> 和 <code>\u007F</code>-<code>\u009F</code>.</li>
  <li>下面字符同样不被允许：<code>\ud800</code>-<code>\u0F8FF</code> 和 <code>\uFFF0</code>-<code>\uFFFF</code>.</li>
  <li><code>.</code>字符可以作为路径名字中某块名的一部分，但是<code>.</code>和<code>..</code>不能单独作为路径的一块，因为在 Zookeeper 中不允许相对路径。因此，如下是非法的：<code>/a/b/./c</code>或者<code>/a/b/../c</code>.</li>
  <li><code>zookeeper</code>字符串保留。</li>
</ul>

<h3 id="znodes">2.1 ZNodes</h3>

<p>ZooKeeper 树上的每一个节点都称之为<code>znode</code>。Znodes 维护了一个包含数据变化和acl变化版本号的状态结构体。这个结构体也包含时间戳。因此，版本号和时间戳一起确保Zookeeper验证缓存和协调更新。每一次znode的数据变化，版本号也会对应增长。例如，当一个客户端检索数据时，它也会获得该数据的版本号，然后当一个客户端执行更新或者删除时，它必须提供对应变化的znode的数据版本。如果它提供的版本不能够匹配到实际的数据版本时，更新将会失败。</p>

<blockquote>
  <blockquote>
    <p>Note:
在分布式应用工程中，<code>node</code>常常被看做一个主机，一台服务器，一组中的一个成员等等。在Zookeeper文档中，<code>znodes</code>称为数据节点；<code>Servers</code>则是标记为Zookeeper服务的机器；<code>quorum peers</code>是标记为一个集群的所有服务器；<code>client</code>是任何使用Zookeeper服务的机器或者进程。</p>

  </blockquote>
</blockquote>

<p>Znodes是开发者访问的最主要的实体。它们有一些值得去关注的特征：</p>

<h4 id="watches">2.1.1 Watches</h4>

<p>客户端可以在 znodes 上设置监听。znode 的改变将会触发监听器，然后清理监听。当一个监听器被触发时，Zookeeper 会发送对应客户端一个通知。更新的信息可以参考 <a href="#ZooKeeper_Watches">Zookeeper 监听</a>。</p>

<h4 id="section-1">2.1.2 数据访问</h4>

<p>保存在一个命名空间里的每个节点上的数据都可以被原子的读和写。读，获取对应znode上所有的数据字节；然后一个写，替换所有的数据。每个节点上的ACL(访问控制列表)可以限制<code>who can do what</code>。</p>

<p>Zookeeper 不是被设计用来作为一个通用的数据库或者大对象的存储。相反，它是用来管理协调数据的。这个数据来源于配置，状态信息，集结地点等形式中。一般，协调的数据相对来说是很小的：几千字节计算。Zookeeper 客户端和服务器实现的时候会确保znode的数据小于1M，但是通常数据会比那个小得多。操作相对大的数据将会导致一些操作会花费更对的时间，从而一些操作的延迟性，这主要是因为一些额外的时间需要被用来在网络上移动更多的数据，存储起来。如果一定需要大数据的存储，通常的处理方式是将数据存储在大容量存储系统上，比如 NFS 或者 HDFS ，然后再Zookeeper里保持存储位置的指针。</p>

<h4 id="section-2">2.1.3 短暂节点</h4>

<p>Zookeeper 也有短暂节点的概念。在会话创建时，znode存活；当会话结束时，znode删除。由于这个特性，所以其不允许有孩子。</p>

<h4 id="section-3">2.1.4 顺序节点-唯一命名</h4>

<p>当创建一个znode时，你也可以请求Zookeeper在路径的末尾增加一个单调递增的计算器。这个计算器对父节点来说是唯一的。计算器有一个<code>%010d</code>格式化–表示10个数字0补全。比如：<code>&lt;path&gt;0000000001</code>。Notes：计数器用来保存下一个顺序数字是一个有符号整形，由父节点保存，当增长到<code>2147483647</code>将会溢出。</p>

<h3 id="zookeeper--time">2.2 Zookeeper 中的 Time</h3>

<p>Zookeeper 追踪 time的多种方式如下：</p>

<ul>
  <li>
    <p>Zxid<br />
Zookeeper状态的每次改变，在<code>zxid</code>(ZooKeeper Transaction Id)里都会获取到一个时间戳。这意味着在ZooKeeper中所有都变化都是有序的。每次改变都将会有一个<code>zxid</code>，如果 zxid1 小于 zxid2，则 zxid1 一定在 zxid2 之前发生。</p>
  </li>
  <li>
    <p>版本号<br />
一个节点的每次改变都会导致对应节点的其中一个版本号递增。节点对应的三个版本号是：version(znode 数据改变对应的编号)；cversion(znode 的孩子改变对应的编号)；aversion(znode 的ACL改变对应的编号)。</p>
  </li>
  <li>
    <p>Ticks<br />
当使用多服务器的 ZooKeeper 时，服务器使用 <code>ticks</code> 来定义事件的时间，比如，状态上传，会话超时，连接超时等。tick 时间只能间接地表示最小的会话超时（每tick时间内2次）；如果一个客户端请求的会话超时小于最小的会话超时，则服务器将会告诉客户端它请求的会话超时实际上是最小的会话超时。</p>
  </li>
  <li>
    <p>真实时间<br />
ZooKeeper 不使用真实时间或者时钟时间，即使在所有我们期望把时间戳放入znode创建和修改的状态结构体里面。</p>
  </li>
</ul>

<h3 id="zookeeper-">2.3 ZooKeeper 状态结构体</h3>

<p>ZooKeeper 里每个 znode 的状态结构体都包括下面这些字段：</p>

<ul>
  <li>czxid<br />
导致znode被创建的zxid。</li>
  <li>mzxid<br />
对应znode最后一次改变的zxid。</li>
  <li>ctime<br />
当该znode创建开始的毫秒数。</li>
  <li>mtime<br />
当该znode最后一次更改开始的毫秒数。</li>
  <li>version<br />
znode数据改变的编号。</li>
  <li>cversion</li>
  <li>aversion</li>
  <li>ephemeralOwner<br />
如果该znode是临时节点，则为该节点owner的 会话id；如果不是临时节点，则为0。</li>
  <li>dataLength<br />
znode 数据字段的长度。</li>
  <li>numChildren<br />
znode对应孩子的个数。</li>
</ul>

<h2 id="a-idzookeepersessions-3-zookeeper-a"><a id="ZooKeeper_Sessions"> 3 Zookeeper 会话</a></h2>

<p>ZooKeeper 客户端通过绑定的编程语言创建一个 <code>handle</code>从而和ZooKeeper服务建立会话。一旦创建完成，<code>handle</code>开始处在  <code>CONNECTING</code> 状态，然后客户端将会和ZooKeeper服务中某个服务器连接上，然后其会切换到 <code>CONNECTED</code>状态。在通常的操作过程中，会处在这两张状态中的一种。如果发生了一个不可恢复的错误，比如会话过期或者认证失败，再或者如果应用显示地关闭 <code>handle</code>，则该 <code>handle</code> 将会转变为 <code>CLOSE</code> 状态。</p>

<p>下面的图展示了一个 ZooKeeper 客户端可能的状态流转情形：</p>

<p><img src="http://kxcoder.github.io/images/2015/09/zookeeper_stat.png" /></p>

<p>为了创建一个客户端会话，应用代码必须提供一个连接字符串，包含一个以逗号分隔的 <code>host:pair</code>列表, 每个<code>host:pair</code> 对应的是一台 ZooKeeper服务器（比如，”127.0.0.1:4545” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002”）。ZooKeeper 客户端会挑选任务的服务器，然后尝试去连接它。如果这个连接失败，或者这个客户端因为任何原因导致和这个服务器断开连接，客户端都将会自动尝试列表中的下一台服务器，知道一个连接被(重新)建立起来。</p>

<p><em>3.2.0 新特性</em>：一个可选择的”chroot”后缀也可能会添加到连接字符串中。和linux中的<code>chroot</code>命令相似，运行客户端的所有命令中的路径都是相对这个root来确定的。比如我们如果使用：”127.0.0.1:4545/app/a” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a”，则客户端将会以”/app/a” 为root，然后所有路径都是相对这个root而言的–例如，我们获取 “/foo/bar” 下面的文件，则实际上将会在 “app/a/foo/bar” 下面执行。这个特性对于多租户环境下是很有用的，这样每个用户在 ZooKeeper服务上其root都可以不同。因此，对于每个用户如果编码他们的应用中以”/”为root情况下，重复使用ZooKeeper服务将非常简单。</p>

<p>当一个客户端获取到ZooKeeper服务的一个<code>handle</code>，ZooKeeper 创建一个ZooKeeper 会话，以 64位数字表示。如果客户端连接到一台不同的 ZooKeeper服务器，它将会发送一个会话id作为连接握手的一部分。作为一个安全手段，服务器为该会话id创建一个任何ZooKeeper服务器都可以验证的password。当客户端建立完会话之后，password 将会和会话id一起发送给客户端。当客户端需要和新的服务器重新建立连接时，则发送该password 和 会话id。</p>

<p>ZooKeeper 客户端库调用创建一个ZooKeeper会话时，其中有一个参数是毫秒数的会话超时。客户端发送一个请求超时，服务器将响应从客户端获取的超时。当前的时候要求超时时间最小为 2 个 tckTime，并且最大为 20 个 tickTime。ZooKeeper 客户端API 运行访问协商的超时。</p>

<p>当一个客户端（会话）从ZK服务集群里分隔开，它将会开始搜素我们在创建会话时候指定的服务器列表。最后，当客户端和至少服务器中的一台重新建立连接后，会话将会要么转化为 <code>connected</code>状态（如果会话重连接在超时值之内），要么转化为<code>expired</code>状态（如果重连在会话超时之后）。为断开连接的客户端创建一个新的会话对象是不明智的。ZK 客户端库将会为你处理重连。在实践中，我们在客户端库中会有一些启发式的算法构建来处理像”羊群效应”等事情。只有在收到会话过期通过时，才会去创建一个新的会话。</p>

<p>会话过期由ZooKeeper集群自己管理，而不是客户端。当ZK客户端和集群建立会话时，其提供一个超时值。集群使用这个值来决定客户端会话是否超时。当集群没有在超时时间内收到返回，则发送会话过期。在会话过期的时候，集群将会删除该会话拥有的所有的临时节点，然后立即通知监听该变化的所有连接状态的客户端。在这个时间点，超时会话的客户端仍然和集群断开连接，在重新和集群建立连接之前，它将不会收到会话超时的通知。客户端将会一直带着断开连接的状态，知道TCP连接被重新建立起来，然后 超时会话的<code>watcher</code>将会接收到”会话超时”的通知。</p>

<p>一个超时的会话状态流转的过程示例：</p>

<ol>
  <li>connected：会话建立连接，客户端和集群处于通信中。</li>
  <li>客户端从集群中分割开…</li>
  <li>disconnected：客户端丢失和集群之间的连接</li>
  <li>… 时间过去了，在 超时区间之后，集群过期了会话，客户端由于和集群断开了所以看不到任何东西。</li>
  <li>… 时间进行走着，客户端恢复了和集群的网络层连接、</li>
  <li>expired：最终，客户端重新连接上集群，然后被通知过期。</li>
</ol>

<p>ZooKeeper 建立会话调用的另一个蚕食是默认的 <code>watcher</code>。当在客户端上的状态发送变更，watcher 将会被通知到。例如，如果一个客户端丢失了和服务器之间的连接，则客户端将会收到通知，或者如果客户端会话过期了。watcher 应该认为初始状态是 断开连接的。在一个新连接的case里面，发送给 watcher 的第一个通知就是会话连接事件。</p>

<p>会话通过客户端发送请求保持alive。如果会话空闲了会话超时时间段时，客户端将会发送 <code>PING</code>请求来保持会话alive。<code>PING</code>请求不仅允许 ZooKeeper服务器知道 客户端仍然活跃，也允许客户端通过连接验证 ZooKeeper服务器仍然活跃。<code>PING</code>的时间很充足，从而确保有在检测到死连接，然后重新连接到新的server的操作有足够的时间。</p>

<p>一旦一个到服务器的连接成功的建立了，客户端 lib 有两个基本的case 导致 连接丢失，当执行一个同步或者异步操作，然后出现如下情况：</p>

<ol>
  <li>在一个不再活跃/有效的会话上调用一个操作。</li>
  <li>当ZooKeeper客户端挂起一个操作时，断开和服务器之间的连接。</li>
</ol>

<p><em>3.2.0 新特性–SessionMovedException</em>：这是一个内部的异常。这个异常一般发生在一个会话和不同的服务器重新建立连接后接收到请求的时候。正常导致这个错误的原因是一个哭护短发生一个请求给一个服务器，但是网络包延迟，所以客户端超时，然后和新的服务器建立间接。当延迟的包被第一台服务器收到时，老的服务器检测到会话已经被移开，然后关闭客户端连接。客户端正常下不会看着这个错误，因为他不会从老的连接中读数据。出现这种情况的一个条件是当两个客户端尝试使用 password 和 会话id 重新建立相同的连接，其中一个客户端将重新建立连接，第二个客户端将会断开连接。</p>

<p><em>更新服务器列表</em>：我们允许客户端通过提供一组新的逗号分隔的<code>host:port</code>对列表来更新连接字符串。这个函数调用一个基于概率的负载均衡算法导致客户端断开和当前host的连接，从而达到服务器列表中连接的平均数。万一当前客户端连接的host不在新的列表中，这个调用将会导致连接被丢弃。另外，决定服务器数量的增加或者减少以及多少。</p>

<p>例如：如果前面的连接字符串包含 3 host，然后现在列表包含这 3 个 host和 2 个新加的 host，40%的客户端原来对应的连接将会迁移到新的hosts中的一个来确保均衡负载。这个方案将会导致客户端丢弃他的连接，然后0.4的概率连接到其他2台机器，在这种情况下，导致客户端随机选择连接 2 个新的host中的一台。</p>

<p>另一个例子–假设我们有5 台host，现在我们更新服务器列表移走 2 台host，然后客户端连接剩下 3 台host的依然连接，然后 移除的2台 host上的连接将被移动到剩下 3 台host的其中一台。如果连接丢弃，客户端移动到指定的模式，其可以选择一个新的服务器去根据概率算法连接服务器，而不是 RR。</p>

<p>在第一个例子中，每个客户端决定以0.4的概率来断开连接，但是一旦做完决定，它将尝试随机连接到一个新的服务器，仅仅在不能连接到新的服务器中的任何一台时，它才会尝试连接老的服务器。在找到一个服务器，或者尝试列表中所有的服务器，仍然连接失败的时候，客户端回退到正常的操作模式(从概率模式回到轮询RR模式)，即从连接字符串中选择任意的服务器，然后尝试连接它。如果失败，它将以RR模式尝试不同随机服务器。</p>

<h2 id="a-idzookeeperwatches-4-zookeeper-a"><a id="ZooKeeper_Watches"> 4 Zookeeper 监听</a></h2>

<p>在 ZooKeeper 里所有的读操作（getData()，getChildren()和 exists()）都可以将设置一个 <code>watch</code> 作为附加功能。ZooKeeper 对 <code>watch</code>的定义是：一个监听事件是一次性的 <code>trigger</code>，当监听的数据发送变化的时候，发送给设置监听的客户端们。对于这个定义，有三个关键点：</p>

<ul>
  <li>
    <p>One-time trigger<br />
当监听数据发送变化的时候，一个监听事件将会发送给客户端。例如，一个客户端使用 <code>getData("/znode1", true)</code>，然后<code>/znode1</code>的数据发送变化或者删除，客户端将会获得一个对应 <code>/znode1</code>的监听事件。<em>但是，如果<code>/znode1</code>再次改变，就不会再有监听事件发送出去，除非客户端通过另一个读操作来设置监听watch</em></p>
  </li>
  <li>
    <p>Sent to client<br />
这意味着一个正发送给客户端的事件，可能在发送修改操作的客户端完成操作返回成功 code 之前不会到达客户端。监听事件是异步发送给监听客户端的。ZooKeeper 提供一个有序的保证：一个客户端永远只有在看到一个watch事件之后才会看到这个watch对应的改变。网络延迟或者其他原因可能导致不同的客户端看到watch和更新返回code的时间不同。其关键之处在于不同客户端看到的所有事情都是有一致性的顺序的。</p>
  </li>
  <li>
    <p>The data for which the watch was set<br />
这指的是节点改变的不同方式。你可以认为 ZooKeeper 维护 watch的两个列表：数据watch 和 孩子watch。<code>getData()</code>和<code>exists()</code>设置数据watch；<code>getChildren()</code> 设置child监听。此外，你也可以认为 watch 可以根据数据返回的类型来设置。<code>getData()</code>和<code>exists()</code> 返回节点数据的信息，然而<code>getChildren()</code> 返回 孩子列表。因此，<code>setData()</code>将触发节点的数据watch 设置。一个成功的<code>create()</code>将会触发znode的数据watch 以及 父节点的child watch。一个成功的 <code>delete()</code>将会触发节点的数据watch和child watch（因为将不会再有children了）。</p>
  </li>
</ul>

<p>watch 由与对应client连接的ZooKeeper服务器负责维护。因此，这可以使得 watch 可以轻量级地设置，维护和分发。当一个客户端连接到一个新的server，watch将会出现会话时间。当和server断开连接后，将不会收到watch。当一个客户端重新连接，任务先前注册的watch将会被重新注册，然后当需要的时候触发。一般情况下，这都是显示地发生的。有一个case就是一个watch可能被丢失：一个人还未创建的znode的 existence watch 将会被丢失，如果这个znode 创建，然后当断开连接的时候又被删除了。</p>

<h3 id="watch-">4.1 watch 语义</h3>

<p>我们可以通过读ZooKeeper的三种状态来设置 watch：exists, getData, 和
getChildren。下面的列表展示了一个watch 触发和调用激活的方式：</p>

<ul>
  <li>Created event:<br />
通过 exist调用激活。</li>
  <li>Deleted event:<br />
通过调用 exists, getData, 和 getChildren 激活</li>
  <li>Changed event:<br />
通过调用 exists, getData 激活。</li>
  <li>Child event:<br />
通过调用 getChildren 激活。</li>
</ul>

<h3 id="watch--1">4.2 watch 移除</h3>

<p>我们可以调用 removeWatches 方法移除在 znode 注册的 watch。一个客户端可以本地移除watch操作，即使没有连接ZooKeeper服务器，只是本地设置标识为true。下面的列表详细说明了在成功移除watch 之后会触发什么事件：</p>

<ul>
  <li>Child Remove event:<br />
在调用getChildren的时候添加 watcher。</li>
  <li>Data Remove event:<br />
在调用 exists 或者 getData 的时候添加 watcher。</li>
</ul>

<h3 id="watch--2">4.4 关于 watch 需要记住的事情</h3>

<ul>
  <li>Watches 是一次性触发器。如果你获取了一个 watch 事件，然后你还想在未来更改的时候也获得通知，则你必须要设置另外的watch。</li>
  <li>由于watch是一次性的触发器，并且在获取时间和发送新的请求去获取watch 这段之间的延迟，所看到的发生在 ZooKeeper Znode 上的所有改变都是不可信的。需要准备好处理在获取事件和设置watch之间znode改变多次的case。</li>
  <li>一个watch对象，或者 function/context对，对于给定的通知只会被触发一次。例如，如果一个相同的watch对象被一个<code>exists 或者 getData</code> 文件file调用操作注册，然后这个文件file被删除了，这个watch对象将和这个文件file的删除通知一起，仅仅被调用一次。</li>
  <li>当你从服务器上断开连接，你将不能获得任何watch 直到连接被重新建立起来。基于这个原因，会话事件将被发生给所有突出的watch处理器。使用会话事件会进入一个安全模式：你将不能接收事件指导断开连接，所以你的处理处理这种模式下需要谨慎。</li>
</ul>

<h2 id="a-idzookeeperacl-5-zookeeper--acl-a"><a id="ZooKeeper_ACL"> 5 ZooKeeper 使用 ACL 访问控制</a></h2>

<p>（待定….）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 反向代理配置和工作原理]]></title>
    <link href="http://kxcoder.github.io/blog/2015/08/30/nginx-proxy-configure-and-sduty/"/>
    <updated>2015-08-30T18:52:03+08:00</updated>
    <id>http://kxcoder.github.io/blog/2015/08/30/nginx-proxy-configure-and-sduty</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Proxy">Nginx 反向代理配置说明</a></li>
  <li><a href="#ProcessRequest">Nginx 架构和请求处理流程</a></li>
  <li><a href="#ImplementationStudy">Nginx Upstream模块和Location配置</a></li>
  <li><a href="#End">后记</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p><code>Nginx</code>是一款面向性能设计的HTTP服务器，其性能相对于其他服务器表现优异。内部使用异步的事件处理模型，比如linux平台的<code>epoll</code>事件模型，unix平台的<code>kqueue</code>事件模型等。在Nginx源码的<code>src/event/modules</code>目录下，其对各个平台不同的异步模型进行了二次封装。此外，Nginx在代码实现的时候，会考虑到众多细节优化。比如：根据CPU亲缘性来分配进程和事件，避免CPU级的缓存失效；比如字符串比较时，四字节转换为整数来进行快速指令级比较，等等。</p>

<p>本博文主要目的不是Nginx源码分析，所以，对源码及其独特优秀的代码设计不会去详细介绍。</p>

<p>在最近的一些项目中，涉及到nginx的反向代理配置，然后花了一些时间了解下关于Nginx的整体请求处理流程和返现代理的实现机制。</p>

<p>Nginx虽然代码整洁，模块清晰，但是代码量毕竟还是很多，而且注释实在是太少，所以把一些学习的资料和心得整理一下，以便以后查看。</p>

<!--more-->

<h2 id="a-idproxynginx-a"><a id="Proxy">Nginx 反向代理配置说明</a></h2>

<p>反向代理指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接到客户端，此时代理服务器对外就表现为一个服务器，而此种工作模式类似于LVS-NET模型。</p>

<p>反向代理也可以理解为web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加的 一个高速web缓冲服务器，用来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，所有外部网络要访问服务器时的所有请求都要通过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存在本地，以便日后再收到同样的信息请求时，它会将本地缓存里的内容直接发给用户，已减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</p>

<p>了解nginx的反向代理如何实现之前，先看看我们一般配置nginx反向代理的设置：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>nginx反向代理的设置 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class="nginx"><span class="line">    <span class="k">upstream</span> <span class="s">cc_001</span> <span class="p">{</span>
</span><span class="line">        <span class="kn">server</span> <span class="n">192.168.1.101</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class="line">        <span class="kn">server</span> <span class="n">192.168.1.102</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="kn">healthcheck_enabled</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_delay</span> <span class="mi">3000</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_timeout</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_failcount</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">        <span class="kn">healthcheck_send</span> <span class="s">&#39;GET</span> <span class="s">/healthcheck.html</span> <span class="s">HTTP/1.0&#39;</span> <span class="s">&#39;Host:</span> <span class="s">local.com&#39;</span> <span class="s">&#39;Connection:</span> <span class="s">close&#39;</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">server</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="kn">listen</span>       <span class="n">192.168.1.100</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class="line">        <span class="kn">server_name</span>  <span class="s">cc.local.com</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="kn">proxy_buffers</span> <span class="mi">64</span> <span class="mi">4k</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="kn">location</span> <span class="p">=</span> <span class="s">/</span> <span class="p">{</span>
</span><span class="line">            <span class="kn">proxy_pass</span> <span class="s">http://cc_001/bm/index.htm</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
</span><span class="line">            <span class="kn">proxy_pass</span> <span class="s">http://cc_001</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
</span><span class="line">            <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的code主要列出来nginx 反向代理基本配置。</p>

<blockquote>
  <blockquote>
    <p>Tips：上面的配置选项都是最最基本的，一般涉及到反向代理都会使用到这些配置。对于其中的设置项，理解起来也很简单。</p>
  </blockquote>
</blockquote>

<p><em>upstream配置块</em></p>

<p>其实在nginx中，<code>upstream</code>是一个非常重要的配置。nginx所有对于动态请求的处理，基本上都需要使用<code>upstream</code>配置模块。nginx的两个很重要的功能，反向代理和负载均衡，都需要通过配置对应的<code>upstream</code>来完成。</p>

<blockquote>
  <blockquote>
    <p>其实在nginx中，有一个基础模块叫handler，这个模块可以接受来自客户端/用户端的请求，然后处理并产生对应的响应内容返回过去。因此，我们那些静态资源，前端页面什么的，都是使用handler模块来完成响应的。但是，众所知周，一般的核心服务都是后台动态产生的，这些资源就不可以方便使用handler去完成内容的生成和响应动作（当然也是可以使用开发自定义handler来完成的，比如各种xxxcgi之流，但是一般还是用来处理静态资源）。</p>

    <p>那么，upstream就出现了。其接收到用户的请求，然后转发到后端服务器拿到对应的响应资源，再返回给请求端。在整个处理过程中，其本身不会产生自己的响应内容，这是和<code>handler</code>模块唯一的区别。</p>

    <p>upstream的特性，决定了在其配置块中，设置一些后端服务器的地址和端口，就ok了。</p>

  </blockquote>
</blockquote>

<p>配置项说明：</p>

<ul>
  <li>
    <p>upstream中的server项：表明后台的一台服务器地址和端口。当客户端有请求到<code>nginx</code>服务器的时候，upstream模块根据这里配置的server，该对应的请求转发到这些server服务上，由这些server来处理请求，然后把响应结果告知upstream模块。</p>
  </li>
  <li>
    <p>healthcheck_enabled项：healthcheck健康监控功能，并不是原生nginx自带的。所以如果使用这个功能，必须要安装第三方插件：<code>ngx_http_healthcheck_module</code>。healthcheck_enabled表示启动健康检查模块功能。</p>
  </li>
  <li>
    <p>healthcheck_delay项：对同一台后端服务器两次检测之间的时间间隔，单位毫秒，默认为1000。</p>
  </li>
  <li>
    <p>healthcheck_timeout项：进行一次健康检测的超时时间，单位为毫秒，默认值2000。</p>
  </li>
  <li>
    <p>healthcheck_failcount项：对一台后端服务器检测成功或失败多少次之后方才确定其为成功或失败，并实现启用或禁用此服务器。</p>
  </li>
  <li>
    <p>healthcheck_send项：为了检测后端服务器的健康状态所发送的检测请求。然后根据各个服务器的响应情况来判断服务器是否存活。上面的配置表面，各个后台服务器上都存在<code>healthcheck.html</code>静态页面，然后nginx会get这个页面，根据是否status为200来判断是否服务器存活。</p>
  </li>
</ul>

<p><em>server配置块</em></p>

<p>在nginx中，不管怎么样的配置，都会有一个server配置块。http服务上支持若干虚拟主机。每个虚拟主机会有一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</p>

<blockquote>
  <blockquote>
    <p>Server其实就是一个虚拟主机。因为在nginx中可以配置多个server，这样就使得nginx可以在一台服务器上配置多个域名。</p>

    <p>在nginx的Server虚拟主机中，它只会处理与之对应的域名请求。并且，如果在listen中设置了ip地址，则该虚拟主机只会处理从该服务器的指定ip端口进来的请求，才会去处理。关于一台服务器设置多个别名ip地址的方式，可以参考博客<a href="http://www.cnblogs.com/mchina/archive/2012/05/21/2511824.html">在Nginx中部署基于IP的虚拟主机</a></p>
  </blockquote>
</blockquote>

<p>配置项说明：</p>

<ul>
  <li>
    <p>listen项：监听ip和端口。当nginx服务器的该ip端口有请求访问，则调用该server的配置来处理该请求。</p>
  </li>
  <li>
    <p>server_name项：域名。nginx对进入该虚拟主机的请求，检查其请求Host头是否匹配设置的server_name，如果是，则继续处理该请求。</p>
  </li>
  <li>
    <p>location块选项：Location在nginx中是一个非常重要的指令。对于HTTP请求，其被用来详细匹配URI和设置的location path。一般这个uri path会是字符串或者正则表达式形式。</p>
  </li>
</ul>

<blockquote>
  <blockquote>
    <p>: 关于location匹配，存在一些语法规则，如下：</p>

    <pre><code>  location [=|~|~*|^~|@] /uri/ { ... }
   =：表示精确匹配，如果找到，立即停止搜索并立即处理此请求。
   ~：表示区分大小写匹配。
   ~*：表示不区分大小写匹配。
   ^~：表示只匹配字符，串不查询正则表达式。
   @：指定一个命名的location，一般只用于内部重定向请求。
</code></pre>
  </blockquote>
</blockquote>

<ul>
  <li>
    <p>location中proxy_pass项：代理转发。配置了该项，当匹配location path的请求进来后，会根据upstream设置，请求后台服务器上的proxy_pass的请求。例如，上面的配置，当有请求<code>cc.local.com</code>时，由于精确匹配<code>=/</code>，则根据proxy_pass配置，则会反向代理，请求<code>192.168.1.101:80/bm/index.htm</code>。</p>
  </li>
  <li>
    <p>location中proxy_set_header项：设置代理请求头。由于经过了反向代理服务器，所以后台服务器不能获取真正的客户端请求地址等信息，这样，就需要把这些ip地址，设置回请求头部中。然后，我们在后台服务上，可以使用<code>request.get("X-Real-IP")</code>或者<code>request.get("X-Forwarded-For")</code>获取真实的请求ip地址。获取host也是如此。具体可以参考博文：<a href="http://gong1208.iteye.com/blog/1559835"> 使用nginx后如何在web应用中获取用户ip及原理解释</a>.</p>
  </li>
</ul>

<h2 id="a-idprocessrequestnginx-a"><a id="ProcessRequest">Nginx 架构和请求处理流程</a></h2>

<p>Nginx架构，在taobao的<a href="http://tengine.taobao.org/book/chapter_02.html">《Nginx开发从入门到精通》</a>电子书中，写的比较详细。这里记录一些核心的细节。</p>

<p>Nginx在启动会以daemon形式在后台运行，采用<code>多进程+异步非阻塞IO事件模型</code>来处理各种连接请求。</p>

<p>Nginx主要包含一个master进行和多个worker进行，一般worker进程个数是根据服务器CPU核数来决定的。如下图：</p>

<p><img src="http://kxcoder.github.io/images/2015/08/nginx_process.png" /></p>

<blockquote>
  <blockquote>
    <p>Notes：从上图中可以很明显地看到，4个worker进程的父进程都是master进程，表明worker进程都是从父进程fork出来的，并且父进程的ppid为1，表示其为daemon进程。</p>

    <p>需要说明的是，在nginx多进程中，每个worker都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p>

  </blockquote>
</blockquote>

<p>下面来介绍一个请求进来，进程模型的处理方式。</p>

<p><em>首先</em>，master进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。</p>

<p><em>其次</em>，根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</p>

<p><em>然后</em>，这个时候有多个worker进程都在监听同样设置的socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的<code>惊群现象</code>。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个<code>accept_mutex</code>类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</p>

<p><em>最后</em>，注册成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。</p>

<blockquote>
  <blockquote>
    <p>进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个worker进程出现异常退出，其他worker进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样子会提高处理效率，并且开发调试也更容易。</p>

    <p>如前文所述，<code>多进程模型+异步非阻塞模型</code>才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。</p>

    <p>关于异步非阻塞IO模型：linux的epoll介绍，可以参考：<a href="http://www.cppblog.com/deane/articles/165218.html">深入了解epoll </a></p>
  </blockquote>
</blockquote>

<h3 id="nginx-">Nginx 连接和请求处理</h3>

<p>上一节介绍了，worker进程会竞争客户端的连接请求，这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠web服务器环境下。</p>

<p>针对这种现象，Nginx采用了一个是否打开accept_mutex选项的值<code>ngx_accept_disabled</code>。标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件。</p>

<blockquote>
  <blockquote>
    <p>ngx_accept_disabled值，nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled。</p>

    <p>当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。</p>
  </blockquote>
</blockquote>

<p>接下来，看看连接处理流程（来自tengine.taobao.org）：</p>

<p><img src="http://kxcoder.github.io/images/2015/08/request_process.png" /></p>

<blockquote>
  <blockquote>
    <p>关于处理流程的说明，参考: <a href="http://tengine.taobao.org/book/chapter_02.html">http://tengine.taobao.org/book/chapter_02.html</a></p>

  </blockquote>
</blockquote>

<h2 id="a-idimplementationstudynginx-upstreamlocationa"><a id="ImplementationStudy">Nginx Upstream模块和Location配置</a></h2>

<p><em>Nginx Upstream</em></p>

<p>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。</p>

<p>从本质上说，upstream属于handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为upstream（上游）。请求并取得响应内容的整个过程已经被封装到nginx内部，所以upstream模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p>

<p><code>upstream</code>模块逻辑实现的十分复杂，对于其具体实现，不分析。</p>

<p><code>upstream</code>模块主要做两件事情：</p>

<ul>
  <li>
    <p>当外部的客户端发送一个http请求后，如果涉及更后台服务，则会创建一个到后端服务的request请求；</p>
  </li>
  <li>
    <p>请求到达后端，然后处理完成后，则upstream会将返回的数据接收过来，然后发送给外部请求的客户端。</p>
  </li>
</ul>

<p><em>Nginx Location</em></p>

<p>首先，介绍下存在的几种Location配置方式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>nginx Location配置方式 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="nginx"><span class="line"><span class="k">location</span>  <span class="p">=</span> <span class="s">/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches the query / only.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">A</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span>  <span class="s">/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any query, since all queries begin with /, but regular</span>
</span><span class="line">  <span class="c1"># expressions and any longer conventional blocks will be</span>
</span><span class="line">  <span class="c1"># matched first.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">B</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span> <span class="s">/documents/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any query beginning with /documents/ and continues searching,</span>
</span><span class="line">  <span class="c1"># so regular expressions will be checked. This will be matched only if</span>
</span><span class="line">  <span class="c1"># regular expressions don&#39;t find a match.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">C</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span> <span class="s">^~</span> <span class="s">/images/</span> <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any query beginning with /images/ and halts searching,</span>
</span><span class="line">  <span class="c1"># so regular expressions will not be checked.</span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">D</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span><span class="line"><span class="s">location</span> <span class="p">~</span><span class="sr">*</span> <span class="s">\.(gif|jpg|jpeg)</span>$ <span class="p">{</span>
</span><span class="line">  <span class="c1"># matches any request ending in gif, jpg, or jpeg. However, all</span>
</span><span class="line">  <span class="c1"># requests to the /images/ directory will be handled by</span>
</span><span class="line">  <span class="c1"># Configuration D.   </span>
</span><span class="line">  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">E</span> <span class="s">]</span>
</span><span class="line"><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>示例请求：</p>

<ul>
  <li>/ -&gt; configuration A</li>
  <li>/index.html -&gt; configuration B</li>
  <li>/documents/document.html -&gt; configuration C</li>
  <li>/images/1.gif -&gt; configuration D</li>
  <li>/documents/1.jpg -&gt; configuration E</li>
</ul>

<p>解析匹配规则为：</p>

<ol>
  <li>
    <p>字符串精确匹配到一个带 “=” 号前缀的location，则停止，且使用这个location的配置；</p>
  </li>
  <li>
    <p>字符串匹配剩下的非正则和非特殊location，如果匹配到某个带 “^~” 前缀的location，则停止；</p>
  </li>
  <li>
    <p>正则匹配，匹配顺序为location在配置文件中出现的顺序。如果匹配到某个正则location，则停止，并使用这个location的配置；否则，使用步骤2中得到的具有最大字符串匹配的location配置。</p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>Notes：需要注意的是：<code>~ 开头</code>表示区分大小写的正则匹配；而<code>~*  开头</code>表示不区分大小写的正则匹配。<code>!~和!~*</code>分别为区分大小写不匹配及不区分大小写不匹配的正则</p>
  </blockquote>
</blockquote>

<h2 id="a-idenda"><a id="End">后记</a></h2>

<p>Nginx 是一个十分优秀的服务器软件，其内部相当多的设计和实现都非常巧妙和高效。</p>

<p>关于Nginx的一些好的站点有：</p>

<ul>
  <li><a href="http://tengine.taobao.org/book/">http://tengine.taobao.org/book/</a></li>
  <li><a href="http://www.pagefault.info/?cat=7">http://www.pagefault.info/?cat=7</a></li>
  <li><a href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></li>
  <li><a href="http://kxcoder.github.io/images/2015/08/nginx_stream.png">http://kxcoder.github.io/images/2015/08/nginx_stream.png</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Awk 使用学习笔记]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/30/Linux-Awk-Study-Note/"/>
    <updated>2014-05-30T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/30/Linux-Awk-Study-Note</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Console">Awk命令行</a></li>
  <li><a href="#Script">Awk脚本程序</a></li>
  <li><a href="#Recommend">推荐教程</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p><code>linux Awk</code> 脚本语言，算来也有很长的一段历史了。在如今各种更全更简单的脚本语言遍地生成的年代，关注<code>Awk</code>的新人越来越少了。最近，在项目组同事的影响下，去学习了下<code>Awk</code>的基本使用方法。</p>

<blockquote>
  <blockquote>
    <p>Note：本文只是学习笔记，很多示例和描述都来自最后推荐的文章里面。</p>
  </blockquote>
</blockquote>

<p>起意写关于<code>Awk</code>学习笔记的主要原因是，学习皓哥的<a href="http://coolshell.cn/articles/9070.html">AWK 简明教程</a> 完了之后，完全还是云里雾里的，不知所以然。所以，找了个<a href="http://www.aslibra.com/doc/awk.htm">AWK 手册</a>好好学习。但是，对于前者介绍太多浅，初学者对于<code>Awk</code>使用没有任何概念；后者又过于长，不方便我去查资料，所以合计起来，就写一个学习总结罢了。</p>

<!--more-->

<h2 id="a-idconsoleawka"><a id="Console">Awk命令行</a></h2>

<p>关于<code>Awk</code>的历史，语言优势什么的，就不浪费时间介绍了。</p>

<h3 id="awk-">2.1 Awk 程序结构</h3>

<p>首先，我们在服务器上查看日志信息，大部分时候都希望使用一行命令搞定问题，因此，显然命令行方式使用<code>Awk</code>是很频繁的事情。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>awk语法</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="awk"><span class="line"><span class="nx">awk</span> <span class="s1">&#39;awk程序主体&#39;</span> <span class="p">[</span><span class="err">操作的文本</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在写一个<code>awk</code>脚本之前，首先需要的是了解 <code>awk</code>程序组成结构，如果你不了解它的程序一般的结构，那么你去看皓哥或者其他人写的入门级<code>Awk</code>小程序，你也无法真正去了解或者深入。</p>

<pre><code>Pattern1 {Actions1}
Pattern2 { Actions2 }
......
Pattern3 { Actions3 }
</code></pre>

<blockquote>
  <blockquote>
    <p>Note：<code>Pattern （模式）</code>，如同正则一样，就是判断<code>Pattern</code>是否满足，如果满足，则执行就下来的<code>Actions</code>动作行为。<code>awk</code>提供的比较运算符和<code>C</code>语言一样，不过新加了 ` ~ <code>(匹配) 及 </code> !~ `(不匹配) 二个关系运算符.</p>
  </blockquote>
</blockquote>

<pre><code>其用法与涵义如下:
若 A 为一字符串, B 为一正则表达式(Regular Expression)
A ~ B 判断 字符串A 中是否 包含 能匹配(match)B表达式的子字符串.
A !~ B 判断 字符串A 中是否 不包含 能匹配(match)B表达式的子字符串.
</code></pre>

<blockquote>
  <blockquote>
    <p>Note：<code>Action</code>，就是动作，但是需要指出的是，一个<code>Pattern</code>所对应的<code>Action</code>应该要放进<code>{ }</code>内。当然，存在一种情况，就是没有<code>Pattern</code>,直接就是<code>{Action}</code>，这表示，“无条件执行指定的Action动作”。</p>
  </blockquote>
</blockquote>

<p>了解了<code>awk</code>程序的基本结构，下面给一个简单示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>awk语法</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="awk"><span class="line"><span class="nx">awk</span> <span class="s1">&#39; $0&gt;1 {print &quot;hello world&quot;}&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>这个程序意思就是：<code>$0&gt;1</code>模式成立，则打印后面的<code>hello world</code>，在console上输入3，回车，则会打印<code>hello world</code>；如果输入0，则不会打印该消息。</p>
  </blockquote>
</blockquote>

<h3 id="awk--1">2.2 Awk 程序说明</h3>

<p>首先，需要了解<code>$0</code>这种格式： <code>$0</code>表示<code>awk</code>所读入的一行字符串；<code>$1</code>则表示所读入的字符串的第一个数据，默认安装<code>空格/tab</code>来分隔；<code>$2</code>则表示所读入的字符串的第二个数据；以此类推…..</p>

<p>其次，这个程序是从控制台，或者文本中读取变量值（需要在后面写操作的文本名）。如果你测试了这个小脚本，你会发现，它会一直读，知道遇到<code>ctrl+d</code>或者<code>EOF</code>才会结束。但是，如果你初始化一些变量或者其他只需要执行一次的逻辑，怎么办呢？你需要<code>BEGIN</code>和<code>END</code>。</p>

<pre><code>1. BEGIN ：程序一开始执行时执行的，仅被执行一次。
2. END	 ：程序处理完所有数据即将返回的时候，执行一次。
</code></pre>

<p>比如上面的程序，可以写成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>awk示例</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="awk"><span class="line"><span class="nx">awk</span> <span class="s1">&#39; BEGIN{n=3} $0&gt;1 &amp;&amp; --n&gt;0 {print &quot;hello world&quot;} END{print &quot;EXIT AWK TEST&quot;}&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行完了结果如下：</p>

<pre><code>[tao.ke@l-rtools1.ops.cn6 ~]$ awk ' BEGIN{n=3} $0&gt;1 &amp;&amp; --n&gt;0 {print "hello world"} END{print "EXIT AWK TEST"}'         
3
hello world
2
hello world
1
0 #（在这里的时候输入 ctrl+d）
EXIT AWK TEST
</code></pre>

<p>最后，说说<code>Awk</code>中使用<code>linux shell</code>命令。和<code>linux</code>一样，使用<code>|</code>来操作管道流，使用<code>""</code>标识<code>linux</code>命令。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>awk示例</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="awk"><span class="line"><span class="nx">awk</span> <span class="s1">&#39; BEGIN{while(&quot;who&quot;|getline){print $0}} &#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>这里可以打印出，所有的登陆在系统上的用户。	关于<code>while</code>的使用，和<code>c</code>语言一样；此外，其他控制语言<code>if</code>、<code>do-while</code>、<code>for</code>，也和<code>c</code>一样。需要说明的是，<code>for</code>可以使用类似<code>foreach</code>的形式，具体见下一节。</p>
  </blockquote>
</blockquote>

<h2 id="a-idscriptawka"><a id="Script">Awk脚本程序</a></h2>

<p>–待续</p>

<h2 id="a-idrecommenda"><a id="Recommend">推荐教程</a></h2>

<ul>
  <li>
    <p>awk手册，<a href="http://www.aslibra.com/doc/awk.htm">http://www.aslibra.com/doc/awk.htm</a></p>
  </li>
  <li>
    <p>AWK 简明教程，<a href="http://coolshell.cn/articles/9070.html">http://coolshell.cn/articles/9070.html</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线上Mysql死锁问题分析]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/28/Online-Mysql-Deadlock-Analyse/"/>
    <updated>2014-05-28T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/28/Online-Mysql-Deadlock-Analyse</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Problem">死锁问题定位</a></li>
  <li><a href="#Reproduce">问题重现</a></li>
  <li><a href="#Solution">解决方法</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>前段时间，查看线上<code>Tomcat</code>日志，发现多台服务器出现<code>Mysql</code>死锁情况，虽然死锁问题没有影响到正常业务，但是毕竟数据库死锁还是得需要好好分析原因去修复和开发过程中极力需要避免的。服务器上<code>Mysql死锁</code>日志如下：</p>

<!--more-->

<p><img src="http://kxcoder.github.io/images/2014/05/deadlock-log.png" /></p>

<p>由于我们的服务使用了连接池，所以接着让 DBA 查询下<code>Mysql</code>的数据库操作日志信息，如下图所示：</p>

<p><img src="http://kxcoder.github.io/images/2014/05/mysql-log.png" /></p>

<h2 id="a-idproblema"><a id="Problem">死锁问题定位</a></h2>

<p>查看了建表语句，其实很简单：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>建表SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="mysql"><span class="line"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="ss">`room_rate_plan_id`</span> <span class="p">(</span>
</span><span class="line">  <span class="ss">`id`</span> <span class="kt">bigint</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">unsigned</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
</span><span class="line">  <span class="ss">`value`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="p">,</span>
</span><span class="line">  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="ss">`id`</span><span class="p">),</span>
</span><span class="line">  <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="ss">`uniq_value`</span> <span class="p">(</span><span class="ss">`value`</span><span class="p">)</span> <span class="k">USING</span> <span class="n">BTREE</span>
</span><span class="line"><span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="kp">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">175663</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而使用的地方只在一个类代码里用过，使用的方式是<code>select for update</code>，并且该查询事务中包含着，如果不存在，则<code>INSERT INTO room_rate_plan_id (value) VALUES(?)</code>语句，那么，接着就得了解<code>select for update</code>来确定是不是这里导致数据库死锁现象。主要有两篇博客：</p>

<ul>
  <li>
    <p><a href="http://stackoverflow.com/questions/5432370/mysql-innodb-dead-lock-on-select-with-exclusive-lock-for-update">http://stackoverflow.com/questions/5432370/mysql-innodb-dead-lock-on-select-with-exclusive-lock-for-update</a></p>
  </li>
  <li>
    <p><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-deadlocks.html">http://dev.mysql.com/doc/refman/5.0/en/innodb-deadlocks.html</a></p>
  </li>
</ul>

<p><code>SELECT FOR UPDATE</code> 是<code>SELECT</code> 的升级版，其在查询时会上锁。一般地，当数据量特别大时，可能有大量的并发，这些并发会导致在<code>SELECT</code>时，状态已经变更了，因此需要上锁。InnoDB默认是Row-Level Lock，因此<code>SELECT FOR UPDATE</code>只有在<code>WHERE</code> 判断条件内明确指定主键时，才会执行<code>Row lock</code>，否则会<code>lock</code>整个数据表。当有多个请求同时加上<code>for update</code>的意向锁时，如果<code>select</code>没有时，第一个请求会接着<code>insert</code>而去尝试获取排它锁，B锁保持等待；而第二个请求也<code>select</code>为空时，并且刚好第二条请求插入的数据和第一个请求一样的时候，则会导致死锁。</p>

<h2 id="a-idreproducea"><a id="Reproduce">问题重现</a></h2>

<blockquote>
  <blockquote>
    <p>执行下面语句：</p>
  </blockquote>
</blockquote>

<ul>
  <li><code>session 1</code>执行：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="mysql"><span class="line"><span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">qunar</span><span class="p">.</span><span class="n">room_rate_plan_id</span> <span class="k">where</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;elong_abcd&#39;</span><span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li><code>session 2</code>执行：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="mysql"><span class="line"><span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">qunar</span><span class="p">.</span><span class="n">room_rate_plan_id</span> <span class="k">where</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;elong_abcd&#39;</span><span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>在<code>session 1</code>上执行 <code>insert</code> 语句：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="mysql"><span class="line"><span class="k">insert</span> <span class="k">into</span> <span class="n">qunar</span><span class="p">.</span><span class="nf">room_rate_plan_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;elong_abcd&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>执行上面的操作，则在<code>Mysql</code>控制台上打出死锁日志信息：</p>
  </blockquote>
</blockquote>

<p><img src="http://kxcoder.github.io/assets/img/2014/5/28/mysql-dead.png" /></p>

<h2 id="a-idsolutiona"><a id="Solution">解决方法</a></h2>

<ol>
  <li>
    <p>采用官网上指出的方法：If you are using locking reads (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE MODE), try using <code>a lower isolation level</code> such as READ COMMITTED.</p>
  </li>
  <li>
    <p>由于<code>select for update</code>只有不存在记录时才会去加一个意向锁，所以可以采用下面方法解决：select—&gt; if(id) is empty —&gt;insert;如果不为空，则select for update。不过这样就多了一次select了。</p>
  </li>
  <li>
    <p>使用<code>insert ignore</code> 插入，然后select ，由于是value是<code>unique key</code>，所以select可以获取正确id，并且还可以不需要添加事务。可能会多一次insert ignore。这种方法之所以这样子，是因为在业务中没有update操作，只有insert和select，并且value是唯一的，这样子就可以只采用select而不需要采用select for update，并且还可以不需要事务，提供效率。</p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>如果采用第3中解决方案，不会出现死锁问题，但是当锁一直被占用时，会出现等待超时，当然，如果不使用事务，则肯定不会有锁的问题了。</p>
  </blockquote>
</blockquote>

<pre><code>* session 1：
    &lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;figcaption&gt;&lt;span&gt;执行SQL语句&lt;/span&gt;&lt;/figcaption&gt;
</code></pre>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="mysql"><span class="line">		<span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class="line">		<span class="k">INSERT</span> <span class="k">IGNORE</span> 	<span class="k">INTO</span> <span class="nf">room_rate_plan_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;elong_abcs&#39;</span><span class="p">);</span>
</span><span class="line">		<span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">room_rate_plan_id</span> <span class="k">where</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;elong_abcs&#39;</span><span class="p">;</span>
</span><span class="line">		
</span></code></pre></td></tr></table></div>
<p>&lt;/figure&gt;&lt;/notextile&gt;&lt;/div&gt;</p>

<pre><code>* session 2：
    &lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;figcaption&gt;&lt;span&gt;执行SQL语句&lt;/span&gt;&lt;/figcaption&gt;
</code></pre>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="mysql"><span class="line">		<span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class="line">		<span class="k">INSERT</span> <span class="k">IGNORE</span> 	<span class="k">INTO</span> <span class="nf">room_rate_plan_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;elong_abcs&#39;</span><span class="p">);</span>
</span><span class="line">		
</span></code></pre></td></tr></table></div>
<p>&lt;/figure&gt;&lt;/notextile&gt;&lt;/div&gt;
	* 出现超时异常信息：</p>

<p><img src="http://kxcoder.github.io/images/2014/05/timeout.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 查看系统GC命令介绍]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/27/Jstat-GC-Guide-Introduce/"/>
    <updated>2014-05-27T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/27/Jstat-GC-Guide-Introduce</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Jstat">Jstat 查看系统 GC 命令介绍</a></li>
  <li><a href="#Jmap">Jmap 查看系统 GC 命令介绍</a></li>
  <li><a href="#Finally">小结</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>使用	<code>JVM</code>的人都或多或少的了解<code>垃圾回收</code>机制，当系统的服务出现性能问题时，都会去服务器上查看下系统<code>GC</code>的情况。此外，如果有新的服务上线，也需要去服务器上查看下新服务的整体<code>GC</code>水平，这就可以使用<code>jstat</code>命令来查看了，当然你也可以使用其他方式。</p>

<!--more-->

<h2 id="a-idjstatjstat--gc-a"><a id="Jstat">Jstat 查看系统 GC 命令介绍</a></h2>

<p><code>jstat</code>的命令查看系统<code>GC</code>情况，很简单，只需要先通过<code>jps</code>或者<code>ps -aux |grep tomcat</code>来查看对应服务所在的进程数，然后使用下面命令查看。</p>

<blockquote>
  <blockquote>
    <p>jstat 查看 gc 使用方法如下：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Jstat 查看系统GC </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="go">jstat -gcutil `线程值` `间隔时间数(ms)`</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>执行命令<code>sudo jstat -gcutil 11694 3600</code>，结果会显示内存各个区域大小的情况，如图：</p>
  </blockquote>
</blockquote>

<p><img src="http://kxcoder.github.io/images/2014/05/jstat-gc.jpg" /></p>

<blockquote>
  <blockquote>
    <p>Note: 结果里面列出每个区间的内存大小，新生代gc的次数和时间，老年代gc的次数和时间。</p>
  </blockquote>
</blockquote>

<pre><code>1. S0  — Heap上的 Survivor space 0 区已使用空间的百分比;
2. S1  — Heap上的 Survivor space 1 区已使用空间的百分比;
3. E   — Heap上的 Eden space 区已使用空间的百分比;
4. O   — Heap上的 Old space 区已使用空间的百分比;
5. P   — Perm space 区已使用空间的百分比;
6. YGC — 从应用程序启动到采样时发生 Young GC 的次数;
7. YGCT– 从应用程序启动到采样时 Young GC 所用的时间(单位秒);
8. FGC — 从应用程序启动到采样时发生 Full GC 的次数;
9. FGCT– 从应用程序启动到采样时 Full GC 所用的时间(单位秒);
10. GCT — 从应用程序启动到采样时用于垃圾回收的总时间(单位秒).
</code></pre>

<h2 id="a-idjmapjmap--gc-a"><a id="Jmap">Jmap 查看系统 GC 命令介绍</a></h2>

<p>当我们使用<code>jstat</code>命令查看<code>GC</code>时，发现<code>YoungGC</code>或者<code>FullGC</code>频率过高时，就需要分析服务的具体情况了。这个时候，可以使用<code>Jmap</code>来查看当前系统的实例使用内存大小，一般地，需要<code>dump</code>到本地进行分析，使用可视化工具可以使分析效率得到很大的提高。</p>

<blockquote>
  <blockquote>
    <p><code>Jmap</code>的使用方法如下所示：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Jmap 查看系统GC </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="console"><span class="line"><span class="go">jmap -dump:format=b,file=log.bin `进程id`    </span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>使用<code>sudo jmap -dump:format=b,file=log.bin  -F 11694</code>命令，写入文件内容如下:</p>
  </blockquote>
</blockquote>

<pre><code>JAVA PROFILE 1.0.1
JAVA PROFILE 1.0.1
Lcom/alibaba/dubbo/remoting/exchange/support/DefaultFuture$RemotingInvocationTimeoutScan;
DefaultStatistics.java
T8procedureNameRs
StringUtils.10
isCons
(Ljava/lang/Integer;)Ljava/math/BigDecimal;
HtheCloseBracketFor
h([Ljava/lang/String;Lorg/codehaus/jackson/JsonGenerator;Lorg/codehaus/jackson/map/SerializerProvider;Lorg/codehaus/jackson/map/JsonSerializer;)V
zC@roureq
lastActiveFilter
Ampersand
......
</code></pre>

<blockquote>
  <blockquote>
    <p>Note：有很多可视化的工具来分析<code>dump</code>文件，为了简单，这里使用java自带的工具<code>jvisualvm</code>工具，在<code>文件</code>选项中<code>装入</code> dump 下来的 文件<code>log.bin</code>，就可以看到各个对象实例所占用的内存大小和实例数量了。如下图：</p>
  </blockquote>
</blockquote>

<p><img src="http://kxcoder.github.io/images/2014/05/jmap-gc.jpg" /></p>

<h2 id="a-idfinallya"><a id="Finally">小结</a></h2>

<p>java 中 还有一个命令比较有用，就是<code>jstack</code>，该命令可以查看服务器上的某个服务的堆栈信息。从而分析线程是否处于死锁状态，从而导致服务不可用或者服务性能受到影响。使用命令<code>jstack 线程id</code>就可以获取所有堆栈信息了，非常简单便捷。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring MVC 项目构建入门指南]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/26/Spring-MVC-Project-Introduction/"/>
    <updated>2014-05-26T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/26/Spring-MVC-Project-Introduction</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Framework">SimpleSpringProject 结构介绍</a></li>
  <li><a href="#Configure">SimpleSpringProject 配置介绍</a></li>
  <li><a href="#DataOp">SimpleSpringProject 数据操作实现介绍</a></li>
  <li><a href="#Finally">小结</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>走入社会工作接近一年了，感慨颇多。一年前的现在，自己对java知之甚少，更不知道怎么去创建一个满足<code>spring mvc</code>架构思想的web项目。最近，为了学习<code>Spring MVC</code>框架的实现原理，首先新建了一个web项目，该项目包含 <code>Spring + Mybatis</code>，涉及数据库，DAO，service，API，业务，controller多个模块。</p>

<blockquote>
  <blockquote>
    <p>Note：这个项目代码完成的功能只是为了演示一个大项目应该具备的结构，而显然在实际工程中，这么简单地功能，是不需要如此繁杂的结构模块的。</p>
  </blockquote>
</blockquote>

<p>此外，关于<code>Spring MVC</code>演示项目的代码，可以从<code>github</code>上<code>clone</code>一份到本地，项目为：<a href="https://github.com/ketao1989/simpleSpringProject">SimpleSpringProject</a>。<code>git clone</code> 地址为：<code>https://github.com/ketao1989/simpleSpringProject.git</code></p>

<!--more-->

<h2 id="a-idframeworksimplespringproject-a"><a id="Framework">SimpleSpringProject 结构介绍</a></h2>

<p><code>simpleSpringProject</code>项目各个模块分工明确，主要由8个模块组成：</p>

<pre><code>1. simple-spring-main模块：该模块主要是提供给外界访问的controller层所在。`controller`层可以对外提供html视图，也可以对外提供RPC调用，例如 alibaba 的 dubbo接口。

2. simple-spring-api模块：该模块主要就是封装一些底层的方法接口给外部使用。比如，如果我们使用RPC接口调用服务，则只需要API包就可以了，具体实现调用方是不需要知道的。

3. simple-spring-biz模块：该模块是业务模块，也就是具体业务需要的方法基本上都是在这里实现的。在demo 中，在这一层实现api提供的接口。该模块主要调用service层提供的基本服务，组装起来，实现各种不同的业务逻辑接口。

4. simple-spring-service模块：该模块是基础服务模块，该模块会为biz业务模块提供基本的服务，这些服务功能都比较简单，业务逻辑单一。因此，在这一层进行单元测试，一般会取到比较好的效果。

5. simple-spring-dao模块：该模块是数据库相关接口模块。`Mybatis`可以把interface 和 xml结合起来，使得开发者可以把数据库表中相关操作集成在 interface 代码中，而具体的`SQL`实现则写在xml文件中。这样子，可以让整个结构更清晰。

6. simple-spring-config模块：该模块就是相关`sql`语句的配置文件所在地。一般地，会根据interface 来切分不同的配置文件，两种的关联关系是通过对于的`sql.xml`文件中`mapper namespace`来关联。

7. simple-spring-common模块：该模块一般存放一些项目公用的工具类和常量值。比如，一些配置文件中需要配置的属性值，一些xxxUtils类实现等。

8. simple-spring-model模块：该模块主要提供一些模型，各个类需要使用的对象。比如，我们需要获取一个学生个体信息，显然会作为一个对象类来实现。
</code></pre>

<blockquote>
  <blockquote>
    <p>Note：显然，对于各个模块的具体详细分工，其实还是可以调整的，比如可能有些地方会在<code>service</code>层来做稍微复杂的服务实现，而在<code>biz</code>层则稍微组合就可以了。这里，demo的模块分类，只是正常情况下，业务规模有一些大的情况下，才会进行多个模块的分工。</p>
  </blockquote>
</blockquote>

<h2 id="a-idconfiguresimplespringproject-a"><a id="Configure">SimpleSpringProject 配置介绍</a></h2>

<p><code>Spring</code>作为一个主打配置的框架，配置文件的位置，十分重要。如果，一些配置文件的一个符号错误，都会导致整个<code>MVC</code> web 项目无法正常启动。</p>

<blockquote>
  <blockquote>
    <p>首先，来看看web项目中，重中之重的配置文件<code>web.xml</code>，</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>配置文件web.xml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
</pre></td><td class="code"><pre><code class="xml"><span class="line"><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
</span><span class="line"><span class="nt">&lt;web-app</span> <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
</span><span class="line">         <span class="na">xmlns=</span><span class="s">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="na">xmlns:web=</span><span class="s">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>
</span><span class="line">         <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>
</span><span class="line">         <span class="na">id=</span><span class="s">&quot;WebApp_ID&quot;</span> <span class="na">version=</span><span class="s">&quot;2.5&quot;</span><span class="nt">&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!--启动配置文件设置--&gt;</span>
</span><span class="line">    <span class="nt">&lt;display-name&gt;</span>simple-spring-main<span class="nt">&lt;/display-name&gt;</span>
</span><span class="line">    <span class="nt">&lt;context-param&gt;</span>
</span><span class="line">        <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;param-value&gt;</span>classpath:applicationContext.xml<span class="nt">&lt;/param-value&gt;</span>
</span><span class="line">    <span class="nt">&lt;/context-param&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="nt">&lt;listener&gt;</span>
</span><span class="line">        <span class="nt">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="nt">&lt;/listener-class&gt;</span>
</span><span class="line">    <span class="nt">&lt;/listener&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- 请求地址匹配映射 --&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="nt">&lt;servlet&gt;</span>
</span><span class="line">        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
</span><span class="line">        <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
</span><span class="line">    <span class="nt">&lt;/servlet&gt;</span>
</span><span class="line">    <span class="nt">&lt;servlet-mapping&gt;</span>
</span><span class="line">        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;url-pattern&gt;</span>*.htm<span class="nt">&lt;/url-pattern&gt;</span>
</span><span class="line">    <span class="nt">&lt;/servlet-mapping&gt;</span>
</span><span class="line">    <span class="nt">&lt;servlet-mapping&gt;</span>
</span><span class="line">        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;url-pattern&gt;</span>*.json<span class="nt">&lt;/url-pattern&gt;</span>
</span><span class="line">    <span class="nt">&lt;/servlet-mapping&gt;</span>
</span><span class="line">    <span class="nt">&lt;servlet-mapping&gt;</span>
</span><span class="line">        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;url-pattern&gt;</span>*.xml<span class="nt">&lt;/url-pattern&gt;</span>
</span><span class="line">    <span class="nt">&lt;/servlet-mapping&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- 编码过滤器 --&gt;</span>
</span><span class="line">    <span class="nt">&lt;filter&gt;</span>
</span><span class="line">        <span class="nt">&lt;filter-name&gt;</span>characterEncodingFilter<span class="nt">&lt;/filter-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;filter-class&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="nt">&lt;/filter-class&gt;</span>
</span><span class="line">        <span class="nt">&lt;init-param&gt;</span>
</span><span class="line">            <span class="nt">&lt;param-name&gt;</span>encoding<span class="nt">&lt;/param-name&gt;</span>
</span><span class="line">            <span class="nt">&lt;param-value&gt;</span>UTF-8<span class="nt">&lt;/param-value&gt;</span>
</span><span class="line">        <span class="nt">&lt;/init-param&gt;</span>
</span><span class="line">        <span class="nt">&lt;init-param&gt;</span>
</span><span class="line">            <span class="nt">&lt;param-name&gt;</span>forceEncoding<span class="nt">&lt;/param-name&gt;</span>
</span><span class="line">            <span class="nt">&lt;param-value&gt;</span>true<span class="nt">&lt;/param-value&gt;</span>
</span><span class="line">        <span class="nt">&lt;/init-param&gt;</span>
</span><span class="line">    <span class="nt">&lt;/filter&gt;</span>
</span><span class="line">    <span class="nt">&lt;filter-mapping&gt;</span>
</span><span class="line">        <span class="nt">&lt;filter-name&gt;</span>characterEncodingFilter<span class="nt">&lt;/filter-name&gt;</span>
</span><span class="line">        <span class="nt">&lt;url-pattern&gt;</span>*.htm<span class="nt">&lt;/url-pattern&gt;</span>
</span><span class="line">    <span class="nt">&lt;/filter-mapping&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- 指定404页面 --&gt;</span>
</span><span class="line">    <span class="nt">&lt;error-page&gt;</span>
</span><span class="line">        <span class="nt">&lt;error-code&gt;</span>404<span class="nt">&lt;/error-code&gt;</span>
</span><span class="line">        <span class="nt">&lt;location&gt;</span>/404.html<span class="nt">&lt;/location&gt;</span>
</span><span class="line">    <span class="nt">&lt;/error-page&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>接下来默认<code>springmvc-servlet.xml</code>文件和<code>applicationContext.xml</code>文件。<code>springmvc-servlet.xml</code>配置文件，主要定义servlet相关配置，比如scan 基本包名，视图velocity配置，jsp配置设置等信息。由于这里只有一个 mapping servlet，所以只有一个对应的配置文件，当然也可以把这个文件放置其他地方，然后再<code>web.xml</code>中定义对于的servlet就可以了。<code>applicationContext.xml</code>配置文件，则是整个项目的公共配置，比如指定数据库配置，连接池相关信息，一些spring bean 注册信息，默认的视图解析器等等。</p>
  </blockquote>
</blockquote>

<p>-</p>

<blockquote>
  <blockquote>
    <p>接下来，就是<code>mybatis.xml</code>配置文件，这个配置主要是针对<code>Mybatis</code>而存在的，其指定项目中<code>Mybatis</code>设置，以及一些<code>typeHandler</code>，<code>mapper</code>实现的位置。下面给出demo中的配置示例：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>配置文件mybatis.xml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class="xml"><span class="line"><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
</span><span class="line"><span class="cp">&lt;!DOCTYPE configuration</span>
</span><span class="line"><span class="cp">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>
</span><span class="line"><span class="cp">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span>
</span><span class="line"><span class="nt">&lt;configuration&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="nt">&lt;settings&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 这个配置使全局的映射器启用或禁用缓存 --&gt;</span>
</span><span class="line">        <span class="nt">&lt;setting</span> <span class="na">name=</span><span class="s">&quot;cacheEnabled&quot;</span> <span class="na">value=</span><span class="s">&quot;false&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;setting</span> <span class="na">name=</span><span class="s">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="na">value=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载 --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载 --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt; --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 允许或不允许多种结果集从一个单独的语句中返回（需要适合的驱动） --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测试两种方法来决定所使用的驱动 --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 允许JDBC支持生成的键。需要适合的驱动。如果设置为true则这个设置强制生成的键被使用，尽管一些驱动拒绝兼容但仍然有效（比如Derby） --&gt;</span>
</span><span class="line">        <span class="nt">&lt;setting</span> <span class="na">name=</span><span class="s">&quot;useGeneratedKeys&quot;</span> <span class="na">value=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 指定MyBatis如何自动映射列到字段/属性。PARTIAL只会自动映射简单，没有嵌套的结果。FULL会自动映射任意复杂的结果（嵌套的或其他情况） --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; --&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 配置默认的执行器。SIMPLE执行器没有什么特别之处。REUSE执行器重用预处理语句。BATCH执行器重用语句和批量更新 --&gt;</span>
</span><span class="line">        <span class="nt">&lt;setting</span> <span class="na">name=</span><span class="s">&quot;safeRowBoundsEnabled&quot;</span> <span class="na">value=</span><span class="s">&quot;false&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;setting</span> <span class="na">name=</span><span class="s">&quot;defaultExecutorType&quot;</span> <span class="na">value=</span><span class="s">&quot;REUSE&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="c">&lt;!-- 设置超时时间，它决定驱动等待一个数据库响应的时间 --&gt;</span>
</span><span class="line">        <span class="nt">&lt;setting</span> <span class="na">name=</span><span class="s">&quot;defaultStatementTimeout&quot;</span> <span class="na">value=</span><span class="s">&quot;600&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">    <span class="nt">&lt;/settings&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="nt">&lt;mappers&gt;</span>
</span><span class="line">        <span class="nt">&lt;mapper</span> <span class="na">resource=</span><span class="s">&quot;mapper/version.xml&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">    <span class="nt">&lt;/mappers&gt;</span>
</span><span class="line">
</span><span class="line"><span class="nt">&lt;/configuration&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>-</p>

<blockquote>
  <blockquote>
    <p>最后，介绍下<code>pom.xml</code>文件，这个实际上，不算是MVC 所仅有的。但是，作为一个maven项目，很多配置都比较关键，一般模块的<code>pom.xml</code>都比较简单，但是<code>	main</code>模块由于涉及编译成war包，并且针对不同的运行环境，对应打包的配置文件不同，因此，其内部配置会比较复杂。具体参考demo项目代码。</p>
  </blockquote>
</blockquote>

<h2 id="a-iddataopsimplespringproject-a"><a id="DataOp">SimpleSpringProject 数据操作实现介绍</a></h2>

<p>整个项目代码都非常简单，不需要过多的去说明。在这里，对于初学者，需要介绍下，数据库相关的访问代码实现逻辑。</p>

<blockquote>
  <blockquote>
    <p>首先，定义一个接口，该接口里面会声明一些需要在	<code>sql</code>中去实现的方法名，如下所示：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>dao层代码 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: tao.ke Date: 14-5-26 Time: 上午11:28</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">VersionDao</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 根据id 查询对应的version信息</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param id</span>
</span><span class="line"><span class="cm">     * @return</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="n">Version</span> <span class="nf">queryVersionById</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">)</span> <span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 查询所有的版本信息</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @return</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="n">List</span><span class="o">&lt;</span><span class="n">Version</span><span class="o">&gt;</span> <span class="nf">queryAllVersions</span><span class="o">();</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>当<code>dao</code>模块则存在了需要实现的接口，则接下来可以在<code>config</code>模块中去实现它，具体实现，如下所示：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>配置文件mapper.xml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
</pre></td><td class="code"><pre><code class="xml"><span class="line"><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
</span><span class="line"><span class="cp">&lt;!DOCTYPE mapper PUBLIC &quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span>
</span><span class="line"><span class="nt">&lt;mapper</span> <span class="na">namespace=</span><span class="s">&quot;io.github.ketao1989.dao.VersionDao&quot;</span><span class="nt">&gt;</span>
</span><span class="line">    <span class="nt">&lt;resultMap</span> <span class="na">id=</span><span class="s">&quot;VersionMap&quot;</span> <span class="na">type=</span><span class="s">&quot;io.github.ketao1989.model.Version&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;id</span> <span class="na">column=</span><span class="s">&quot;id&quot;</span> <span class="na">property=</span><span class="s">&quot;id&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;id&quot;</span> <span class="na">property=</span><span class="s">&quot;id&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;version_num&quot;</span> <span class="na">property=</span><span class="s">&quot;versionNum&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;description&quot;</span> <span class="na">property=</span><span class="s">&quot;description&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;update_time&quot;</span> <span class="na">property=</span><span class="s">&quot;updateTime&quot;</span><span class="nt">/&gt;</span>
</span><span class="line">    <span class="nt">&lt;/resultMap&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="nt">&lt;sql</span> <span class="na">id=</span><span class="s">&quot;versionColumn&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;trim</span> <span class="na">suffix=</span><span class="s">&quot;&quot;</span> <span class="na">suffixOverrides=</span><span class="s">&quot;,&quot;</span><span class="nt">&gt;</span>
</span><span class="line">            <span class="nt">&lt;if</span> <span class="na">test=</span><span class="s">&quot;versionNum != null&quot;</span><span class="nt">&gt;</span>version_num,<span class="nt">&lt;/if&gt;</span>
</span><span class="line">            <span class="nt">&lt;if</span> <span class="na">test=</span><span class="s">&quot;description != null&quot;</span><span class="nt">&gt;</span>description,<span class="nt">&lt;/if&gt;</span>
</span><span class="line">            <span class="nt">&lt;if</span> <span class="na">test=</span><span class="s">&quot;updateTime != null&quot;</span><span class="nt">&gt;</span>update_time<span class="nt">&lt;/if&gt;</span>
</span><span class="line">        <span class="nt">&lt;/trim&gt;</span>
</span><span class="line">    <span class="nt">&lt;/sql&gt;</span>
</span><span class="line">    <span class="nt">&lt;sql</span> <span class="na">id=</span><span class="s">&quot;versionValue&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;trim</span> <span class="na">suffix=</span><span class="s">&quot;&quot;</span> <span class="na">suffixOverrides=</span><span class="s">&quot;,&quot;</span><span class="nt">&gt;</span>
</span><span class="line">            <span class="nt">&lt;if</span> <span class="na">test=</span><span class="s">&quot;versionNum != null&quot;</span><span class="nt">&gt;</span>#{versionNum},<span class="nt">&lt;/if&gt;</span>
</span><span class="line">            <span class="nt">&lt;if</span> <span class="na">test=</span><span class="s">&quot;description != null&quot;</span><span class="nt">&gt;</span>#{description},<span class="nt">&lt;/if&gt;</span>
</span><span class="line">            <span class="nt">&lt;if</span> <span class="na">test=</span><span class="s">&quot;updateTime != null&quot;</span><span class="nt">&gt;</span>#{updateTime}<span class="nt">&lt;/if&gt;</span>
</span><span class="line">        <span class="nt">&lt;/trim&gt;</span>
</span><span class="line">    <span class="nt">&lt;/sql&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- 根据id查询Version记录 --&gt;</span>
</span><span class="line">    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">&quot;queryVersionById&quot;</span> <span class="na">parameterType=</span><span class="s">&quot;map&quot;</span> <span class="na">resultMap=</span><span class="s">&quot;VersionMap&quot;</span><span class="nt">&gt;</span>
</span><span class="line">          select id,version_num,description,update_time
</span><span class="line">          from version
</span><span class="line">          where id = #{id}
</span><span class="line">    <span class="nt">&lt;/select&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="c">&lt;!-- 查询所有Version记录 --&gt;</span>
</span><span class="line">    <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">&quot;queryAllVersions&quot;</span>  <span class="na">resultMap=</span><span class="s">&quot;VersionMap&quot;</span><span class="nt">&gt;</span>
</span><span class="line">          select id,version_num,description,update_time
</span><span class="line">          from version
</span><span class="line">    <span class="nt">&lt;/select&gt;</span>
</span><span class="line"><span class="nt">&lt;/mapper&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note：这样在<code>service</code>模块调用 <code>dao</code>模块的接口，就可以操作数据库了。当然，你在<code>applicationContext.xml</code>中需要配置下面一段代码：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>配置文件applicationContext.xml </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="xml"><span class="line"><span class="c">&lt;!-- 创建SqlSessionFactory --&gt;</span>
</span><span class="line">    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;sqlSessionFactory&quot;</span> <span class="na">name=</span><span class="s">&quot;sqlSessionFactory&quot;</span>
</span><span class="line">          <span class="na">class=</span><span class="s">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;dataSource&quot;</span> <span class="na">ref=</span><span class="s">&quot;dataSource&quot;</span> <span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;configLocation&quot;</span> <span class="na">value=</span><span class="s">&quot;classpath:mybatis-config.xml&quot;</span> <span class="nt">/&gt;</span>
</span><span class="line">    <span class="nt">&lt;/bean&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span><span class="nt">&gt;</span>
</span><span class="line">        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;basePackage&quot;</span> <span class="na">value=</span><span class="s">&quot;io.github.ketao1989.dao&quot;</span> <span class="nt">/&gt;</span>
</span><span class="line">        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="na">value=</span><span class="s">&quot;sqlSessionFactory&quot;</span> <span class="nt">/&gt;</span>
</span><span class="line">    <span class="nt">&lt;/bean&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idfinallya"><a id="Finally">小结</a></h2>

<p>本文只是简单介绍了下<code>Spring MVC</code>项目的一些实现注意点，具体的代码实现，请参考本github上的<a href="https://github.com/ketao1989/simpleSpringProject">SimpleSpringProject</a> 。在demo代码的实现里面，如果你是一个初学者，你会发现更多需要注意的地方。如果你对于本项目的各个地方都能理解，并且可以仿照新建一个项目，那么你对于<code>Spring MVC</code>就已经入门了，可以深入框架源码来进一步学习了。</p>

<p>当然，作为一个提供初学者使用的<code>Spring MVC</code> web工程项目，该demo只是供学习使用而已。你也可以继续在该demo上扩展，增加更多地类，更多地业务和功能，从而完成一个商业大项目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Fork&Join框架使用和实现分析]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/24/Java-Fork-Join-Task-Framework-API-Introduce/"/>
    <updated>2014-05-24T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/24/Java-Fork-Join-Task-Framework-API-Introduce</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#ForkJoin">ForkJoin框架介绍</a></li>
  <li><a href="#API">ForkJoin API介绍</a></li>
  <li><a href="#Example">ForkJoin 使用示例</a></li>
  <li><a href="#Analyze">ForkJoin 实现剖析</a></li>
  <li><a href="#Finally">小结</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>在并发编程网上，关于ForkJoin框架介绍得很好，推荐去看：<a href="http://ifeve.com/fork-join-1/">Fork/Join框架</a>.本篇博文只是对一些地方进行补充说明（为了文章连续性，会借鉴一些介绍文字）。</p>

<p>在上一篇博文：<a href="http://ketao1989.github.io/posts/Java-MultiThread-ThreadPool-Introduce.html">Java 多线程线程池介绍</a> 中最后说明了，对于一个任务可以切割成多个小任务分别执行，然后把各个小任务的结果，组合成最终的结论。熟悉<code>MapReduce</code>的同学，肯定对此再熟悉不过了。</p>

<p>首先贴出一个很简单的代码demo，这段代码是对上篇博文中代码，用<code>ForkJoin</code> API方式来实现（实际上，这并不是一个好的介绍<code>ForkJoin</code>功能的例子，但是我们先用它来入门了）</p>

<blockquote>
  <blockquote>
    <p><code>ForkJoin</code>任务，继承自<code>RecursiveAction</code>，因为我们不需要任务返回什么计算结果：</p>
  </blockquote>
</blockquote>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>测试示例 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">package</span> <span class="n">io</span><span class="o">.</span><span class="na">github</span><span class="o">.</span><span class="na">ketao1989</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">java.util.concurrent.RecursiveAction</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * 很简单的一个操作，就是把字符串加一个后缀，然后放进队列里</span>
</span><span class="line"><span class="cm"> * </span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-24 Time: 下午10:16</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListTask</span> <span class="kd">extends</span> <span class="n">RecursiveAction</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">THRESHOLD</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">processStr</span><span class="o">;</span>
</span><span class="line">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
</span><span class="line">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">processStr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">processStr</span> <span class="o">=</span> <span class="n">processStr</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="nd">@Override</span>
</span><span class="line">    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">isProcess</span> <span class="o">=</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">==</span> <span class="n">THRESHOLD</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">isProcess</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line">            <span class="n">String</span> <span class="n">newStr</span> <span class="o">=</span> <span class="n">processStr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;-test&quot;</span><span class="o">;</span>
</span><span class="line">            <span class="n">processStr</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">newStr</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&quot;----&quot;</span><span class="o">);</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">partPos</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
</span><span class="line">            <span class="n">ListTask</span> <span class="n">taskl</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">processStr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">partPos</span><span class="o">);</span>
</span><span class="line">            <span class="n">ListTask</span> <span class="n">taskr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">processStr</span><span class="o">,</span> <span class="n">partPos</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
</span><span class="line">            <span class="n">invokeAll</span><span class="o">(</span><span class="n">taskl</span><span class="o">,</span> <span class="n">taskr</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p><code>ForkJoin</code>的DEMO主函数，最后如果任务正常结束，则打印<code>任务顺利完成</code>信息：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>测试示例 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">package</span> <span class="n">io</span><span class="o">.</span><span class="na">github</span><span class="o">.</span><span class="na">ketao1989</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">java.util.concurrent.ForkJoinPool</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">com.alibaba.fastjson.JSON</span><span class="o">;</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">com.google.common.collect.Lists</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-24 Time: 下午10:12</span>
</span><span class="line"><span class="cm"> * @version: \$Id: ForkJoinTest.java 6 2014-05-24 14:13:48Z ketao1989 $</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForkJoinTest</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ForkJoinPool</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="s">&quot;thread-11&quot;</span><span class="o">,</span> <span class="s">&quot;thread-21&quot;</span><span class="o">,</span> <span class="s">&quot;thread-31&quot;</span><span class="o">,</span> <span class="s">&quot;thread-41&quot;</span><span class="o">,</span> <span class="s">&quot;thread-51&quot;</span><span class="o">,</span>
</span><span class="line">                <span class="s">&quot;thread-61&quot;</span><span class="o">,</span> <span class="s">&quot;thread-71&quot;</span><span class="o">,</span> <span class="s">&quot;thread-81&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">ListTask</span> <span class="n">listTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class="line">        <span class="n">pool</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">listTask</span><span class="o">);</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">list</span><span class="o">));</span>
</span><span class="line">        <span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">listTask</span><span class="o">.</span><span class="na">isCompletedNormally</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Task 任务顺利完成！&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>执行结果如下，如我们所期望的那样：</p>
  </blockquote>
</blockquote>

<pre><code>ForkJoinPool-1-worker-1----
ForkJoinPool-1-worker-1----
ForkJoinPool-1-worker-1----
ForkJoinPool-1-worker-1
ForkJoinPool-1-worker-3----
ForkJoinPool-1-worker-3
ForkJoinPool-1-worker-3
ForkJoinPool-1-worker-2----
ForkJoinPool-1-worker-1
ForkJoinPool-1-worker-4----
ForkJoinPool-1-worker-4
ForkJoinPool-1-worker-4
ForkJoinPool-1-worker-2----
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-2
["thread-11-test","thread-21-test","thread-31-test","thread-41-test","thread-51-test","thread-61-test","thread-71-test","thread-81-test"]
Task 任务顺利完成！
</code></pre>

<p>上面的代码，其是同步执行任务，也就是说当任务开始执行时，主线程会阻塞执行任务，直到任务执行完成。和线程池一样，你也可以使用Future来完成异步执行任务。此外，对于需要返回结果的<code>ForkJoin</code>，Task类可以继承<code>RecursiveTask&lt;T&gt;</code>类。</p>

<h2 id="a-idforkjoinforkjoina"><a id="ForkJoin">ForkJoin框架介绍</a></h2>

<p><code>ForkJoin</code>框架其本质就是将一个大任务分割成多个小任务来执行，然后将每个小任务执行的结果合并为我们需要的返回值。因此，和当前云计算框架<code>MapReduce</code>一样，其计算主要分两步：</p>

<pre><code>1. Fork操作：就是把一个大的任务分割成多个更小的子任务，然后执行这些小的子任务；

2. Join操作：顾名思义就是等待所有任务完成后返回。
</code></pre>

<p>因此可以看出，命名意义和<code>Linux C</code>的<code>Thread</code>的API定义保持一致。借鉴网络上得一张图来形象描述下：</p>

<p><img src="http://kxcoder.github.io/images/2014/05/forkjoin-work.jpg" /></p>

<p>这个框架被设计用来解决可以使用分而治之技术将任务分解成更小的问题。在一个任务中，检查你想要解决问题的大小，如果它大于一个既定的大小，把它分解成更小的任务，然后用这个框架来执行。如果问题的大小是小于既定的大小，你直接在任务中解决这问题。它返回一个可选地结果。</p>

<p>Fork/Join 和Executor框架主要的区别是<code>work-stealing</code>算法，可以参考上一篇博文：<a href="http://ketao1989.github.io/posts/Java-MultiThread-ThreadPool-Introduce.html">Java 多线程线程池介绍</a>。不像Executor框架，当一个任务正在等待它使用join操作创建的子任务的结 束时，执行这个任务的线程（工作线程）查找其他未被执行的任务并开始它的执行。通过这种方式，线程充分利用它们的运行时间，从而提高了应用程序的性能。</p>

<p>工作窃取算法，<code>work-stealing</code>算法存在可以帮助我们充分利用线程资源来减少执行时间。</p>

<blockquote>
  <blockquote>
    <p>Tips: 我们把一个大的任务分割成多个不相互依赖的小的子任务，并且把这些子任务分别放在不同的执行队列中，每个执行队列分别创建一个单独的线程来执行任务。默认线程数（队列数）为执行机器的CPU核数+1，具体可以看看上面DEMO执行的线程编号。每个队列分别有一个线程单独去执行，是为了避免或减少线程间的竞争。当某线程执行完队列中得所有任务时，而有其他线程没有完成对应队列中的任务时，线程会协助其他线程完成其对应队列中剩余的任务。为了避免线程间获取队列任务时产生竞争，显然会采取双端队列从而线程可以从队列尾部拿到还未被执行的任务，而真正执行队列任务的线程，则依然从队列头部获取任务。当然，该算法遇到队列只有一个任务时，也会产生竞争，并且多个队列和多个线程，也会消耗更多的系统资源。</p>
  </blockquote>
</blockquote>

<p>为实现这个目标，Fork/Join框架执行的任务有以下局限性：</p>

<pre><code>1. 任务只能使用`fork()`和`join()`操作，作为同步机制。如果使用其他同步机制，工作线程不能执行其他任务，当它们在同步操作时。比如，在Fork/Join框架中，你使任务进入睡眠，正在执行这个任务的工作线程将不会执行其他任务，在这睡眠期间内。

2. 任务不应该执行I/O操作，如读或写数据文件。

3. 任务不能抛出检查异常，它必须包括必要的代码来处理它们。
</code></pre>

<p>Fork/Join框架的核心是由以下两个类：</p>

<pre><code>1. ForkJoinPool：它实现ExecutorService接口和work-stealing算法。它管理工作线程和提供关于任务的状态和它们执行的信息。

2. ForkJoinTask： 它是将在ForkJoinPool中执行的任务的基类。它提供在任务中执行fork()和join()操作的机制，并且这两个方法控制任务的状态。通常， 为了实现你的Fork/Join任务，你将实现两个子类的子类的类：RecursiveAction对于没有返回结果的任务和RecursiveTask 对于返回结果的任务。
</code></pre>

<h2 id="a-idapiforkjoin-apia"><a id="API">ForkJoin API介绍</a></h2>

<p>一般地，你需要按照下面两种情况下使用<code>ForkJoin</code>框架的API：</p>

<blockquote>
  <blockquote>
    <p><code>RecursiveAction</code>任务对应的API使用模型：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RecursiveAction </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">		<span class="n">If</span> <span class="o">(</span><span class="n">problem</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="k">default</span> <span class="n">size</span><span class="o">){</span>
</span><span class="line">            <span class="n">tasks</span><span class="o">=</span><span class="n">divide</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
</span><span class="line">            <span class="n">execute</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">            <span class="n">resolve</span> <span class="n">problem</span> <span class="n">using</span> <span class="n">another</span> <span class="n">algorithm</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p><code>RecursiveTask&lt;V&gt;</code>类任务对应的API使用模型：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RecursiveTask </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">        <span class="n">If</span> <span class="o">(</span><span class="n">problem</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">){</span>
</span><span class="line">            <span class="n">tasks</span><span class="o">=</span><span class="n">Divide</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
</span><span class="line">            <span class="n">execute</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
</span><span class="line">            <span class="n">groupResults</span><span class="o">()</span>
</span><span class="line">            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">            <span class="n">resolve</span> <span class="n">problem</span><span class="o">;</span>
</span><span class="line">            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>首先，看看<code>ForkJoinPool</code>类的构造函数，和一些重要的对外提供的方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinPool </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">	 * 创建线程数为当前系统CPU核数+1的{@code ForkJoinPool}对象，该对象使用{@linkplain</span>
</span><span class="line"><span class="cm">     * #defaultForkJoinWorkerThreadFactory default thread factory}，没有异常处理器和非异步的LIFO处理模式</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @throws SecurityException if a security manager exists and</span>
</span><span class="line"><span class="cm">     *         the caller is not permitted to modify threads</span>
</span><span class="line"><span class="cm">     *         because it does not hold {@link</span>
</span><span class="line"><span class="cm">     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">(</span><span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">(),</span>
</span><span class="line">             <span class="n">defaultForkJoinWorkerThreadFactory</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 指定线程数</span>
</span><span class="line">    <span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">parallelism</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">(</span><span class="n">parallelism</span><span class="o">,</span> <span class="n">defaultForkJoinWorkerThreadFactory</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 原生的构造函数</span>
</span><span class="line">    <span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">parallelism</span><span class="o">,</span>
</span><span class="line">                        <span class="n">ForkJoinWorkerThreadFactory</span> <span class="n">factory</span><span class="o">,</span>
</span><span class="line">                        <span class="n">Thread</span><span class="o">.</span><span class="na">UncaughtExceptionHandler</span> <span class="n">handler</span><span class="o">,</span>
</span><span class="line">                        <span class="kt">boolean</span> <span class="n">asyncMode</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 执行给定的task任务，直到执行完成之后返回它的结果</span>
</span><span class="line">    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">	<span class="c1">// 异步执行给定的task任务</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">task</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 提交一个 ForkJoinTask 任务去执行</span>
</span><span class="line">    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">)</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 按照先前提交任务的顺序关闭，但是不在接收新的任务。对于已经关闭的pool，不会有副作用。</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来，看看<code>RecursiveAction</code>类的构造函数，以及相应地方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RecursiveAction </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="c1">// 抽象类，</span>
</span><span class="line">	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RecursiveAction</span> <span class="kd">extends</span> <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 任务需要执行的代码. 继承该类的子类，需要重写该方法</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后，看看<code>RecursiveTask</code>类的构造函数，以及相应地方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RecursiveTask </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="c1">// 抽象类，</span>
</span><span class="line">	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RecursiveTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 任务需要执行的代码. 继承该类的子类，需要重写该方法</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">V</span> <span class="nf">compute</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idexampleforkjoin-a"><a id="Example">ForkJoin 使用示例</a></h2>

<p>在前言中已经给出了关于<code>RecursiveAction</code>的demo，下面来看看使用<code>RecursiveTask</code>来实现该问题的代码，一并说明异步返回：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RecursiveAction demo </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">package</span> <span class="n">io</span><span class="o">.</span><span class="na">github</span><span class="o">.</span><span class="na">ketao1989</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">java.util.concurrent.RecursiveTask</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">com.google.common.collect.Lists</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * 很简单的一个操作，就是把字符串加一个后缀，然后放进队列里</span>
</span><span class="line"><span class="cm"> * </span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-24 Time: 下午10:16</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListTask</span> <span class="kd">extends</span> <span class="n">RecursiveTask</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">THRESHOLD</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">processStr</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
</span><span class="line">    <span class="kd">private</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">processStr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">processStr</span> <span class="o">=</span> <span class="n">processStr</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="nd">@Override</span>
</span><span class="line">    <span class="kd">protected</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayListWithCapacity</span><span class="o">(</span><span class="n">processStr</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">isProcess</span> <span class="o">=</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">==</span> <span class="n">THRESHOLD</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">isProcess</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line">            <span class="n">String</span> <span class="n">newStr</span> <span class="o">=</span> <span class="n">processStr</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;-test&quot;</span><span class="o">;</span>
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newStr</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&quot;---&quot;</span><span class="o">);</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">partPos</span> <span class="o">=</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
</span><span class="line">            <span class="n">ListTask</span> <span class="n">taskl</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">processStr</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">partPos</span><span class="o">);</span>
</span><span class="line">            <span class="n">ListTask</span> <span class="n">taskr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">processStr</span><span class="o">,</span> <span class="n">partPos</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">            <span class="n">taskl</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span> <span class="c1">//按序异步执行这个任务，会放到一个队列里</span>
</span><span class="line">            <span class="n">taskr</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">            <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">resultl</span> <span class="o">=</span> <span class="n">taskl</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> <span class="c1">//等待执行完成后返回，调用isDone 会返回true</span>
</span><span class="line">            <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">resultr</span> <span class="o">=</span> <span class="n">taskr</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">resultl</span><span class="o">);</span>
</span><span class="line">            <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">resultr</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line">        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * 测试主函数</span>
</span><span class="line"><span class="cm"> * </span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-24 Time: 下午10:12</span>
</span><span class="line"><span class="cm"> * @version: \$Id: ForkJoinTest.java 6 2014-05-24 14:13:48Z ketao1989 $</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForkJoinTest</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ForkJoinPool</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="s">&quot;thread-11&quot;</span><span class="o">,</span> <span class="s">&quot;thread-21&quot;</span><span class="o">,</span> <span class="s">&quot;thread-31&quot;</span><span class="o">,</span> <span class="s">&quot;thread-41&quot;</span><span class="o">,</span> <span class="s">&quot;thread-51&quot;</span><span class="o">,</span>
</span><span class="line">                <span class="s">&quot;thread-61&quot;</span><span class="o">,</span> <span class="s">&quot;thread-71&quot;</span><span class="o">,</span> <span class="s">&quot;thread-81&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">ListTask</span> <span class="n">listTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListTask</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class="line">        <span class="n">Future</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">listTask</span><span class="o">);</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">()));</span>
</span><span class="line">        <span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">listTask</span><span class="o">.</span><span class="na">isCompletedNormally</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Task 任务顺利完成！&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行结果，如下所示：</p>

<pre><code>ForkJoinPool-1-worker-1---
ForkJoinPool-1-worker-2---
ForkJoinPool-1-worker-3---
ForkJoinPool-1-worker-4---
ForkJoinPool-1-worker-5
ForkJoinPool-1-worker-5---
ForkJoinPool-1-worker-3
ForkJoinPool-1-worker-3---
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-5
ForkJoinPool-1-worker-1---
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-2
ForkJoinPool-1-worker-3
["thread-11-test","thread-21-test","thread-31-test","thread-41-test","thread-51-test","thread-61-test","thread-71-test","thread-81-test"]
Task 任务顺利完成！
</code></pre>

<blockquote>
  <blockquote>
    <p>demo代码很简单，这里不进行说明。</p>
  </blockquote>
</blockquote>

<h2 id="a-idanalyzeforkjoin-a"><a id="Analyze">ForkJoin 实现剖析</a></h2>

<p><code>ForkJoin</code>整体框架相对简单明了，实现起来，也就是<code>ForkJoinTask</code> 和<code>ForkJoinWorkerThread</code>两部分，其中Task负责存放需要执行的任务，而Thread负责执行任务即可。具体实现，如下分析。</p>

<h3 id="forkjoinpool">5.1 ForkJoinPool实现分析</h3>

<p>首先，看<code>ForkJoinPool</code>类的构造函数，代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinPool实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="kd">public</span> <span class="nf">ForkJoinPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">parallelism</span><span class="o">,</span>
</span><span class="line">                        <span class="n">ForkJoinWorkerThreadFactory</span> <span class="n">factory</span><span class="o">,</span>
</span><span class="line">                        <span class="n">Thread</span><span class="o">.</span><span class="na">UncaughtExceptionHandler</span> <span class="n">handler</span><span class="o">,</span>
</span><span class="line">                        <span class="kt">boolean</span> <span class="n">asyncMode</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">checkPermission</span><span class="o">();</span> <span class="c1">// 安全管理，检查操作是否有权限修改线程</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">factory</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line">            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">parallelism</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">parallelism</span> <span class="o">&gt;</span> <span class="n">MAX_ID</span><span class="o">)</span>
</span><span class="line">            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">parallelism</span> <span class="o">=</span> <span class="n">parallelism</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">factory</span> <span class="o">=</span> <span class="n">factory</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">ueh</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">locallyFifo</span> <span class="o">=</span> <span class="n">asyncMode</span><span class="o">;</span>
</span><span class="line">        <span class="kt">long</span> <span class="n">np</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)(-</span><span class="n">parallelism</span><span class="o">);</span> <span class="c1">// offset ctl counts</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">ctl</span> <span class="o">=</span> <span class="o">((</span><span class="n">np</span> <span class="o">&lt;&lt;</span> <span class="n">AC_SHIFT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">AC_MASK</span><span class="o">)</span> <span class="o">|</span> <span class="o">((</span><span class="n">np</span> <span class="o">&lt;&lt;</span> <span class="n">TC_SHIFT</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">TC_MASK</span><span class="o">);</span><span class="c1">//ctl是整个池的核心控制技术变量，说明见下面</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">submissionQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[</span><span class="n">INITIAL_QUEUE_CAPACITY</span><span class="o">];</span> <span class="c1">// 提交任务队列</span>
</span><span class="line">        <span class="c1">// initialize workers array with room for 2*parallelism if possible</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">parallelism</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAX_ID</span><span class="o">)</span>
</span><span class="line">            <span class="n">n</span> <span class="o">=</span> <span class="n">MAX_ID</span><span class="o">;</span>
</span><span class="line">        <span class="k">else</span> <span class="o">{</span> <span class="c1">// 当 n &lt; (1 &lt;&lt; 16)时，计算 n对应2进制的后面所有bit位为1，比如：6 = 110B --&gt; 111B = 7 ；8 = 1000B --&gt; 1111B = 15</span>
</span><span class="line">            <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span> <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span> <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">workers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinWorkerThread</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span> <span class="c1">//执行任务的线程数组，n+1</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">submissionLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">termination</span> <span class="o">=</span> <span class="n">submissionLock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</span><span class="line">        <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">(</span><span class="s">&quot;ForkJoinPool-&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">poolNumberGenerator</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">());</span> <span class="c1">// pool 序数</span>
</span><span class="line">        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;-worker-&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">workerNamePrefix</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// 线程名前缀在demo中，结果中打印出来了</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p><code>ForkJoinPool</code>代码中变量<code>volatile long ctl</code>包含了<code>forkjoinpool</code>几个核心的数值，使用bit位来表示。具体为： AC(16 bits)–活跃运行的<code>worker</code>数量减去当前系统<code>parallelism</code>值；TC(16 bits)–总的<code>worker</code>数减去当前系统<code>parallelism</code>值；ST（1 bits）– <code>pool</code>是否结束；EC(15 bits) –等待线程组的头部的等待数；ID（16 bits）– 正在等待的线程组栈顶的索引<code>poolIndex</code>.</p>
  </blockquote>
</blockquote>

<hr />

<blockquote>
  <blockquote>
    <p>Tips: 在构造函数中，创建了两个对象，分别是大小为<code>8</code>的<code>ForkJoinTask</code>数组 和 大小为<code>n+1</code>（4核Cpu为8）的 <code>ForkJoinWorkerThread</code>。因此，可以知道<strong>在初始化的时候，提交任务队列的大小 和 执行任务的线程数 很可能不相等</strong>。</p>
  </blockquote>
</blockquote>

<p>接下来需要说明的是，<code>ForkJoinPool</code>的<code>submit</code>方法，其会调用<code>forkOrSubmit(ForkJoinTask&lt;T&gt; task)</code>，实现代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinPool实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"> 	<span class="kd">private</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">forkOrSubmit</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span>
</span><span class="line">        <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">shutdown</span><span class="o">)</span>
</span><span class="line">            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RejectedExecutionException</span><span class="o">();</span>
</span><span class="line">        <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">ForkJoinWorkerThread</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class="line">            <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="n">ForkJoinWorkerThread</span><span class="o">)</span><span class="n">t</span><span class="o">).</span><span class="na">pool</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
</span><span class="line">            <span class="n">w</span><span class="o">.</span><span class="na">pushTask</span><span class="o">(</span><span class="n">task</span><span class="o">);</span><span class="c1">//push 该任务到该线程对应的队列中</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">            <span class="nf">addSubmission</span><span class="o">(</span><span class="n">task</span><span class="o">);</span> <span class="c1">//把任务task 插入到submissionQueue队列中</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>因此，需要执行的任务task已经被放进了队列中，执行线程可以获取任务来进行执行了。<code>addSubmission</code>运行时会使用<code>this.submissionLock</code>锁，并且入队之后，会调用<code>signalWork()</code>方法，该方法会根据当前<code>pool</code>中<code>worker</code>数量和状态来决定 唤醒或者创建一个worker。</p>
  </blockquote>
</blockquote>

<hr />

<blockquote>
  <blockquote>
    <p>在<code>pool</code>中有一个核心的顶层循环，所有的工作线程都会按照这个步骤执行：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinPool实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 在每一步：如果上一步顺利通过所有的队列，并且发现没有了任务；或者有多余的线程，则可能会阻塞。此外，扫描scan，如果发现任务，则执行。</span>
</span><span class="line"><span class="cm">     * 当pool和 worker结束的时候，返回， </span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">swept</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>                <span class="c1">// true on empty scans</span>
</span><span class="line">        <span class="kt">long</span> <span class="n">c</span><span class="o">;</span>
</span><span class="line">        <span class="k">while</span> <span class="o">(!</span><span class="n">w</span><span class="o">.</span><span class="na">terminate</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//当线程未结束，并且还有任务未完成执行</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>                            <span class="c1">// active count</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(!</span><span class="n">swept</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="n">AC_SHIFT</span><span class="o">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class="line">                <span class="n">swept</span> <span class="o">=</span> <span class="n">scan</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">a</span><span class="o">);</span> <span class="c1">//扫描任务，发现，则执行</span>
</span><span class="line">            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">tryAwaitWork</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="c1">//把worker线程放入等待queue中，等待worker的eventCount改变。</span>
</span><span class="line">                <span class="n">swept</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p><code>Scan</code>方法的逻辑其实很简单，就是首先获取其线程内部的queue，执行任务；如果完了，则steal其他<code>worker</code>线程的任务；如果还没有，则执行pool中的<code>submissionQueue</code>。再没有，则返回true。</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinPool实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     * Scans for and, if found, executes one task. Scans start at a</span>
</span><span class="line"><span class="cm">     * random index of workers array, and randomly select the first</span>
</span><span class="line"><span class="cm">     * (2*#workers)-1 probes, and then, if all empty, resort to 2</span>
</span><span class="line"><span class="cm">     * circular sweeps, which is necessary to check quiescence. and</span>
</span><span class="line"><span class="cm">     * taking a submission only if no stealable tasks were found.  The</span>
</span><span class="line"><span class="cm">     * steal code inside the loop is a specialized form of</span>
</span><span class="line"><span class="cm">     * ForkJoinWorkerThread.deqTask, followed bookkeeping to support</span>
</span><span class="line"><span class="cm">     * helpJoinTask and signal propagation. The code for submission</span>
</span><span class="line"><span class="cm">     * queues is almost identical. On each steal, the worker completes</span>
</span><span class="line"><span class="cm">     * not only the task, but also all local tasks that this task may</span>
</span><span class="line"><span class="cm">     * have generated. On detecting staleness or contention when</span>
</span><span class="line"><span class="cm">     * trying to take a task, this method returns without finishing</span>
</span><span class="line"><span class="cm">     * sweep, which allows global state rechecks before retry.</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param w the worker</span>
</span><span class="line"><span class="cm">     * @param a the number of active workers</span>
</span><span class="line"><span class="cm">     * @return true if swept all queues without finding a task</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">scan</span><span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">scanGuard</span><span class="o">;</span> <span class="c1">// mask 0 avoids useless scans if only one active</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">parallelism</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">blockedCount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span>
</span><span class="line">        <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">workers</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">)</span>         <span class="c1">// staleness check</span>
</span><span class="line">            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">seed</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">r</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-(</span><span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">);</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
</span><span class="line">            <span class="n">ForkJoinWorkerThread</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">];</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span><span class="o">)</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="na">queueTop</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">queue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
</span><span class="line">                <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">v</span><span class="o">.</span><span class="na">queueTop</span><span class="o">;</span>
</span><span class="line">                    <span class="n">v</span><span class="o">.</span><span class="na">stealHint</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">poolIndex</span><span class="o">;</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class="line">                        <span class="n">signalWork</span><span class="o">();</span>             <span class="c1">// propagate if nonempty</span>
</span><span class="line">                    <span class="n">w</span><span class="o">.</span><span class="na">execTask</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="o">;</span> <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">17</span><span class="o">;</span> <span class="n">w</span><span class="o">.</span><span class="na">seed</span> <span class="o">=</span> <span class="n">r</span> <span class="o">^</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="o">);</span>
</span><span class="line">                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>                     <span class="c1">// store next seed</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>                     <span class="c1">// xorshift</span>
</span><span class="line">                <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="o">;</span> <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">17</span><span class="o">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">^=</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="k">else</span>
</span><span class="line">                <span class="o">++</span><span class="n">k</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">scanGuard</span> <span class="o">!=</span> <span class="n">g</span><span class="o">)</span>                       <span class="c1">// staleness check</span>
</span><span class="line">            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="k">else</span> <span class="o">{</span>                                    <span class="c1">// try to take submission</span>
</span><span class="line">            <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
</span><span class="line">            <span class="k">if</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">!=</span> <span class="n">queueTop</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">submissionQueue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
</span><span class="line">                <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                    <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class="line">                    <span class="n">w</span><span class="o">.</span><span class="na">execTask</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>                         <span class="c1">// all queues empty</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="forkjoinworkerthread">5.2 ForkJoinWorkerThread实现分析</h3>

<p>在<code>submit</code>方法中调用了<code>pushTask(ForkJoinTask&lt;?&gt; t)</code>方法，其实现在<code>ForkJoinWorkerThread</code>类中。<code>ForkJoinWorkerThread</code>类是用来被<code>ForkJoinPool</code>管理的线程类型，该类线程值执行<code>ForkJoinTask</code>类任务对象。</p>

<p>依然首先看看其构造方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinWorkerThread实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 在给定的pool里面创建一个 ForkJoinWorkerThread 实例.</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">protected</span> <span class="nf">ForkJoinWorkerThread</span><span class="o">(</span><span class="n">ForkJoinPool</span> <span class="n">pool</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kd">super</span><span class="o">(</span><span class="n">pool</span><span class="o">.</span><span class="na">nextWorkerName</span><span class="o">());</span> <span class="c1">// 使用Thread调用pool中指定的线程名前缀</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="o">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">registerWorker</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">//注册线程到pool得worker数组中，获取在pool数组里对应的index索引</span>
</span><span class="line">        <span class="n">poolIndex</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
</span><span class="line">        <span class="n">eventCount</span> <span class="o">=</span> <span class="o">~</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span> <span class="c1">// clear wait count</span>
</span><span class="line">        <span class="n">locallyFifo</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">locallyFifo</span><span class="o">;</span>
</span><span class="line">        <span class="n">Thread</span><span class="o">.</span><span class="na">UncaughtExceptionHandler</span> <span class="n">ueh</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">ueh</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">ueh</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line">            <span class="n">setUncaughtExceptionHandler</span><span class="o">(</span><span class="n">ueh</span><span class="o">);</span>
</span><span class="line">        <span class="n">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">//守护线程</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Tips: 在构造方法里面，新建的线程实例，会注册到<code>pool</code>的<code>worker</code>数组中去，当<code>worker</code>数组大小不够，会进行<code>CopyOf</code>操作，把大小扩大原来的一倍。此外，代码的实现被没有获取lock操作。此外，创建的线程被指定为<code>守护进程</code>。</p>
  </blockquote>
</blockquote>

<p>接着来看看了<code>pushTask(ForkJoinTask&lt;?&gt; t)</code>方法的实现，该方法和<code>pool</code>的<code>addSubmission</code>方法基本一致，除了<code>addSubmission</code>会增加互斥锁操作。代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinWorkerThread实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * Pushes a task. Call only from this thread.</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param t the task. Caller must ensure non-null.</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">pushTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">// ignore if queue removed</span>
</span><span class="line">            <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">queueTop</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
</span><span class="line">            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">putOrderedObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 把q数组偏移量为u的对应的值，置为t。不保证及时内存可见，如果field不为volatile</span>
</span><span class="line">            <span class="n">queueTop</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>         <span class="c1">// or use putOrderedInt</span>
</span><span class="line">            <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">-=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span>
</span><span class="line">                <span class="n">pool</span><span class="o">.</span><span class="na">signalWork</span><span class="o">();</span> <span class="c1">//唤醒或者新建worker线程</span>
</span><span class="line">            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span>
</span><span class="line">                <span class="n">growQueue</span><span class="o">();</span> <span class="c1">//当s的值和队列值长度length-1一样时，即队列已满，则增加队列大小。</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>关于<code>UNSAFE</code>的实现，底层实现的<code>native</code>方法是C++，具体代码可以参见：<a href="http://www.oschina.net/code/explore/gcc-4.5.2/libjava/sun/misc">UNSAFE 源码实现链接</a></p>
  </blockquote>
</blockquote>

<hr />

<blockquote>
  <blockquote>
    <p>作为一个<code>Thread</code>的继承子类，必然需要实现<code>run</code>方法，实现细节如下：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinWorkerThread实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Throwable</span> <span class="n">exception</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">        <span class="k">try</span> <span class="o">{</span>
</span><span class="line">            <span class="n">onStart</span><span class="o">();</span> <span class="c1">// 该方法主要负责初始化Task 队列，和seed值</span>
</span><span class="line">            <span class="n">pool</span><span class="o">.</span><span class="na">work</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">// 调用pool的work方法，在pool中说明</span>
</span><span class="line">        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">exception</span> <span class="o">=</span> <span class="n">ex</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">            <span class="n">onTermination</span><span class="o">(</span><span class="n">exception</span><span class="o">);</span><span class="c1">// 清除该worker线程关于结束的一些操作，比如取消任务，解除在pool上的注册，状态为结束terminate</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="forkjointask">5.3 ForkJoinTask实现分析</h3>

<p>在API接口描述中，可以看出<code>RecursiveAction</code>类和<code>RecursiveTask</code>类都继承自<code>ForkJoinTask</code>抽象类，唯一不同就是一个不返回执行结果。在<code>ForkJoinTask</code>中需要关注的就是<code>join</code>方法和<code>fork</code>方法。</p>

<p>首先是<code>fork</code>方法的实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinTask实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 按序的异步执行这个任务.</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">final</span> <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">fork</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="o">((</span><span class="n">ForkJoinWorkerThread</span><span class="o">)</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span>
</span><span class="line">            <span class="o">.</span><span class="na">pushTask</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class="line">        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p><code>fork</code>方法实际上就是把新创建的子任务提交给当前线程，由当前线程push到它自身的队列数组中。</p>
  </blockquote>
</blockquote>

<p>接下来看看<code>join</code>方法的实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinTask实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">   <span class="cm">/**</span>
</span><span class="line"><span class="cm">     *当任务执行完成后，返回执行的结果，该方法和`Feture.get()`不同的地方时，其抛出的异常是`RuntimeException`和`Error`。</span>
</span><span class="line"><span class="cm">     *此外，也不会抛出`InterruptedException`。</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">join</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">doJoin</span><span class="o">()</span> <span class="o">!=</span> <span class="n">NORMAL</span><span class="o">)</span> <span class="c1">// 任务没有正常完成</span>
</span><span class="line">            <span class="k">return</span> <span class="nf">reportResult</span><span class="o">();</span> <span class="c1">//处理非正常情况</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">            <span class="k">return</span> <span class="nf">getRawResult</span><span class="o">();</span> <span class="c1">// 返回结果</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p><code>doJoin()</code>方法算是<code>ForkJoinTask</code>类主要方法之一，其他的方法<code>doInvoke</code>、<code>doExec</code>方法和<code>doJoin</code>一样，都会执行核心的任务自定义<code>compute</code>方法。</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ForkJoinTask实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     * Primary mechanics for join, get, quietlyJoin.</span>
</span><span class="line"><span class="cm">     * @return status upon completion</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">doJoin</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Thread</span> <span class="n">t</span><span class="o">;</span> <span class="n">ForkJoinWorkerThread</span> <span class="n">w</span><span class="o">;</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span> <span class="kt">boolean</span> <span class="n">completed</span><span class="o">;</span>
</span><span class="line">        <span class="k">if</span> <span class="o">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span> <span class="k">instanceof</span> <span class="n">ForkJoinWorkerThread</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 如果任务已经完成，则直接返回</span>
</span><span class="line">                <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
</span><span class="line">            <span class="k">if</span> <span class="o">((</span><span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="n">ForkJoinWorkerThread</span><span class="o">)</span><span class="n">t</span><span class="o">).</span><span class="na">unpushTask</span><span class="o">(</span><span class="k">this</span><span class="o">))</span> <span class="o">{</span> <span class="c1">//从当前线程的任务数组中 pop 该任务，准备执行</span>
</span><span class="line">                <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">completed</span> <span class="o">=</span> <span class="n">exec</span><span class="o">();</span> <span class="c1">// 调用自定义任务的compute方法执行</span>
</span><span class="line">                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">rex</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                    <span class="k">return</span> <span class="nf">setExceptionalCompletion</span><span class="o">(</span><span class="n">rex</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">completed</span><span class="o">)</span>
</span><span class="line">                    <span class="k">return</span> <span class="nf">setCompletion</span><span class="o">(</span><span class="n">NORMAL</span><span class="o">);</span> <span class="c1">//如果顺利正常完成，则设置为正常完成状态</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="na">joinTask</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">//当任务没有正常完成，可能阻塞什么的，则会给helpJoinTask stolen-&gt;joining 方式执行</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">            <span class="k">return</span> <span class="nf">externalAwaitDone</span><span class="o">();</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<h3 id="jointask-">5.4 joinTask 方法实现分析</h3>

<p><code>joinTask</code>方法的具体实现在<code>ForkJoinWorkerThread</code>类中。但是由于其实现了 <code>ForkJoin</code>中关于<code>work-stealing</code>算法的实现，所以当初分析下。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>joinTask 方法实现分析 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="c1">// helpJoinTask允许的最大stolen-&gt;joining 链深度，同时也是重试的最大次数</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_HELP</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">joinTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">joinMe</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">prevJoin</span> <span class="o">=</span> <span class="n">currentJoin</span><span class="o">;</span> <span class="c1">//保存当前在执行的任务</span>
</span><span class="line">        <span class="n">currentJoin</span> <span class="o">=</span> <span class="n">joinMe</span><span class="o">;</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="n">MAX_HELP</span><span class="o">;;)</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">joinMe</span><span class="o">.</span><span class="na">status</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//当joinMe任务正常完成，则执行原来正在执行的任务，返回执行状态</span>
</span><span class="line">                <span class="n">currentJoin</span> <span class="o">=</span> <span class="n">prevJoin</span><span class="o">;</span>
</span><span class="line">                <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">queueTop</span> <span class="o">!=</span> <span class="n">queueBase</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//当前队列中有任务未被执行</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">(!</span><span class="n">localHelpJoinTask</span><span class="o">(</span><span class="n">joinMe</span><span class="o">))</span> <span class="c1">//并且队列中还存在其他未取消的任务，则不重试，扔到pool.tryAwaitJoin中</span>
</span><span class="line">                        <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>           <span class="c1">// cannot help</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">retries</span> <span class="o">==</span> <span class="n">MAX_HELP</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//这个值为什么这么判断呢？？为什么retries == 8 执行下面逻辑？？</span>
</span><span class="line">                    <span class="o">--</span><span class="n">retries</span><span class="o">;</span>                 <span class="c1">// check uncommon case</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">(</span><span class="n">tryDeqAndExec</span><span class="o">(</span><span class="n">joinMe</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 当joinMe是一些worker 队列的base上面，则steal，并且执行，执行的状态为不正常完成时</span>
</span><span class="line">                        <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>        <span class="c1">// 则礼貌性的暂停任务</span>
</span><span class="line">                       <span class="o">}</span>
</span><span class="line">                <span class="k">else</span>
</span><span class="line">                	<span class="c1">// 尝试定位和执行给定任务的stealer的任务集，或者轮流执行他的所有stealers的一个。如果运行一个任务，则返回true</span>
</span><span class="line">                    <span class="n">retries</span> <span class="o">=</span> <span class="n">helpJoinTask</span><span class="o">(</span><span class="n">joinMe</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAX_HELP</span> <span class="o">:</span> <span class="n">retries</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="k">else</span> <span class="o">{</span>
</span><span class="line">                <span class="n">retries</span> <span class="o">=</span> <span class="n">MAX_HELP</span><span class="o">;</span>           <span class="c1">// restart if not done</span>
</span><span class="line">                <span class="n">pool</span><span class="o">.</span><span class="na">tryAwaitJoin</span><span class="o">(</span><span class="n">joinMe</span><span class="o">);</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">helpJoinTask</span><span class="o">(</span><span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">joinMe</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">helped</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">scanGuard</span> <span class="o">&amp;</span> <span class="n">SMASK</span><span class="o">;</span>
</span><span class="line">        <span class="n">ForkJoinWorkerThread</span><span class="o">[]</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">workers</span><span class="o">;</span> <span class="c1">//获取pool所有的worker线程数组</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">ws</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">joinMe</span><span class="o">.</span><span class="na">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">levels</span> <span class="o">=</span> <span class="n">MAX_HELP</span><span class="o">;</span>              <span class="c1">// remaining chain length</span>
</span><span class="line">            <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="n">joinMe</span><span class="o">;</span>      <span class="c1">// base of chain</span>
</span><span class="line">            <span class="nl">outer:</span><span class="k">for</span> <span class="o">(</span><span class="n">ForkJoinWorkerThread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">this</span><span class="o">;;)</span> <span class="o">{</span>
</span><span class="line">                <span class="c1">// Try to find v, the stealer of task, by first using hint</span>
</span><span class="line">                <span class="n">ForkJoinWorkerThread</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">thread</span><span class="o">.</span><span class="na">stealHint</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">];</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">v</span><span class="o">.</span><span class="na">currentSteal</span> <span class="o">!=</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;)</span> <span class="o">{</span>        <span class="c1">// search array</span>
</span><span class="line">                        <span class="k">if</span> <span class="o">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">ws</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">.</span><span class="na">currentSteal</span> <span class="o">==</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                            <span class="n">thread</span><span class="o">.</span><span class="na">stealHint</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class="line">                            <span class="k">break</span><span class="o">;</span>              <span class="c1">// save hint for next time</span>
</span><span class="line">                        <span class="o">}</span>
</span><span class="line">                        <span class="k">if</span> <span class="o">(++</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span>
</span><span class="line">                            <span class="k">break</span> <span class="n">outer</span><span class="o">;</span>        <span class="c1">// can&#39;t find stealer</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="c1">// Try to help v, using specialized form of deqTask</span>
</span><span class="line">                <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;[]</span> <span class="n">q</span><span class="o">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">(</span><span class="n">joinMe</span><span class="o">.</span><span class="na">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class="line">                        <span class="k">break</span> <span class="n">outer</span><span class="o">;</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">((</span><span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span><span class="o">)</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="na">queueTop</span> <span class="o">||</span>
</span><span class="line">                        <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">queue</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
</span><span class="line">                        <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class="line">                        <span class="k">break</span><span class="o">;</span>                  <span class="c1">// empty</span>
</span><span class="line">                    <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">ASHIFT</span><span class="o">)</span> <span class="o">+</span> <span class="n">ABASE</span><span class="o">;</span>
</span><span class="line">                    <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">(</span><span class="n">task</span><span class="o">.</span><span class="na">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class="line">                        <span class="k">break</span> <span class="n">outer</span><span class="o">;</span>            <span class="c1">// stale</span>
</span><span class="line">                    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">==</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">v</span><span class="o">.</span><span class="na">queueBase</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class="line">                        <span class="n">v</span><span class="o">.</span><span class="na">stealHint</span> <span class="o">=</span> <span class="n">poolIndex</span><span class="o">;</span>
</span><span class="line">                        <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">currentSteal</span><span class="o">;</span>
</span><span class="line">                        <span class="n">currentSteal</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
</span><span class="line">                        <span class="n">t</span><span class="o">.</span><span class="na">doExec</span><span class="o">();</span> <span class="c1">// 好了，这里获取到了steal到的task，可以执行了</span>
</span><span class="line">                        <span class="n">currentSteal</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
</span><span class="line">                        <span class="n">helped</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">//执行了任务，这里设为true</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="c1">// Try to descend to find v&#39;s stealer</span>
</span><span class="line">                <span class="n">ForkJoinTask</span><span class="o">&lt;?&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="na">currentJoin</span><span class="o">;</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(--</span><span class="n">levels</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">task</span><span class="o">.</span><span class="na">status</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                    <span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">!=</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">task</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class="line">                    <span class="n">thread</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">else</span>
</span><span class="line">                    <span class="k">break</span><span class="o">;</span>  <span class="c1">// max levels, stale, dead-end, or cyclic</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">helped</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idfinallya"><a id="Finally">小结</a></h2>

<p>本文只是简单地分析了Fork&amp;Join 框架的用法和实现。由于JDK 中 关于多线程的代码，有些还涉及到native得实现，并且代码可读性不是太好，导致有些理解不是很清楚。不过知道大体框架和使用方法，应该就可以满足日常使用了。</p>

<p>Fork Join 框架的思想，在很多地方都可以体现，只是实现的繁简而已。大任务的切割，小任务的并发执行，然后Reuce 各个子结果，就是我们想要的最终值了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 多线程线程池分析]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/03/Java-MultiThread-ThreadPool-Introduce/"/>
    <updated>2014-05-03T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/03/Java-MultiThread-ThreadPool-Introduce</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Thread">Java线程API</a></li>
  <li><a href="#ThreadPool">Java线程池API</a></li>
  <li><a href="#Executors">Java Executors类介绍</a></li>
  <li><a href="#CountDownLatch">Java CountDownLatch类介绍</a></li>
  <li><a href="#Finally">总结</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>关于Java多线程的知识，看了很多博客书籍，对理论还是比较了解的。但是，最近写一个很简单的使用线程池对列表中任务进行处理，然后返回结果列表的功能，发现理论和实际操作还是有相当大的差距。</p>

<p>首先贴出一个很简单的代码demo：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>测试示例 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-3 Time: 下午4:51</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadTest</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">executors</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="s">&quot;thread-1&quot;</span><span class="o">,</span> <span class="s">&quot;thread-2&quot;</span><span class="o">,</span> <span class="s">&quot;thread-3&quot;</span><span class="o">,</span> <span class="s">&quot;thread-4&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">executors</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                <span class="nd">@Override</span>
</span><span class="line">                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                    <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">str</span><span class="o">+</span><span class="s">&quot;test&quot;</span><span class="o">);</span>
</span><span class="line">                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">                <span class="o">}</span>
</span><span class="line">            <span class="o">});</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">results</span><span class="o">));</span>
</span><span class="line">        <span class="n">executors</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行结果如下，显然<code>results</code>的值并<strong>不是我们想要的结果</strong> ：</p>

<pre><code>[]
pool-1-thread-1
pool-1-thread-2
pool-1-thread-2
pool-1-thread-1
</code></pre>

<h3 id="section-1">1.1 线程定义</h3>

<p>来自Java 并发大家 Doug Lea 关于线程的描述（<a href="http://ifeve.com/java-concurrency-constructs/">中文版</a>）：</p>

<blockquote>
  <blockquote>
    <p>线程：其是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等）也能访问同一个进程所创建的对象资源（内存资源）。</p>
  </blockquote>
</blockquote>

<p>由于一般的系统，最小的基本调度单位是线程，因此如果一个程序中只有一个线程的话，当该线程因为远程调用或者数据库访问，或者其他大量数学计算导致IO/CPU阻塞时，就会导致整个处理性能大幅度的降低。即使没有这些阻塞，对于当前多核处理系统来讲，单线程也会导致资源的浪费。因此，多线程可以帮助我们很好地提高系统的处理能力和吞吐能力。</p>

<h2 id="a-idthreadjavaapia"><a id="Thread">Java线程API</a></h2>

<p>在Java中可以通过<code>java.lang.Thread</code>创建线程。一般，应用中包括两种类型的线程：用户线程和守护线程。当应用启动时，会创建main线程，然后main线程可以创建多个用户线程和守护线程。当所有的用户线程都终止的时候，则JVM会终止程序。
<strong>相对于用户线程而言，守护线程是为用户线程服务的，当所有的用户线程都退出的时候，守护线程就会全部退出，而不管守护线程当前的执行任务是否完成。</strong></p>

<h3 id="thread">2.1 创建Thread</h3>

<p>在java中，创建一个线程类对象很简单，有两种方式：其一，只需要继承<code>Thread</code>类，并且在子类中实现<code>run()</code>方法;其二，实现一个<code>Runnable</code>接口来创建线程。简单地demo如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>创建Thread </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-3 Time: 下午4:51</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadTest</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span> <span class="c1">// main</span>
</span><span class="line">
</span><span class="line">        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(){</span>
</span><span class="line">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
</span><span class="line">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;创建一个java线程&quot;</span><span class="o">);</span>
</span><span class="line">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span> <span class="c1">// Thread-0</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">};</span>
</span><span class="line">
</span><span class="line">        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">            <span class="nd">@Override</span>
</span><span class="line">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;创建一个java线程&quot;</span><span class="o">);</span>
</span><span class="line">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span> <span class="c1">// Thread==Runable=2</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">},</span><span class="s">&quot;Thread==Runable=2&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于上面的两种创建线程的方法，推荐使用<code>Runnable</code>来实现，因为我们知道在java 线程池<code>ExecutorService</code>可以管理和使用<code>Runnable</code>接口的线程。
当请求超过线程池设置的大小后，新的请求会排队等待执行，直到所有的线程池空闲为止，如果通过<code>Thread 子类</code>来实现线程池，则会比较复杂。</p>

<blockquote>
  <blockquote>
    <p>Tip: 在demo中使用<code>thread.run()</code>也可以得到相同的输出结果，但是，<strong>run() 的输出是由当前线程执行的，而不是新创建的线程</strong>。</p>
  </blockquote>
</blockquote>

<h3 id="section-2">2.2 创建守护线程</h3>

<p>守护线程，你可能没有注意过，但是在运行java服务的时候必然会遇到，因为一个典型的守护线程就是java垃圾回收线程。因此，当我们的java应用的所有用户线程都完成退出后，就不会再由内存垃圾产生，进而垃圾回收线程就不需要GC操作，对于只剩下守护线程时，JVM的操作就是退出，结束整个java应用环境。</p>

<p>参考网络上得一篇博文<a href="#http://blog.csdn.net/lcore/article/details/12280027">Java中的Daemon线程–守护线程</a>，给出一个deamon示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>创建守护线程 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-3 Time: 下午4:51</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadTest</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">            <span class="nd">@Override</span>
</span><span class="line">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">200</span><span class="o">);</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;创建一个守护线程Deamon&quot;</span><span class="o">);</span>
</span><span class="line">                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">},</span> <span class="s">&quot;deamon-thread-1&quot;</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="n">thread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class="line">        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;守护线程：  &quot;</span> <span class="o">+</span> <span class="n">thread</span><span class="o">.</span><span class="na">isDaemon</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="c1">// AddShutdownHook方法增加JVM停止时要做处理事件：</span>
</span><span class="line">
</span><span class="line">        <span class="c1">// 当JVM退出时，打印JVM Exit语句.</span>
</span><span class="line">        <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">addShutdownHook</span><span class="o">(</span><span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">            <span class="nd">@Override</span>
</span><span class="line">            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;JVM Exit!&quot;</span><span class="o">);</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">});</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note: 守护线程不要去做一些文件、数据库等操作，因为一旦用户线程都完成操作退出后，守护线程也需要退出，这个时候可能会导致内存溢出等风险。</p>
  </blockquote>
</blockquote>

<h2 id="a-idthreadpooljavaapia"><a id="ThreadPool">Java线程池API</a></h2>

<p>在前言中，引入的<code>ExecutorService</code>是对原生线程池<code>ThreadPoolExecutor</code>类的封装，提供了4种构造不同需求的线程池方法。首先，还是先介绍下<code>ThreadPoolExecutor</code>，API接口定义如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Java线程池API </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 根据给定的初始化参数创建一个新的 {@code ThreadPoolExecutor} 对象.</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param corePoolSize 线程池中维持的线程数，即使所有线程都是空闲状态；除非设置了{@code allowCoreThreadTimeOut}。</span>
</span><span class="line"><span class="cm">     * @param maximumPoolSize 线程池中允许的最大数量的线程。</span>
</span><span class="line"><span class="cm">     * @param keepAliveTime 当线程数量比corePoolSize的值大时，这个变量指定了在结束之前，多余的线程等待新来任务时最长的时间。</span>
</span><span class="line"><span class="cm">     * @param unit 参数{@code keepAliveTime} 的时间单位</span>
</span><span class="line"><span class="cm">     * @param workQueue 在任务执行之前，存储这些任务的队列queue。这个队列只会保存通过{@code execute}提交的{@code Runnable}任务。</span>
</span><span class="line"><span class="cm">     * @param threadFactory 当创建一个新的线程时候，使用的工厂factory对象。</span>
</span><span class="line"><span class="cm">     * @param handler 当执行任务出现阻塞的时候，使用的处理器handler。一般，可能当前的线程上线和队列容量都已经饱和的时候，</span>
</span><span class="line"><span class="cm">     *        就需要对新进来的任务执行相应处理策略。</span>
</span><span class="line"><span class="cm">     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span>
</span><span class="line"><span class="cm">     *         {@code corePoolSize &lt; 0}&lt;br&gt;</span>
</span><span class="line"><span class="cm">     *         {@code keepAliveTime &lt; 0}&lt;br&gt;</span>
</span><span class="line"><span class="cm">     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;</span>
</span><span class="line"><span class="cm">     *         {@code maximumPoolSize &lt; corePoolSize}</span>
</span><span class="line"><span class="cm">     * @throws NullPointerException if {@code workQueue}</span>
</span><span class="line"><span class="cm">     *         or {@code threadFactory} or {@code handler} is null</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line"><span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span>
</span><span class="line">                              <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span>
</span><span class="line">                              <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span>
</span><span class="line">                              <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span>
</span><span class="line">                              <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span>
</span><span class="line">                              <span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span>
</span><span class="line">                              <span class="n">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于该构造函数的参数说明，已经对应的一些注意事项可以参考 <a href="http://dlc.sun.com.edgesuite.net/jdk/jdk-api-localizations/jdk-api-zh-cn/builds/latest/html/zh_CN/api/">JDK 6 ThreadPoolExecutor API中文</a>。但是需要对其中<code>BlockingQueue&lt;Runnable&gt;</code>，<code>ThreadFactory</code>，<code>RejectedExecutionHandler</code>进行说明。</p>

<h3 id="blockingqueuerunnable-">3.1 BlockingQueue<runnable> 介绍</runnable></h3>

<p>在jdk 6中对<code>BlockingQueue</code>接口进行了详细的说明，主要几点如下：</p>

<ol>
  <li>
    <p>BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p>
  </li>
  <li>
    <p>BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。</p>
  </li>
  <li>
    <p>BlockingQueue 实质上不 支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的 end-of-stream 或 poison 对象，并根据使用者获取这些对象的时间来对它们进行解释。</p>
  </li>
  <li>
    <p>此外，BlockingQueue 可以安全地与多个生产者和多个使用者一起使用。</p>
  </li>
</ol>

<p>在java 中默认实现了4种阻塞队列，提供四种不同的阻塞队列模型：</p>

<ol>
  <li>
    <p>ArrayBlockingQueue, 底层由数组构成的有界阻塞队列。按照FIFO(先进先出)策略对元素进行排序。因此，队列的头部是当前队列中，最早进入队列的元素，而队尾则是最后进入队列的元素。并且，新来的任务元素，都插入到队列的尾部，执行任务的时候，从队列的头部取出任务元素。</p>
  </li>
  <li>
    <p>LinkedBlockingQueue, 底层由链表组成的阻塞队列。同样是按照FIFO策略对元素进行排序。和ArrayBlockingQueue不同的是，基于链表的阻塞队列可以不设置队列的大小，从而构造一个无界队列；此外，LinkedBlockingQueue的吞吐量也要高于数组的阻塞队列，不过，它会造成部分元素插入顺序的不确定性。</p>
  </li>
  <li>
    <p>SynchronousQueue，同步的阻塞队列，不存储元素，没有任何内部容量。因此，这决定了该队列模型是一个同步操作，即每一个生产者的任务消息都会直接给消费者处理，而不会先保存起来，让消费者从队列中FIFO来获取最老的消息元素。其特点就是：每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。适合传递性设计，设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。</p>
  </li>
  <li>
    <p>DelayQueue<e extends="" delayed="">，延迟的无界阻塞队列。队列中的元素只有在只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。</e></p>
  </li>
  <li>
    <p>LinkedBlockingDeque，底层有双向链表构成的阻塞队列。和LinkedBlockingQueue一样，可以做无界队列，只是因为可以从两端插入和获取元素，所以时间消耗是单向链表的一半；当然这是一种空间换时的策略。该队列需要设置队列大小来防止过度膨胀。</p>
  </li>
  <li>
    <p>PriorityBlockingQueue，一个无界的阻塞队列，它的使用和类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 Arrays.sort(pq.toArray())。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。</p>
  </li>
</ol>

<p><strong>ArrayBlockingQueue：</strong>	<br />
Note: <code>ArrayBlockingQueue</code>队列是有界的队列，所以当队列满的时候，如果还向该队列插入元素，则会导致操作被阻塞住，当然，如果从空的队列中获取元素，该操作也会被阻塞。此外，构造<code>ArrayBlockingQueue</code>队列时，有一个参数为：<code> boolean fair</code> ：如果为 true，则按照 FIFO 顺序访问插入或移除时受阻塞线程的队列；如果为 false，则访问顺序是不确定的.</p>

<p><strong>LinkedBlockingQueue：</strong><br />
Note: <code>LinkedBlockingQueue</code> 队列的吞吐量也要高于数组的阻塞队列，这主要是因为数组的特性和链表的特性决定的，链表在处理元素的offer队头元素和add队尾元素的速度要快于相应地数组操作。不过，显然这样会造成部分元素插入顺序的不确定性。</p>

<p><strong><code>DelayQueue&lt;E extends Delayed&gt;</code>：</strong><br />
Note: <code>DelayQueue&lt;E extends Delayed&gt;</code>队列中的元素需要实现<code>Delayed</code>接口，该接口只有<code>long getDelay(TimeUnit unit);</code>方法即可使用延迟阻塞队列。此外，需要注意，可能存在的时间延时，即任务元素不一定会准时执行，会有一点点的延迟。</p>

<p><strong>LinkedBlockingDeque：</strong><br />
Note: <code>LinkedBlockingDeque</code>队列用的最多的地方，就是使用<code>工作窃取算法</code>的地方。工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。如下图（参考<a href="http://ifeve.com/talk-concurrency-forkjoin/">工作窃取运行说明</a>）：</p>

<p><img src="http://kxcoder.github.io/images/2014/05/work-stealing.png" /></p>

<p><strong>PriorityBlockingQueue：</strong><br />
Note: <code>PriorityBlockingQueue</code>队列，默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。比较器可使用修改键断开主优先级值之间的联系。元素默认按照升序排列。</p>

<p>选择其中的<code>LinkedBlockingQueue</code>来简单分析下，其内部实现结构和细节：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>LinkedBlockingQueue </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">   <span class="kd">public</span> <span class="nf">LinkedBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
</span><span class="line">        <span class="n">last</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// Node是链表中一个节点，包含一个元素和下一个元素的引用</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从上面的代码可以看到，<code>LinkedBlockingQueue</code>实质上就是一个链表结构。作为阻塞的队列，在插入和移出元素的时候，肯定会加一个特殊的操作控制。在代码中，可以很清楚的看到，其消费者和生产者是通过singal来维护的，包括<code>notFull</code>和<code>notEmpty</code>两个信号变量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>LinkedBlockingQueue </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">   <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 插入指定元素到队列的尾部，如果没有空间的话，等待。</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @throws InterruptedException {@inheritDoc}</span>
</span><span class="line"><span class="cm">     * @throws NullPointerException {@inheritDoc}</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">        <span class="c1">// Note: convention in all put/take/etc is to preset local var</span>
</span><span class="line">        <span class="c1">// holding count negative to indicate failure unless set.</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class="line">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="c1">//创建插入链表的节点node</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">putLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">putLock</span><span class="o">;</span> <span class="c1">// 使用自旋锁，确保插入时线程安全</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span> <span class="c1">// 原子类型整型</span>
</span><span class="line">        <span class="n">putLock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span><span class="c1">// 可中断加锁</span>
</span><span class="line">        <span class="k">try</span> <span class="o">{</span>
</span><span class="line">            <span class="cm">/*</span>
</span><span class="line"><span class="cm">             * 在这里的count并没有使用锁来保护，这是因为这里只有递减操作，并且我</span>
</span><span class="line"><span class="cm">             * 们在容量大小更改的时候将会发送信号，这和在其他等待guard计数相似。 </span>
</span><span class="line"><span class="cm">             */</span>
</span><span class="line">            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">notFull</span><span class="o">.</span><span class="na">await</span><span class="o">();</span> <span class="c1">//等待，直到有空间插入元素</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="n">enqueue</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 插入元素</span>
</span><span class="line">            <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span> <span class="c1">//插入成功</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span>
</span><span class="line">                <span class="n">notFull</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span> <span class="c1">//释放信号，队列未满</span>
</span><span class="line">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">            <span class="n">putLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">//释放锁</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class="line">            <span class="n">signalNotEmpty</span><span class="o">();</span> <span class="c1">//发送信号，表明当前队列为空。使用全局takeLock 自旋锁来加锁设置发送信号</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="n">E</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">E</span> <span class="n">x</span><span class="o">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">takeLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">takeLock</span><span class="o">;</span>
</span><span class="line">        <span class="n">takeLock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
</span><span class="line">        <span class="k">try</span> <span class="o">{</span>
</span><span class="line">            <span class="k">while</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">notEmpty</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="n">x</span> <span class="o">=</span> <span class="n">dequeue</span><span class="o">();</span>
</span><span class="line">            <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">getAndDecrement</span><span class="o">();</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span>
</span><span class="line">                <span class="n">notEmpty</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
</span><span class="line">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">            <span class="n">takeLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span>
</span><span class="line">            <span class="n">signalNotFull</span><span class="o">();</span> <span class="c1">//发送信号告知当前队列已满，使用全局putLock 自旋锁来加锁发送信号。</span>
</span><span class="line">        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note: <code>put</code>在插入的时候，会一直等待插入成功；如果需要设置等待超时时间，需要使用<code>offer(E e, long timeout, TimeUnit unit)</code>来插入元素。
此外，<code>take</code>方法和<code>put</code>方法整体流程基本一样。</p>
  </blockquote>
</blockquote>

<h3 id="threadfactory-">3.2 ThreadFactory 介绍</h3>

<p><code>ThreadFactory</code>，线程工厂，顾名思义，就是采用工厂模式来创建线程实例。使用<code>ThreadFactory</code>方式构建线程，可以不调用<code>{@link Thread#Thread(Runnable) new Thread}</code>方法来new 一个新的线程，这样可以更方便的让应用使用定制好了的线程子类，属性等。
<code>ThreadFactory</code>接口，只有一个需要实现的方法，接口定义为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ThreadFactory </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ThreadFactory</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * Constructs a new {@code Thread}.  Implementations may also initialize</span>
</span><span class="line"><span class="cm">     * priority, name, daemon status, {@code ThreadGroup}, etc.</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param r a runnable to be executed by new thread instance</span>
</span><span class="line"><span class="cm">     * @return constructed thread, or {@code null} if the request to</span>
</span><span class="line"><span class="cm">     *         create a thread is rejected</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="n">Thread</span> <span class="nf">newThread</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们一般使用<code>Executors</code>类中提供的<code>DefaultThreadFactory</code>对接口进行了简单地实现，我们在代码中使用<code>Executors</code>来创建线程池时，会用到这个默认线程工厂类。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>ThreadFactory </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm">     * The default thread factory</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DefaultThreadFactory</span> <span class="kd">implements</span> <span class="n">ThreadFactory</span> <span class="o">{</span>
</span><span class="line">        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">poolNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AtomicInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//线程池序号</span>
</span><span class="line">        <span class="kd">private</span> <span class="kd">final</span> <span class="n">ThreadGroup</span> <span class="n">group</span><span class="o">;</span>
</span><span class="line">        <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">threadNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AtomicInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//线程所在池中的序号</span>
</span><span class="line">        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">namePrefix</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">DefaultThreadFactory</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">            <span class="n">SecurityManager</span> <span class="n">s</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">();</span>
</span><span class="line">            <span class="n">group</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">s</span><span class="o">.</span><span class="na">getThreadGroup</span><span class="o">()</span> <span class="o">:</span>
</span><span class="line">                                  <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getThreadGroup</span><span class="o">();</span> <span class="c1">// 当前线程组名</span>
</span><span class="line">            <span class="n">namePrefix</span> <span class="o">=</span> <span class="s">&quot;pool-&quot;</span> <span class="o">+</span>
</span><span class="line">                          <span class="n">poolNumber</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">()</span> <span class="o">+</span>
</span><span class="line">                         <span class="s">&quot;-thread-&quot;</span><span class="o">;</span> <span class="c1">// 线程前缀组合名</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">
</span><span class="line">        <span class="kd">public</span> <span class="n">Thread</span> <span class="nf">newThread</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span>
</span><span class="line">                                  <span class="n">namePrefix</span> <span class="o">+</span> <span class="n">threadNumber</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(),</span>
</span><span class="line">                                  <span class="mi">0</span><span class="o">);</span> <span class="c1">// 封装了new 对象的方法</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isDaemon</span><span class="o">())</span>
</span><span class="line">                <span class="n">t</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// 设置为非deamon 线程</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getPriority</span><span class="o">()</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">)</span>
</span><span class="line">                <span class="n">t</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">);</span> <span class="c1">//设置为默认优先级 </span>
</span><span class="line">            <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note: 除了<code>Executors</code>使用的默认的线程工厂类之外，还提供了一个线程工厂类：<code>PrivilegedThreadFactory</code>类。该类继承了<code>DefaultThreadFactory</code>，增加了访问控制上下文和类加载器，会检查类的调用者是否有相关权限。例如：<code>System.getSecurityManager().checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</code>以及<code>System.getSecurityManager().checkPermission(new RuntimePermission("setContextClassLoader"));</code>。</p>
  </blockquote>
</blockquote>

<h3 id="rejectedexecutionhandler-">3.3 RejectedExecutionHandler 介绍</h3>

<p><code>RejectedExecutionHandler</code>类是对线程池中不能被执行的任务，所需要采用的处理策略的指定。当 <code>executor</code> 不能接受某个任务时，可以由 <code>ThreadPoolExecutor</code> 调用<code>RejectedExecutionHandler</code>指定的处理方法。这种不能接受任务的情况，很容易就发生了，比如当超出其界限而没有更多可用的线程或队列池时，或者关闭 Executor 时。默认情况下，<code>private static final RejectedExecutionHandler defaultHandler = new AbortPolicy()</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RejectedExecutionHandler </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RejectedExecutionHandler</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * &lt;p&gt;In the absence of other alternatives, the method may throw</span>
</span><span class="line"><span class="cm">     * an unchecked {@link RejectedExecutionException}, which will be</span>
</span><span class="line"><span class="cm">     * propagated to the caller of {@code execute}.</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param r the runnable task requested to be executed</span>
</span><span class="line"><span class="cm">     * @param executor the executor attempting to execute this task</span>
</span><span class="line"><span class="cm">     * @throws RejectedExecutionException if there is no remedy</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="n">ThreadPoolExecutor</span> <span class="n">executor</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>JDK 6 提供了 4 种处理拒绝执行任务的策略：</p>

<pre><code>1. `AbortPolicy`类，该策略很简单，如果出现任务要被拒绝处理，则会抛出`RejectedExecutionException`异常，该策略为默认处理方式。

2. `CallerRunsPolicy`类，该策略会直接在`execute`方法的调用线程中运行该呗拒绝执行的任务；如果执行程序已经关闭，则直接丢弃该任务。

3. `DiscardOldestPolicy`类，该策略会在出现拒绝执行任务的时候，放弃队列中最老的未被处理的请求，然后重试execute；如果执行程序关闭，同样直接丢弃该任务。

4. `DiscardPolicy`类，该策略同样很简单，就是如果出现被拒绝执行的任务，则直接丢弃该任务。
</code></pre>

<p>比如<code>DiscardOldestPolicy</code>策略的实现，其把任务阻塞队列中得队头元素丢弃掉，然后重新执行该任务。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>RejectedExecutionHandler </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     * A handler for rejected tasks that discards the oldest unhandled</span>
</span><span class="line"><span class="cm">     * request and then retries {@code execute}, unless the executor</span>
</span><span class="line"><span class="cm">     * is shut down, in which case the task is discarded.</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DiscardOldestPolicy</span> <span class="kd">implements</span> <span class="n">RejectedExecutionHandler</span> <span class="o">{</span>
</span><span class="line">        <span class="cm">/**</span>
</span><span class="line"><span class="cm">         * Creates a {@code DiscardOldestPolicy} for the given executor.</span>
</span><span class="line"><span class="cm">         */</span>
</span><span class="line">        <span class="kd">public</span> <span class="nf">DiscardOldestPolicy</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/**</span>
</span><span class="line"><span class="cm">         * Obtains and ignores the next task that the executor</span>
</span><span class="line"><span class="cm">         * would otherwise execute, if one is immediately available,</span>
</span><span class="line"><span class="cm">         * and then retries execution of task r, unless the executor</span>
</span><span class="line"><span class="cm">         * is shut down, in which case task r is instead discarded.</span>
</span><span class="line"><span class="cm">         *</span>
</span><span class="line"><span class="cm">         * @param r the runnable task requested to be executed</span>
</span><span class="line"><span class="cm">         * @param e the executor attempting to execute this task</span>
</span><span class="line"><span class="cm">         */</span>
</span><span class="line">        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="n">ThreadPoolExecutor</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(!</span><span class="n">e</span><span class="o">.</span><span class="na">isShutdown</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">                <span class="n">e</span><span class="o">.</span><span class="na">getQueue</span><span class="o">().</span><span class="na">poll</span><span class="o">();</span> <span class="c1">// 丢弃最老的元素</span>
</span><span class="line">                <span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">r</span><span class="o">);</span> <span class="c1">//重试执行该拒绝任务</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idexecutorsjava-executorsa"><a id="Executors">Java Executors类介绍</a></h2>

<p>虽然<code>Executors</code>类只是对<code>ThreadPoolExecutor</code>的一些属性进行组合封装，但是，一般地，我们只需要使用该工具类完成创建线程池，就可以基本上满足我们的需求。
<code>Executors</code>类提供了创建4种不同属性的线程池，分别为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Java Executors类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。</span>
</span><span class="line"><span class="cm">     * 在任意点，大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，</span>
</span><span class="line"><span class="cm">     * 剩余任务将在队列中一直等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。</span>
</span><span class="line"><span class="cm">     * 在某个线程被显式地关闭{@link ExecutorService#shutdown shutdown}之前，池中的线程将一直存在。</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param nThreads the number of threads in the pool</span>
</span><span class="line"><span class="cm">     * @param threadFactory 默认使用Executors.defaultThreadFactory()线程工厂，使用抛出异常的AbortPolicy处理策略</span>
</span><span class="line"><span class="cm">     * @throws IllegalArgumentException if {@code nThreads &lt;= 0}</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">,</span> <span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span>
</span><span class="line">                                      <span class="mi">0L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
</span><span class="line">                                      <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;(),</span>
</span><span class="line">                                      <span class="n">threadFactory</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，</span>
</span><span class="line"><span class="cm">     *（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。</span>
</span><span class="line"><span class="cm">     * 并在需要时使用提供的 ThreadFactory 创建新线程。与其他等效的 newFixedThreadPool(1, threadFactory) 不同，</span>
</span><span class="line"><span class="cm">     * 可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newSingleThreadExecutor</span><span class="o">(</span><span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="k">new</span> <span class="nf">FinalizableDelegatedExecutorService</span>
</span><span class="line">            <span class="o">(</span><span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
</span><span class="line">                                    <span class="mi">0L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
</span><span class="line">                                    <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;(),</span>
</span><span class="line">                                    <span class="n">threadFactory</span><span class="o">));</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</span>
</span><span class="line"><span class="cm">     * 对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。</span>
</span><span class="line"><span class="cm">     * 如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</span>
</span><span class="line"><span class="cm">     * 因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">(</span><span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
</span><span class="line">                                      <span class="mi">60L</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
</span><span class="line">                                      <span class="k">new</span> <span class="n">SynchronousQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;(),</span>
</span><span class="line">                                      <span class="n">threadFactory</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。</span>
</span><span class="line"><span class="cm">     *（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程会代替它执行后续的任务）。</span>
</span><span class="line"><span class="cm">     * 可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</span>
</span><span class="line"><span class="cm">     * 与其他等效的 newScheduledThreadPool(1, threadFactory) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ScheduledExecutorService</span> <span class="nf">newSingleThreadScheduledExecutor</span><span class="o">(</span><span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="k">new</span> <span class="nf">DelegatedScheduledExecutorService</span>
</span><span class="line">            <span class="o">(</span><span class="k">new</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">threadFactory</span><span class="o">));</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span>
</span><span class="line"><span class="cm">     * @param corePoolSize 池中所保存的线程数，即使线程是空闲的也包括在内。</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">ScheduledExecutorService</span> <span class="nf">newScheduledThreadPool</span><span class="o">(</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span> <span class="n">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="k">new</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">,</span> <span class="n">threadFactory</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在前言部分使用了<code>Executors.newFixedThreadPool</code>来创建固定线程数的线程池。因此，我们就对这个代码的整个流程进行说明。</p>

<blockquote>
  <blockquote>
    <p>Note： 代码首先new 一个线程池，如上面代码所示，直接调用<code>ThreadPoolExecutor</code>构造函数即可。接下来就是创建任务放在线程池中执行了。</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Java Executors类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 在将来某个时间执行给定任务。可以在新线程中或者在现有池线程中执行该任务。 </span>
</span><span class="line"><span class="cm">     * 如果无法将任务提交执行，或者因为此执行程序已关闭，或者因为已达到其容量，则该任务由当前 RejectedExecutionHandler 处理。     </span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line">            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
</span><span class="line">        <span class="cm">/*</span>
</span><span class="line"><span class="cm">         * Proceed in 3 steps:</span>
</span><span class="line"><span class="cm">         *</span>
</span><span class="line"><span class="cm">         * 1. 如果比指定的corePoolSize值要少的线程在运行，则尝试着使用给定的factory来新建一个线程来运行该Runnable任务。</span>
</span><span class="line"><span class="cm">         * 这次addworker()方法的调用会自动检查运行状态和工作者worker数量，所以如果不允许增加worker则会返回false。具体实现参见下面分析。</span>
</span><span class="line"><span class="cm">         *</span>
</span><span class="line"><span class="cm">         * 2. 如果任务被插入队列，然后我们仍然需要再次检查是否我们应该增加一个线程（可能会有某一个线程在上一次检查完之后挂掉了），</span>
</span><span class="line"><span class="cm">         * 或者一进入该方法，线程池就down掉了。所以我们重复检查状态，并在如果需要，则回滚进入队列，或者开启新的线程。</span>
</span><span class="line"><span class="cm">         *</span>
</span><span class="line"><span class="cm">         * 3. 如果我们不可以插入任务到队列，则我们会尝试新加一个线程。如果增加失败，我们需要现在线程池已经关闭了或者饱和了，因此拒绝任务进入。</span>
</span><span class="line"><span class="cm">         */</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 获取线程池中有效的线程数</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="c1">//增加新的工作线程运行新的任务command</span>
</span><span class="line">                <span class="k">return</span><span class="o">;</span>
</span><span class="line">            <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">//增加新的失败，则获得有效线程数，进行再次尝试</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 如果worker正在运行任务，则把新的command放在queue中去。</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="c1">//非running状态的线程是不接受任务的，所以从队列中移除任务</span>
</span><span class="line">                <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span> <span class="c1">//并且执行拒绝操作</span>
</span><span class="line">            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">//如果当前没有running线程是因为线程池没有线程，则增加非core线程。</span>
</span><span class="line">                <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
</span><span class="line">            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span> <span class="c1">//增加线程失败，则调用对接的策略来执行拒绝该任务</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">removed</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
</span><span class="line">        <span class="n">tryTerminate</span><span class="o">();</span> <span class="c1">// In case SHUTDOWN and now empty</span>
</span><span class="line">        <span class="k">return</span> <span class="n">removed</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<blockquote>
  <blockquote>
    <p>Tips: 在代码中，获取当前程序中运行的线程数，是一个很有趣的实现。核心代码如下：</p>
  </blockquote>
</blockquote>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Java Executors类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="c1">// 主线程池控制状态 ctl，表示当前有效地线程数，此外还可以指示是否是running、shutdown等状态</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="n">RUNNING</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">COUNT_BITS</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span> <span class="c1">//Integer.SIZE = 32</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span><span class="c1">// 00011111111111111111111111111111</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * RUNNING -&gt; SHUTDOWN</span>
</span><span class="line"><span class="cm">     *    On invocation of shutdown(), perhaps implicitly in finalize()</span>
</span><span class="line"><span class="cm">     * (RUNNING or SHUTDOWN) -&gt; STOP</span>
</span><span class="line"><span class="cm">     *    On invocation of shutdownNow()</span>
</span><span class="line"><span class="cm">     * SHUTDOWN -&gt; TIDYING</span>
</span><span class="line"><span class="cm">     *    When both queue and pool are empty</span>
</span><span class="line"><span class="cm">     * STOP -&gt; TIDYING</span>
</span><span class="line"><span class="cm">     *    When pool is empty</span>
</span><span class="line"><span class="cm">     * TIDYING -&gt; TERMINATED</span>
</span><span class="line"><span class="cm">     *    When the terminated() hook method has completed</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// runState 一共5种，使用高位的3位即可完全表示</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span> <span class="c1">// 11100000000000000000000000000000</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SHUTDOWN</span>   <span class="o">=</span>  <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span> <span class="c1">// 00000000000000000000000000000000</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">STOP</span>       <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span> <span class="c1">// 00100000000000000000000000000000</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TIDYING</span>    <span class="o">=</span>  <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span> <span class="c1">// 01000000000000000000000000000000</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TERMINATED</span> <span class="o">=</span>  <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">COUNT_BITS</span><span class="o">;</span> <span class="c1">// 01100000000000000000000000000000</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// Packing and unpacking ctl</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">runStateOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span> <span class="c1">//获取线程的状态</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">workerCountOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">CAPACITY</span><span class="o">;</span> <span class="o">}</span> <span class="c1">//获取线程池的线程数</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ctlOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">rs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">wc</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">rs</span> <span class="o">|</span> <span class="n">wc</span><span class="o">;</span> <span class="o">}</span> <span class="c1">//获取某一状态的值</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note: addWorker方法，会检查如果增加一个新的worker后，是否满足当前线程池的状态和最初创建线程池设置的大小限制。这可能会创建一个新的工作线程worker来运行该任务。但是，如果线程池停止或者将要关闭，再或者使用线程工厂创建新线程失败，都将返回false。
<code>Worker</code>的继承<code>AbstractQueuedSynchronizer</code>类，该类是实现基于FIFO等待队列的阻塞锁和相关同步器的一个基本的框架，其可以依靠单个原子int值来表示状态。因此，<code>Worker</code>类其实主要目的就是为了维持线程的运行的任务的状态而存在的工作者队列。</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Java Executors类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">	<span class="cm">/**</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @param core if true use corePoolSize as bound, else</span>
</span><span class="line"><span class="cm">     * maximumPoolSize. (A boolean indicator is used here rather than a</span>
</span><span class="line"><span class="cm">     * value to ensure reads of fresh values after checking other pool</span>
</span><span class="line"><span class="cm">     * state).</span>
</span><span class="line"><span class="cm">     * @return true if successful</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line"><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">addWorker</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">firstTask</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">core</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="nl">retry:</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="c1">//运行的状态</span>
</span><span class="line">
</span><span class="line">            <span class="c1">// Check if queue empty only if necessary.非running状态</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&gt;=</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                <span class="o">!</span> <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                   <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                   <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span>
</span><span class="line">                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&gt;=</span> <span class="n">CAPACITY</span> <span class="o">||</span>
</span><span class="line">                    <span class="n">wc</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">core</span> <span class="o">?</span> <span class="n">corePoolSize</span> <span class="o">:</span> <span class="n">maximumPoolSize</span><span class="o">))</span>
</span><span class="line">                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">compareAndIncrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
</span><span class="line">                    <span class="k">break</span> <span class="n">retry</span><span class="o">;</span>
</span><span class="line">                <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// Re-read ctl</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">)</span>
</span><span class="line">                    <span class="k">continue</span> <span class="n">retry</span><span class="o">;</span>
</span><span class="line">                <span class="c1">// else CAS failed due to workerCount change; retry inner loop</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">
</span><span class="line">        <span class="kt">boolean</span> <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="n">Worker</span> <span class="n">w</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">        <span class="k">try</span> <span class="o">{</span>
</span><span class="line">            <span class="kd">final</span> <span class="n">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
</span><span class="line">            <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Worker</span><span class="o">(</span><span class="n">firstTask</span><span class="o">);</span> <span class="c1">// 新建worker，并且指定第一个任务</span>
</span><span class="line">            <span class="kd">final</span> <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class="line">                <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                    <span class="c1">// Recheck while holding lock.</span>
</span><span class="line">                    <span class="c1">// Back out on ThreadFactory failure or if</span>
</span><span class="line">                    <span class="c1">// shut down before lock acquired.</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">runStateOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">                    <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&lt;</span> <span class="n">SHUTDOWN</span> <span class="o">||</span>
</span><span class="line">                        <span class="o">(</span><span class="n">rs</span> <span class="o">==</span> <span class="n">SHUTDOWN</span> <span class="o">&amp;&amp;</span> <span class="n">firstTask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span><span class="c1">//正常的线程状态</span>
</span><span class="line">                        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span> <span class="c1">// precheck that t is startable</span>
</span><span class="line">                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalThreadStateException</span><span class="o">();</span>
</span><span class="line">                        <span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span> <span class="c1">//非core线程数时，加入到任务队列中</span>
</span><span class="line">                        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">workers</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</span><span class="line">                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">largestPoolSize</span><span class="o">)</span>
</span><span class="line">                            <span class="n">largestPoolSize</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
</span><span class="line">                        <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">workerAdded</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">//执行worker任务，详细见下面分析</span>
</span><span class="line">                    <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(!</span> <span class="n">workerStarted</span><span class="o">)</span>
</span><span class="line">                <span class="n">addWorkerFailed</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">workerStarted</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段代码比较复杂，其主要就是判断新建worker线程的环境条件，如果可以创建，则执行相应地任务<code>w = new Worker(firstTask);final Thread t = w.thread; t.start()</code>，否则返回false；<code>execute</code>方法会执行相关拒绝策略的操作。</p>

<p><strong>Worker中任务的执行</strong><br />
但是，从上面的代码中，我们看到<code>worker</code>的新建流程，并且把新任务作为参数来初始化worker，但是执行worker有一个目的只是为了测试worker实例是否创建成功。根据上面的API介绍，应该猜到其实大部分的任务到达线程池的时候，显然不是都新建一个线程来处理，而是放进<code>queue</code>中，然后执行。在<code>Worker</code>类中，封装需要执行的Runnable任务，然后其重写了run方法，内部调用<code>runWorker</code>执行任务。</p>

<blockquote>
  <blockquote>
    <p>Note:<code>runWorker</code>是<code>worker</code>主要的工作。就是重复的从queue中获取任务，然后执行他们。整个流程大概如下：  <br />
1. 我们可能会从一个初始的任务开始，当然非core数创建的<code>worker</code>则没有第一个<code>task</code>。此外
    在pool运行期间，我们使用<code>getTask</code>方法来获取任务。如果返回null的时候，则退出worker线程。
    另外，如果执行的任务会抛出异常，也会导致worker突然地完成，进而会使用<code>processWorkerExit</code>来代替该线程。  <br />
2. 在执行任何任务task之前，需要需求<code>lock</code>锁和调用<code>clearInterruptsForTaskRun</code>方法，这是为了防止在任务正在执行的时候，其他线程池中断。<br />
3. 每个任务在递交运行之前，都会调用<code>beforeExecute</code>。这个方法可能会抛出一个异常，这个异常可以导致线程down掉，而不需要执行任务task。<br />
4. 假设	<code>beforeExecute</code>顺利完成了，则开始运行task。在此期间产生的任务异常都会抛给<code>afterExecute</code>方法。分别会处理<code>RuntimeException</code>,<code>Error</code>,以及任意的<code>Throwables</code>。由于我们不可以在run方法中重新抛出<code>Throwables</code>，所以我们封装它们在即将过时的<code>Errors</code>里给线程的<code>UncaughtExceptionHandler</code>方法来处理。任何抛出来得异常也会导致线程down掉。<br />
5. 在run方法完成之后，就会调用<code>afterExecute</code>方法，这也会抛出一个异常，当然也会导致线程down掉。According to <code>JLS Sec 14.20</code>, this exception is the one that will be in effect even if <code>task.run</code> throws.</p>
  </blockquote>
</blockquote>

<p>代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Java Executors类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">runWorker</span><span class="o">(</span><span class="n">Worker</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Thread</span> <span class="n">wt</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class="line">        <span class="n">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span><span class="o">;</span>
</span><span class="line">        <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">        <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// allow interrupts。使该worker状态为0，即可以运行新的任务。</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class="line">        <span class="k">try</span> <span class="o">{</span>
</span><span class="line">            <span class="k">while</span> <span class="o">(</span><span class="n">task</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">getTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//如果task为null的时候，则从队列中获取任务</span>
</span><span class="line">                <span class="n">w</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//设置0为1，表示该worker不可用，原子操作。</span>
</span><span class="line">                <span class="c1">// If pool is stopping, ensure thread is interrupted;</span>
</span><span class="line">                <span class="c1">// if not, ensure thread is not interrupted.  This</span>
</span><span class="line">                <span class="c1">// requires a recheck in second case to deal with</span>
</span><span class="line">                <span class="c1">// shutdownNow race while clearing interrupt</span>
</span><span class="line">                <span class="k">if</span> <span class="o">((</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">STOP</span><span class="o">)</span> <span class="o">||</span>
</span><span class="line">                     <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                      <span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">STOP</span><span class="o">)))</span> <span class="o">&amp;&amp;</span>
</span><span class="line">                    <span class="o">!</span><span class="n">wt</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="c1">// 在这些情况下，需要中断当前的线程。</span>
</span><span class="line">                    <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
</span><span class="line">                <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">beforeExecute</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">task</span><span class="o">);</span>
</span><span class="line">                    <span class="n">Throwable</span> <span class="n">thrown</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">                    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span><span class="c1">//执行任务</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Error</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">thrown</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">afterExecute</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">thrown</span><span class="o">);</span><span class="c1">//执行后处理异常等信息</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">task</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">                    <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">++;</span>
</span><span class="line">                    <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span><span class="c1">//恢复当前worker可工作</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">            <span class="n">processWorkerExit</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">completedAbruptly</span><span class="o">);</span><span class="c1">//为脏worker执行清扫工作和记账工作，true时，方法会把worker的线程移出，或者替换worker等</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 从queue中获取需要执行的任务</span>
</span><span class="line"><span class="cm">     * Performs blocking or timed wait for a task, depending on</span>
</span><span class="line"><span class="cm">     * current configuration settings, or returns null if this worker</span>
</span><span class="line"><span class="cm">     * must exit because of any of:</span>
</span><span class="line"><span class="cm">     * 1. There are more than maximumPoolSize workers (due to</span>
</span><span class="line"><span class="cm">     *    a call to setMaximumPoolSize).</span>
</span><span class="line"><span class="cm">     * 2. The pool is stopped.</span>
</span><span class="line"><span class="cm">     * 3. The pool is shutdown and the queue is empty.</span>
</span><span class="line"><span class="cm">     * 4. This worker timed out waiting for a task, and timed-out</span>
</span><span class="line"><span class="cm">     *    workers are subject to termination (that is,</span>
</span><span class="line"><span class="cm">     *    {@code allowCoreThreadTimeOut || workerCount &gt; corePoolSize})</span>
</span><span class="line"><span class="cm">     *    both before and after the timed wait.</span>
</span><span class="line"><span class="cm">     *</span>
</span><span class="line"><span class="cm">     * @return task, or null if the worker must exit, in which case</span>
</span><span class="line"><span class="cm">     *         workerCount is decremented</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">private</span> <span class="n">Runnable</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">boolean</span> <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Did the last poll() time out?</span>
</span><span class="line">
</span><span class="line">        <span class="nl">retry:</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">            <span class="o">........</span>
</span><span class="line">
</span><span class="line">             <span class="k">try</span> <span class="o">{</span>
</span><span class="line">             <span class="c1">// 获取任务，超时设计判断获取逻辑</span>
</span><span class="line">                <span class="n">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="n">timed</span> <span class="o">?</span>
</span><span class="line">                    <span class="n">workQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">NANOSECONDS</span><span class="o">)</span> <span class="o">:</span>
</span><span class="line">                    <span class="n">workQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line">                    <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
</span><span class="line">                <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">retry</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idcountdownlatchjava-countdownlatcha"><a id="CountDownLatch">Java CountDownLatch类介绍</a></h2>

<p><code>CountDownLatch</code>类，是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或者多个线程一直等待。</p>

<p>用给定的<code>计数Count</code> 初始化 <code>CountDownLatch</code>。由于调用了 <code>countDown()</code> 方法，所以在当前计数到达零之前，<code>await</code> 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要<strong>重置计数，请考虑使用 <code>CyclicBarrier</code></strong>。</p>

<p><code>CountDownLatch</code> 是一个通用同步工具，它有很多用途。将计数 1 初始化的 <code>CountDownLatch</code> 用作一个简单的开/关锁存器，或入口：在通过调用 <code>countDown()</code> 的线程打开入口前，所有调用 <code>await</code> 的线程都一直在入口处等待。用 <code>N</code> 初始化的 <code>CountDownLatch</code> 可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成 N 次之前一直等待。</p>

<p><code>CountDownLatch</code> 的一个有用特性是，它不要求调用 <code>countDown</code>方法的线程等到计数到达零时才继续， 而在所有线程都能通过之前，它只是通过一个 <code>await</code>阻止任何线程继续。</p>

<p>知道<code>CountDownLatch</code>类作用，我们就可以回到前言中说到的一个简单地多线程处理问题。我在一开始的时候，直接使用线程池执行多组任务，虽然考虑了多个线程在处理完任务之后，把结果add到list里面会有线程安全问题，但是放了一个非常大的<code>错误</code>，就是线程池创建完线程，分配给完所有任务之后，主线程Main会接着往下执行，即打印结果。而这时，非常大的可能是，线程全部都在执行，并没有结果add到list中，导致list可能并不是完整地结果集，甚至有些情况下list还会为空。</p>

<p>因此，这个时候就需要<code>CountDownLatch</code>上场了。经过修改的代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>CountDownLatch </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-3 Time: 下午4:51</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadTest</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">executors</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="s">&quot;thread-11&quot;</span><span class="o">,</span> <span class="s">&quot;thread-21&quot;</span><span class="o">,</span> <span class="s">&quot;thread-31&quot;</span><span class="o">,</span> <span class="s">&quot;thread-41&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span>
</span><span class="line">        <span class="kd">final</span> <span class="n">CountDownLatch</span> <span class="n">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CountDownLatch</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">executors</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                <span class="nd">@Override</span>
</span><span class="line">                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">                    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">                        <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="s">&quot;-test&quot;</span><span class="o">);</span>
</span><span class="line">                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class="line">                    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class="line">                        <span class="n">latch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
</span><span class="line">                    <span class="o">}</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">            <span class="o">});</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">latch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">JSON</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">(</span><span class="n">results</span><span class="o">));</span>
</span><span class="line">        <span class="n">executors</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idfinallya"><a id="Finally">总结</a></h2>

<p>在最后，对于<code>CountDownLatch</code>类并没有详细的进行介绍，只是使用该类修复了前言中有问题的代码。其实在Java 7中，对于期待结果的多线程任务，推荐使用Fork &amp; Join 方式来处理。关于多线程其他方面的介绍，将在以后慢慢给出。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java日志框架slf4j API介绍及异常接口实现分析]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/02/Java-slf4j-Introduce/"/>
    <updated>2014-05-02T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/02/Java-slf4j-Introduce</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Facade">Facade设计模式简介</a></li>
  <li><a href="#Bind">slf4j绑定日志</a></li>
  <li><a href="#API">slf4j API使用</a></li>
  <li><a href="#End">后记</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>slf4j: 简洁的java日志统一接口（Simple Logging Facade for Java），顾名思义，就是一个使用Facade设计模式实现的面向java Logging框架的接口开源包。
其和java数据库连接工具包JDBC很像，在JDBC框架中，各个不同数据库连接器分别针对不同数据库系统来实现对应的连接操作，而普通程序员只需要使用统一的JDBC接口而不需要关注具体底层使用的数据库类型，或者针对不同的数据库系统写各种兼容代码。</p>

<blockquote>
  <blockquote>
    <p>Note: slf4j其实类似于适配器，但是这里不称呼适配器，是因为当底层log日志系统不支持slf4j扩展时，比如log4j，就需要在两者中间增加一个适配器层来完成slf4j调用相关日志系统的操作接口动作。例如，slf4j为log4j提高的slf4j-log412.jar类库，但是logback支持slf4J扩展，所以其不需适配层转换。</p>
  </blockquote>
</blockquote>

<!--more-->

<p>同样，slf4j 不参与具体的日志代码实现，它只是在代码编译的时候根据程序的配置来绑定具体的日志系统。这样，使用slf4j类库就可以让你的代码独立于任意一个特定的日志API。因此，如果编写一个对外开发的API活着一个同样的类库，那么为了不限制使用你类库的代码必须使用指定的日志系统，你应该使用slf4j。</p>

<p>相对于其他日志框架，slf4j日志类库的优点和推荐使用的缘由，可以参见 ImportNew 的译文【 <a href="#http://www.importnew.com/7450.html">为什么要使用SLF4J而不是Log4J</a> 】</p>

<h2 id="a-idfacadefacadea"><a id="Facade">Facade设计模式简介</a></h2>

<p>Facade模式，或者叫做外观模式，顾名思义就是封装各个底层子系统的提供的同一类功能接口，统一成一个更易操作使用的上层接口进而对外提供交互。有了这个上层封装的接口，接口调用方只需要调用这个接口，而不需要关于各个子系统的具体逻辑实现。</p>

<p>Facade设计模式的官方定义是：Facade模式定义了一个更高层的接口，使子系统更加容易使用。</p>

<p>关于Facade模式的实例，日常生活中很多这样子的例子。比如，5、1回家，可以有好几种方式：飞机、火车、长途汽车。在实际生活中，你回家的路线应该是：</p>

<pre><code>	1. 坐车去机场（火车站/长途汽车站）；
	2. 坐飞机（火车/长途汽车）到家乡；
	3. 从家乡飞机场（火车站/长途汽车站）到家里。 
</code></pre>

<p>一般来说，上面的流程是毫无问题的。但是，如果做成一个系统，你需要对外暴露3个步骤中得3个不同的接口，外界需要根据不同的交通方式选择不同的调用接口，这无疑加大了接口调研的复杂度，以及系统的复杂度。如下图所示：</p>

<p><img src="http://kxcoder.github.io/images/2014/05/facade.png" /></p>

<p>使用Facade模式，封装各个子系统的实现，对外提供3个接口：</p>

<pre><code>	1. 坐车其站点；
	2. 做主交通工具到家乡；
	3. 从家乡的站点回家里。
</code></pre>

<p>因此，接口使用方不需要知道子系统具体是什么样的业务逻辑，其主要要在配置中，或者一开始指定交通工具，就可以让facade系统来完成下面的一系列操作。这样，除了让我们的系统对外暴露接口少了，最重要的是可以让第三方以最低的成本使用我们的接口。</p>

<h2 id="a-idbindslf4ja"><a id="Bind">slf4j绑定日志</a></h2>

<h3 id="slf4j-">3.1 slf4j 设计模式说明</h3>

<p>为了说明slf4j采用的Facade模式，也就是如果只引入slf4j-api包，日志系统将无法正常使用。例如在pom.xml文件这只有：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>pom.xml依赖 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">        <span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
</span><span class="line">            <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">slf4j</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
</span><span class="line">            <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">slf4j</span><span class="o">-</span><span class="n">api</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
</span><span class="line">            <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">1.7</span><span class="o">.</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
</span><span class="line">        <span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而<a id="BindCode">测试代码</a>为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>测试示例 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-3 Time: 上午1:03</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LogTest</span> <span class="o">{</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">LogTest</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;Hello world&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;ERROR&quot;</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行上面的代码会出现提示：</p>

<pre><code>SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>

<p>而如果我们引入logback日志系统，并且配置logback.xml日志配置文件：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>pom.xml依赖 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">        <span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
</span><span class="line">            <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">ch</span><span class="o">.</span><span class="na">qos</span><span class="o">.</span><span class="na">logback</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
</span><span class="line">            <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">logback</span><span class="o">-</span><span class="n">classic</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
</span><span class="line">            <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">13</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
</span><span class="line">        <span class="o">&lt;/</span><span class="n">dependency</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来执行上面的测试代码，则会打印日志信息：</p>

<pre><code>[2014-05-03 01:27:11 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:17)] Hello world
[2014-05-03 01:27:11 [1;31mERROR[0;39m com.qunar.dubbo.LogTest.main(LogTest.java:18)] ERROR
</code></pre>

<h3 id="slf4j--1">3.2 slf4j 日志绑定流程</h3>

<p>如<a href="#BindCode">3.1</a>中的代码所示，首先调用<code>LoggerFactory.getLogger</code>的方法，这个方法会在编译的时候，绑定系统设置的真正的日志框架，如下代码所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>日志绑定流程 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">  <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * Return a logger named according to the name parameter using the statically</span>
</span><span class="line"><span class="cm">   * bound {@link ILoggerFactory} instance.</span>
</span><span class="line"><span class="cm">   *</span>
</span><span class="line"><span class="cm">   * @param name The name of the logger.</span>
</span><span class="line"><span class="cm">   * @return logger</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Logger</span> <span class="nf">getLogger</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="n">ILoggerFactory</span> <span class="n">iLoggerFactory</span> <span class="o">=</span> <span class="n">getILoggerFactory</span><span class="o">();</span> <span class="c1">// 这里先获取ILoggerFactory对象</span>
</span><span class="line">    <span class="k">return</span> <span class="n">iLoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">name</span><span class="o">);</span> <span class="c1">// 根据获取的ILoggerFactory对象，调用其对应的日志对象</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">   <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * Return the {@link ILoggerFactory} instance in use.</span>
</span><span class="line"><span class="cm">   * &lt;p/&gt;</span>
</span><span class="line"><span class="cm">   * &lt;p/&gt;</span>
</span><span class="line"><span class="cm">   * ILoggerFactory instance is bound with this class at compile time.</span>
</span><span class="line"><span class="cm">   *</span>
</span><span class="line"><span class="cm">   * @return the ILoggerFactory instance in use</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kd">static</span> <span class="n">ILoggerFactory</span> <span class="nf">getILoggerFactory</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">INITIALIZATION_STATE</span> <span class="o">==</span> <span class="n">UNINITIALIZED</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="n">INITIALIZATION_STATE</span> <span class="o">=</span> <span class="n">ONGOING_INITIALIZATION</span><span class="o">;</span>
</span><span class="line">      <span class="n">performInitialization</span><span class="o">();</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">    <span class="k">switch</span> <span class="o">(</span><span class="n">INITIALIZATION_STATE</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">case</span> <span class="nl">SUCCESSFUL_INITIALIZATION:</span>
</span><span class="line">        <span class="k">return</span> <span class="n">StaticLoggerBinder</span><span class="o">.</span><span class="na">getSingleton</span><span class="o">().</span><span class="na">getLoggerFactory</span><span class="o">();</span><span class="c1">// 这里就可以获取底层日志系统的单例对象了</span>
</span><span class="line">      <span class="k">case</span> <span class="nl">NOP_FALLBACK_INITIALIZATION:</span>
</span><span class="line">        <span class="k">return</span> <span class="n">NOP_FALLBACK_FACTORY</span><span class="o">;</span>
</span><span class="line">      <span class="k">case</span> <span class="nl">FAILED_INITIALIZATION:</span>
</span><span class="line">        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">UNSUCCESSFUL_INIT_MSG</span><span class="o">);</span>
</span><span class="line">      <span class="k">case</span> <span class="nl">ONGOING_INITIALIZATION:</span>
</span><span class="line">        <span class="c1">// support re-entrant behavior.</span>
</span><span class="line">        <span class="c1">// See also http://bugzilla.slf4j.org/show_bug.cgi?id=106</span>
</span><span class="line">        <span class="k">return</span> <span class="n">TEMP_FACTORY</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;Unreachable code&quot;</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而绑定是在<code>getILoggerFactory()</code>中调用的，在该方法的实现里，会调用<code>performInitialization()</code>，该方法调用<code>bind()</code>方法（部分代码）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>日志绑定流程 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bind</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">      <span class="n">Set</span> <span class="n">staticLoggerBinderPathSet</span> <span class="o">=</span> <span class="n">findPossibleStaticLoggerBinderPathSet</span><span class="o">();</span><span class="c1">// 寻找程序配置的日志系统集，具体见下面代码</span>
</span><span class="line">      <span class="n">reportMultipleBindingAmbiguity</span><span class="o">(</span><span class="n">staticLoggerBinderPathSet</span><span class="o">);</span><span class="c1">// 验证多于1个日志系统时，输出警告信息</span>
</span><span class="line">      <span class="c1">// the next line does the binding</span>
</span><span class="line">      <span class="n">StaticLoggerBinder</span><span class="o">.</span><span class="na">getSingleton</span><span class="o">();</span><span class="c1">// 测试是否可以获取该静态绑定类单例，可以，则置为成功状态，如下行；否则，会打出3.1中的NOP异常信息。</span>
</span><span class="line">      <span class="n">INITIALIZATION_STATE</span> <span class="o">=</span> <span class="n">SUCCESSFUL_INITIALIZATION</span><span class="o">;</span>
</span><span class="line">      <span class="n">reportActualBinding</span><span class="o">(</span><span class="n">staticLoggerBinderPathSet</span><span class="o">);</span><span class="c1">// 绑定，打印绑定具体日志系统的日志</span>
</span><span class="line">      <span class="n">emitSubstituteLoggerWarning</span><span class="o">();</span><span class="c1">// 提交给临时日志factory 打印的日志，不是重点</span>
</span><span class="line">    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoClassDefFoundError</span> <span class="n">ncde</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="n">String</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">ncde</span><span class="o">.</span><span class="na">getMessage</span><span class="o">();</span>
</span><span class="line">      <span class="k">if</span> <span class="o">(</span><span class="n">messageContainsOrgSlf4jImplStaticLoggerBinder</span><span class="o">(</span><span class="n">msg</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">        <span class="n">INITIALIZATION_STATE</span> <span class="o">=</span> <span class="n">NOP_FALLBACK_INITIALIZATION</span><span class="o">;</span>
</span><span class="line">        <span class="n">Util</span><span class="o">.</span><span class="na">report</span><span class="o">(</span><span class="s">&quot;Failed to load class \&quot;org.slf4j.impl.StaticLoggerBinder\&quot;.&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">Util</span><span class="o">.</span><span class="na">report</span><span class="o">(</span><span class="s">&quot;Defaulting to no-operation (NOP) logger implementation&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">Util</span><span class="o">.</span><span class="na">report</span><span class="o">(</span><span class="s">&quot;See &quot;</span> <span class="o">+</span> <span class="n">NO_STATICLOGGERBINDER_URL</span>
</span><span class="line">                <span class="o">+</span> <span class="s">&quot; for further details.&quot;</span><span class="o">);</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面看看，slf4j是如何获取系统中指定的真正底层日志系统：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>日志绑定流程 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="c1">// We need to use the name of the StaticLoggerBinder class, but we can&#39;t reference</span>
</span><span class="line">  <span class="c1">// the class itself.</span>
</span><span class="line">  <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">STATIC_LOGGER_BINDER_PATH</span> <span class="o">=</span> <span class="s">&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Set</span> <span class="nf">findPossibleStaticLoggerBinderPathSet</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="c1">// use Set instead of list in order to deal with  bug #138</span>
</span><span class="line">    <span class="c1">// LinkedHashSet appropriate here because it preserves insertion order during iteration</span>
</span><span class="line">    <span class="n">Set</span> <span class="n">staticLoggerBinderPathSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">LinkedHashSet</span><span class="o">();</span>
</span><span class="line">    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">      <span class="n">ClassLoader</span> <span class="n">loggerFactoryClassLoader</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">class</span>
</span><span class="line">              <span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
</span><span class="line">      <span class="n">Enumeration</span> <span class="n">paths</span><span class="o">;</span>
</span><span class="line">      <span class="k">if</span> <span class="o">(</span><span class="n">loggerFactoryClassLoader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">paths</span> <span class="o">=</span> <span class="n">ClassLoader</span><span class="o">.</span><span class="na">getSystemResources</span><span class="o">(</span><span class="n">STATIC_LOGGER_BINDER_PATH</span><span class="o">);</span>
</span><span class="line">      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">        <span class="n">paths</span> <span class="o">=</span> <span class="n">loggerFactoryClassLoader</span>
</span><span class="line">                <span class="o">.</span><span class="na">getResources</span><span class="o">(</span><span class="n">STATIC_LOGGER_BINDER_PATH</span><span class="o">);</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">      <span class="k">while</span> <span class="o">(</span><span class="n">paths</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">        <span class="n">URL</span> <span class="n">path</span> <span class="o">=</span> <span class="o">(</span><span class="n">URL</span><span class="o">)</span> <span class="n">paths</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
</span><span class="line">        <span class="n">staticLoggerBinderPathSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">ioe</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="n">Util</span><span class="o">.</span><span class="na">report</span><span class="o">(</span><span class="s">&quot;Error getting resources from path&quot;</span><span class="o">,</span> <span class="n">ioe</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">staticLoggerBinderPathSet</span><span class="o">;</span>
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>slf4j在适配器层或者在兼容slf4j扩展的log-api 中会有一个<code>org/slf4j/impl/StaticLoggerBinder.class</code>类，这样就获取了系统中真正的日志系统。然后获取该日志的单例，打印相关的日志信息就可以了。比如，打印slf4j的<code>log.info</code>则调用logback中<code>Logger.info()</code>方法来打印日志信息。</p>

<h2 id="a-idapislf4j-apia"><a id="API">slf4j API使用</a></h2>

<p>slf4j的打印日志基本一致，主要分为：<code>trace</code>,<code>debug</code>,<code>info</code>,<code>warn</code>,<code>error</code>,比log4j少了<code>fatal</code>级别日志。由于每个级别对于的API方法级别一致，因此，这里选用info来介绍不同输入参数的API使用。</p>

<blockquote>
  <blockquote>
    <p>Tip: SLF4J 认为 ERROR 与 FATAL 并没有实质上的差别，所以拿掉了 FATAL 等级，只剩下其他五种。</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>API使用 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"> <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * 纯字符串形式的日志</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">  <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * 指定一个参数和位置格式的info级别的日志输出形式。这个形式避免了多个object对象的创建。</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">format</span><span class="o">,</span> <span class="n">Object</span> <span class="n">arg</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">  <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * 指定2个参数和对于位置格式的info级别的日志输出。</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">format</span><span class="o">,</span> <span class="n">Object</span> <span class="n">arg1</span><span class="o">,</span> <span class="n">Object</span> <span class="n">arg2</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">  <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * 根据指定的参数和日志格式来输出info级别的日志信息。</span>
</span><span class="line"><span class="cm">   * 但是，需要指出这种形式虽然避免的字符串拼接的成本，但是它会私底下创建一个`Object[]`对象在调用info方法之前，即使info级别的日志不打印。</span>
</span><span class="line"><span class="cm">   * 因此，如果不是必须3个及以上参数的话，推荐使用两个参数和一个参数的info日志。</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">format</span><span class="o">,</span> <span class="n">Object</span><span class="o">...</span> <span class="n">arguments</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">  <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * 打印抛出异常信息的info 级别日志</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">t</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此外，需要介绍的是在slf4j中还提供了含有Marker对象的日记输出API接口。Marker是常常被用来丰富log状态的对象。遵守slf4j的日志系统实现，决定了信息怎样在使用的Marker之间传达。实际上，很多遵守规范的日志系统会忽视掉marker数据,所以，我们不介绍Marker相关API接口。</p>

<p>下面给出各个接口的使用示例代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>API使用 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
</span><span class="line"><span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * @author: ketao Date: 14-5-3 Time: 上午1:03</span>
</span><span class="line"><span class="cm"> * @version: \$Id$</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LogTest</span> <span class="o">{</span>
</span><span class="line">    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">LogTest</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;纯字符串信息的info级别日志&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;一个参数:{}的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;agr1&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;二个参数:agrs1:{};agrs2:{}的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="c1">// 下面两种方式都可以，一般使用上面一种就可以了</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;三个参数:agrs1:{};agrs2:{};args3:{} 的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span> <span class="s">&quot;args3&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;三个参数:agrs1:{};agrs2:{};args3:{} 的info级别日志&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span> <span class="s">&quot;args3&quot;</span> <span class="o">});</span>
</span><span class="line">
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;======================异常相关====================================&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="c1">// 测试异常相关日志</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;抛出异常,e:&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">));</span>
</span><span class="line">
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;二个参数:agrs1:{};agrs2:{}的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">));</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;二个参数:agrs1:{};agrs2:{}的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">));</span>
</span><span class="line">
</span><span class="line">        <span class="c1">// 下面两种方式都可以，一般使用上面一种就可以了</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;三个参数:agrs1:{};agrs2:{};args3:{} 的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">));</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;三个参数:agrs1:{};agrs2:{};args3:{} 的info级别日志&quot;</span><span class="o">,</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span> <span class="s">&quot;agrs3&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span>
</span><span class="line">                <span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">));</span>
</span><span class="line">
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;三个参数:agrs1:{};agrs2:{};args3:{} 的info级别日志&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span> <span class="s">&quot;args3&quot;</span><span class="o">,</span>
</span><span class="line">                <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">)</span> <span class="o">});</span>
</span><span class="line">        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;三个参数:agrs1:{};agrs2:{};args3:{} 的info级别日志&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="s">&quot;args1&quot;</span><span class="o">,</span> <span class="s">&quot;args2&quot;</span><span class="o">,</span>
</span><span class="line">                <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">&quot;测试抛出IO异常信息&quot;</span><span class="o">)</span> <span class="o">});</span>
</span><span class="line">
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对应输出日志信息：</p>

<pre><code>[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:20)] 纯字符串信息的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:21)] 一个参数:agr1的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:22)] 二个参数:agrs1:args1;agrs2:args2的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:24)] 三个参数:agrs1:args1;agrs2:args2;args3:args3 的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:25)] 三个参数:agrs1:args1;agrs2:args2;args3:args3 的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:27)] ======================异常相关====================================
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:29)] 抛出异常,e:
java.io.IOException: 测试抛出IO异常信息
	at com.qunar.dubbo.LogTest.main(LogTest.java:29) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na]
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:31)] 二个参数:agrs1:args1;agrs2:java.io.IOException: 测试抛出IO异常信息的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:32)] 二个参数:agrs1:args1;agrs2:args2的info级别日志
java.io.IOException: 测试抛出IO异常信息
	at com.qunar.dubbo.LogTest.main(LogTest.java:32) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na]
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:35)] 三个参数:agrs1:args1;agrs2:args2;args3:java.io.IOException: 测试抛出IO异常信息 的info级别日志
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:36)] 三个参数:agrs1:args1;agrs2:args2;args3:agrs3 的info级别日志
java.io.IOException: 测试抛出IO异常信息
	at com.qunar.dubbo.LogTest.main(LogTest.java:36) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na]
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:38)] 三个参数:agrs1:args1;agrs2:args2;args3:args3 的info级别日志
java.io.IOException: 测试抛出IO异常信息
	at com.qunar.dubbo.LogTest.main(LogTest.java:38) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) [idea_rt.jar:na]
[2014-05-03 03:47:14 [34mINFO [0;39m com.qunar.dubbo.LogTest.main(LogTest.java:39)] 三个参数:agrs1:args1;agrs2:args2;args3:java.io.IOException: 测试抛出IO异常信息 的info级别日志
</code></pre>

<blockquote>
  <blockquote>
    <p>Note: 从代码调用可以看到，throwable 异常信息单独作为一个参数输入，因此，如果把异常信息作为<code>{}</code>占位符中的字符串，则会调用其对应toString方法，而无法打印异常堆栈信息。可以看看下面的截取源码：</p>
  </blockquote>
</blockquote>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>API使用 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="n">filterAndLog_0_Or3Plus</span><span class="o">(</span><span class="n">FQCN</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">Level</span><span class="o">.</span><span class="na">INFO</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 当日志的参数string 大于1，并且包含 Throwable类型参数，则调用下面的方法</span>
</span><span class="line">  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">info</span><span class="o">(</span><span class="n">String</span> <span class="n">format</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">argArray</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="n">filterAndLog_0_Or3Plus</span><span class="o">(</span><span class="n">FQCN</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">Level</span><span class="o">.</span><span class="na">INFO</span><span class="o">,</span> <span class="n">format</span><span class="o">,</span> <span class="n">argArray</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">   <span class="cm">/**</span>
</span><span class="line"><span class="cm">   * 在logback代码中，作者表明如果不使用Object[]创建参数数组对象，则会减少20 纳秒的时间开销。</span>
</span><span class="line"><span class="cm">   */</span>
</span><span class="line">  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">filterAndLog_0_Or3Plus</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">localFQCN</span><span class="o">,</span>
</span><span class="line">      <span class="kd">final</span> <span class="n">Marker</span> <span class="n">marker</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Level</span> <span class="n">level</span><span class="o">,</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">msg</span><span class="o">,</span>
</span><span class="line">      <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">params</span><span class="o">,</span> <span class="kd">final</span> <span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="kd">final</span> <span class="n">FilterReply</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">loggerContext</span>
</span><span class="line">        <span class="o">.</span><span class="na">getTurboFilterChainDecision_0_3OrMore</span><span class="o">(</span><span class="n">marker</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="n">level</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span>
</span><span class="line">            <span class="n">params</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">decision</span> <span class="o">==</span> <span class="n">FilterReply</span><span class="o">.</span><span class="na">NEUTRAL</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">if</span> <span class="o">(</span><span class="n">effectiveLevelInt</span> <span class="o">&gt;</span> <span class="n">level</span><span class="o">.</span><span class="na">levelInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span><span class="o">;</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">decision</span> <span class="o">==</span> <span class="n">FilterReply</span><span class="o">.</span><span class="na">DENY</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">buildLoggingEventAndAppend</span><span class="o">(</span><span class="n">localFQCN</span><span class="o">,</span> <span class="n">marker</span><span class="o">,</span> <span class="n">level</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">params</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span><span class="c1">// 在这个方法里面，会LoggingEvent方法构架日志信息，而对于Throwable非空时，则会创建一个ThrowableProxy对象，具体代码见下面。</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="c1">// 下面的代码，是对日志中的异常打印信息。显然，在messageFormat里面，使用String来处理，是无法获得这么丰富的异常堆栈信息的。</span>
</span><span class="line">  <span class="kd">public</span> <span class="nf">ThrowableProxy</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">throwable</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">throwable</span> <span class="o">=</span> <span class="n">throwable</span><span class="o">;</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">className</span> <span class="o">=</span> <span class="n">throwable</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">message</span> <span class="o">=</span> <span class="n">throwable</span><span class="o">.</span><span class="na">getMessage</span><span class="o">();</span>
</span><span class="line">    <span class="k">this</span><span class="o">.</span><span class="na">stackTraceElementProxyArray</span> <span class="o">=</span> <span class="n">ThrowableProxyUtil</span><span class="o">.</span><span class="na">steArrayToStepArray</span><span class="o">(</span><span class="n">throwable</span>
</span><span class="line">        <span class="o">.</span><span class="na">getStackTrace</span><span class="o">());</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//下面构建详细异常的堆栈信息，这也就是我们在代码输出时，看到的一大坨at... 输出错误代码位置等。</span>
</span><span class="line">    <span class="n">Throwable</span> <span class="n">nested</span> <span class="o">=</span> <span class="n">throwable</span><span class="o">.</span><span class="na">getCause</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">nested</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">this</span><span class="o">.</span><span class="na">cause</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ThrowableProxy</span><span class="o">(</span><span class="n">nested</span><span class="o">);</span>
</span><span class="line">      <span class="k">this</span><span class="o">.</span><span class="na">cause</span><span class="o">.</span><span class="na">commonFrames</span> <span class="o">=</span> <span class="n">ThrowableProxyUtil</span>
</span><span class="line">          <span class="o">.</span><span class="na">findNumberOfCommonFrames</span><span class="o">(</span><span class="n">nested</span><span class="o">.</span><span class="na">getStackTrace</span><span class="o">(),</span>
</span><span class="line">              <span class="n">stackTraceElementProxyArray</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">    <span class="k">if</span><span class="o">(</span><span class="n">GET_SUPPRESSED_METHOD</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="c1">// this will only execute on Java 7</span>
</span><span class="line">      <span class="k">try</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">GET_SUPPRESSED_METHOD</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">throwable</span><span class="o">);</span>
</span><span class="line">        <span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="n">Throwable</span><span class="o">[])</span> <span class="o">{</span>
</span><span class="line">          <span class="n">Throwable</span><span class="o">[]</span> <span class="n">throwableSuppressed</span> <span class="o">=</span> <span class="o">(</span><span class="n">Throwable</span><span class="o">[])</span> <span class="n">obj</span><span class="o">;</span>
</span><span class="line">          <span class="k">if</span><span class="o">(</span><span class="n">throwableSuppressed</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">suppressed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThrowableProxy</span><span class="o">[</span><span class="n">throwableSuppressed</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span><span class="line">            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">throwableSuppressed</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class="line">              <span class="k">this</span><span class="o">.</span><span class="na">suppressed</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ThrowableProxy</span><span class="o">(</span><span class="n">throwableSuppressed</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class="line">              <span class="k">this</span><span class="o">.</span><span class="na">suppressed</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">commonFrames</span> <span class="o">=</span> <span class="n">ThrowableProxyUtil</span>
</span><span class="line">                  <span class="o">.</span><span class="na">findNumberOfCommonFrames</span><span class="o">(</span><span class="n">throwableSuppressed</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getStackTrace</span><span class="o">(),</span>
</span><span class="line">                      <span class="n">stackTraceElementProxyArray</span><span class="o">);</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">          <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="c1">// ignore</span>
</span><span class="line">      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="c1">// ignore</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note: 上面代码只是一般的步骤，对于调用<code>Object[]</code>形式的方法，则<code>ThrowableProxy</code>之前，还会对<code>Object[]</code>中的元素进行过滤处理，提取出最后一个元素判断是不是 <code>Throwable</code>类型的对象。代码参考如下：</p>
  </blockquote>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>API使用 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"> <span class="kd">final</span> <span class="kd">public</span> <span class="kd">static</span> <span class="n">FormattingTuple</span> <span class="nf">format</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">messagePattern</span><span class="o">,</span>
</span><span class="line">      <span class="n">Object</span> <span class="n">arg1</span><span class="o">,</span> <span class="n">Object</span> <span class="n">arg2</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="k">return</span> <span class="nf">arrayFormat</span><span class="o">(</span><span class="n">messagePattern</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="n">arg1</span><span class="o">,</span> <span class="n">arg2</span> <span class="o">});</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">	<span class="c1">//这方法会对输入参数进行特殊处理和过滤</span>
</span><span class="line"> <span class="kd">final</span> <span class="kd">public</span> <span class="kd">static</span> <span class="n">FormattingTuple</span> <span class="nf">arrayFormat</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">messagePattern</span><span class="o">,</span>
</span><span class="line">      <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">argArray</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">Throwable</span> <span class="n">throwableCandidate</span> <span class="o">=</span> <span class="n">getThrowableCandidate</span><span class="o">(</span><span class="n">argArray</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">	<span class="o">......</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span> <span class="o">(</span><span class="n">L</span> <span class="o">&lt;</span> <span class="n">argArray</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span> <span class="k">new</span> <span class="nf">FormattingTuple</span><span class="o">(</span><span class="n">sbuf</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">argArray</span><span class="o">,</span> <span class="n">throwableCandidate</span><span class="o">);</span><span class="c1">// 如果元素中有Throwable类型，则size会减少，因此，对应的Throwale参数位置为 置提取出来的异常对象</span>
</span><span class="line">    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span> <span class="k">new</span> <span class="nf">FormattingTuple</span><span class="o">(</span><span class="n">sbuf</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">argArray</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">
</span><span class="line">  <span class="kd">static</span> <span class="kd">final</span> <span class="n">Throwable</span> <span class="nf">getThrowableCandidate</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">argArray</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">argArray</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">argArray</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">final</span> <span class="n">Object</span> <span class="n">lastEntry</span> <span class="o">=</span> <span class="n">argArray</span><span class="o">[</span><span class="n">argArray</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">lastEntry</span> <span class="k">instanceof</span> <span class="n">Throwable</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">      <span class="k">return</span> <span class="o">(</span><span class="n">Throwable</span><span class="o">)</span> <span class="n">lastEntry</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idenda"><a id="End">后记</a></h2>
<p>slf4j的日志，打印抛出异常的信息时，如果只需要message，则需要在log api接口中的String 里面对应位置添加<code>{}</code>符号；否则，如果想要打印全量<font color="red">异常栈信息，则**不能也不可以**</font>在string字符串中添加<code>{}</code>，不然会大失所望。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intelij IDEA 远程调试Tomcat服务]]></title>
    <link href="http://kxcoder.github.io/blog/2014/04/29/Intelij-IDEA-Remote-Debug-Tomcat-App/"/>
    <updated>2014-04-29T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/04/29/Intelij-IDEA-Remote-Debug-Tomcat-App</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Server">线上服务配置</a></li>
  <li><a href="#Client">IDE本地配置</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>在很多情况下，我们在本地启动调试一些服务；或者说外部调用开发测试环境某些服务时，需要直接调试定位问题代码点；
这些问题都会让我们需要可以在本地IDE上面调试本地代码来查看线上情况。最近和其他业务部门联调的时候，
了解到原来真的可以debug本地代码同步控制线上运行流程。下面，记录一下具体的操作配置步骤。</p>

<!--more-->

<h2 id="a-idservera"><a id="Server">线上服务配置</a></h2>

<p>目前线上的整个tomcat的服务脚本配置：</p>

<ol>
  <li>一台机器上放一个全局脚本，比如放置在<code>/home/tomcat/bin</code>目录下；</li>
  <li>机器上的每一个tomcat实例目录里面都会有一些基本的设置，比如tomcat的<code>conf</code>目录，以及<code>startenv.sh</code>文件，</li>
  <li><code>startenv.sh</code>文件目前的配置为：</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>线上服务配置 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nb">export </span><span class="nv">TOMCAT_USER</span><span class="o">=</span><span class="s2">&quot;tomcat&quot;</span>
</span><span class="line"><span class="nb">export </span><span class="nv">JAVA_OPTS</span><span class="o">=</span><span class="s2">&quot;-Xms512m -Xmx1024m -XX:NewSize=256m -XX:PermSize=256m -server -XX:+DisableExplicitGC -Dqunar.logs=$CATALINA_BASE/logs -Dqunar.cache=$CATALINA_BASE/cache -verbose:gc -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:$CATALINA_BASE/logs/gc.log&quot;</span>
</span><span class="line">chown -R tomcat:tomcat <span class="nv">$CATALINA_BASE</span>/logs
</span><span class="line">chown -R tomcat:tomcat <span class="nv">$CATALINA_BASE</span>/cache
</span><span class="line">chown -R tomcat:tomcat <span class="nv">$CATALINA_BASE</span>/conf
</span><span class="line">chown -R tomcat:tomcat <span class="nv">$CATALINA_BASE</span>/work
</span><span class="line">chown -R tomcat:tomcat <span class="nv">$CATALINA_BASE</span>/temp
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因此，为了方便，我们只需要增加debug相关配置在JAVA_OPTS就可以了：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>线上JAVA_OPTS服务配置 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">-server -Xdebug -Xnoagent -Djava.compiler<span class="o">=</span>NONE -Xrunjdwp:transport<span class="o">=</span>dt_socket,address<span class="o">=</span>9999,server<span class="o">=</span>y,suspend<span class="o">=</span>n
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Note: 这里的端口指定为9999，你也可以自己指定。主要是JVM绑定端口使用。</p>
  </blockquote>
</blockquote>

<pre><code>-Xdebug					|启用调试特性
-Xrunjdwp				|启用JDWP实现，它包含若干子选项：
transport=dt_socket		|JPDA front-end和back-end之间的传输方法。dt_socket表示使用套接字传输。
address=9999			|JVM在9999端口上监听请求。
server=y				|y表示启动的JVM是被调试者。如果为n，则表示启动的JVM是调试器。
suspend=y				|y表示启动的JVM会暂停等待，直到调试器连接上。
suspend=y这个选项很重要。如果你想从Tomcat启动的一开始就进行调试，那么就必须设置suspend=y。
</code></pre>

<p>接下来，重新启动线上服务，就可以在本地调试相关app了。</p>

<h2 id="a-idclientidea"><a id="Client">IDE本地配置</a></h2>

<p>本地使用的IDE是Intelij IDEA 开发工具，具体操作步骤为：</p>

<p>1、 在IDEA上面新建一个 tomcat remote server服务：
<img src="http://kxcoder.github.io/images/2014/04/newremote.png" />
» Note:图片中的端口是web服务的端口号，而不是JVM监听绑定的端口号。</p>

<p><img src="http://kxcoder.github.io/images/2014/04/debugaddress.png" />
» Note:图片中的端口是JVM监听绑定的端口号，即我们在服务端设置绑定的address值。</p>

<p>2、 接下来就可以通过debug来启动本地服务，当出现下面字样时，表示连接成功，可以debug了。</p>

<pre><code>client：  
	Connected to server
	Connected to the target VM, address: 'l-hds2.h.dev.cn6.qunar.com:9999', transport: 'socket'  
server：  
	Listening for transport dt_socket at address: 9999  
	Listening for transport dt_socket at address: 9999  
	Listening for transport dt_socket at address: 9999
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql主从复制原理]]></title>
    <link href="http://kxcoder.github.io/blog/2014/04/19/Mysql-Master-Slave-Copy/"/>
    <updated>2014-04-19T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/04/19/Mysql-Master-Slave-Copy</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Begin">Mysql复制介绍</a></li>
  <li><a href="#Framework">复制常用框架</a></li>
  <li><a href="#Master">Master服务器启动mysql</a></li>
  <li><a href="#Slave">Slave服务器配置</a></li>
</ol>

<h2 id="a-idbeginmysqla"><a id="Begin">Mysql复制介绍</a></h2>
<p>分为同步复制和异步复制，实际复制架构中大部分为异步复制。</p>

<p>复制的基本过程如下：</p>

<ol>
  <li>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
  <li>Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程根据请求信息读取制定日志指定位置之后的日志信息，返回给Slave 的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置；</li>
  <li>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；</li>
  <li>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</li>
</ol>

<!--more-->

<p>Mysql为了解决这个风险并提高复制的性能，将Slave端的复制改为两个进程来完成。提出这个改进方案的人是Yahoo!的一位工程师“Jeremy Zawodny”。这样既解决了性能问题，又缩短了异步的延时时间，同时也减少了可能存在的数据丢失量。当然，即使是换成了现在这样两个线程处理以后，同样也还是存在slave数据延时以及数据丢失的可能性的，毕竟这个复制是异步的。只要数据的更改不是在一个事物中，这些问题都是会存在的。如果要完全避免这些问题，就只能用mysql的cluster来解决了。不过mysql的cluster是内存数据库的解决方案，需要将所有数据都load到内存中，这样就对内存的要求就非常大了，对于一般的应用来说可实施性不是太大。</p>

<h2 id="a-idframeworka"><a id="Framework">复制常用框架</a></h2>
<p>Mysql复制环境90%以上都是一个Master带一个或者多个Slave的架构模式，主要用于读压力比较大的应用的数据库端廉价扩展解决方案。因为只要master和slave的压力不是太大（尤其是slave端压力）的话，异步复制的延时一般都很少很少。尤其是自slave端的复制方式改成两个进程处理之后，更是减小了slave端的延时。而带来的效益是，对于数据实时性要求不是特别的敏感度的应用，只需要通过廉价的pc server来扩展slave的数量，将读压力分散到多台slave的机器上面，即可解决数据库端的读压力瓶颈。这在很大程度上解决了目前很多中小型网站的数据库压力瓶颈问题，甚至有些大型网站也在使用类似方案解决数据库瓶颈。</p>

<p><strong>Mysql主从复制配置过程：</strong><br />
环境：  <br />
<code>
master: 192.168.0.3  
Slave: 192.168.0.4  
Mysql版本为5.0.67（编译安装）  
database: eric
</code></p>

<h2 id="a-idmastermastermysqla"><a id="Master">Master服务器启动mysql</a></h2>
<ol>
  <li>mysql –uroot –proot</li>
  <li>创建一个有复制权限的用户，只限slave远程连接访问.
mysql&gt;grant replication slave on <em>.</em> to replication@192.168.0.4 identified by ‘password’;
mysql&gt;flush privileges;</li>
  <li>mysql&gt;flush tables with read lock; #锁定master服务器所有表的写入。</li>
  <li>重新打开一终端，备份要复制的数据库。<br />
Var]#tar zcvf eric.tar.gz eric/    //eric所在路径/opt/mysql/var/eric/即一个库。<br />
]#scp eric.tar.gz 192.168.0.4:/opt/mysql/var/    //将主服务器的库传到slave相应路径下。</li>
  <li>
    <p>返回上一终端。<br />
Mysql&gt;show master status;</p>

    <p>+——————+———-+————–+——————+<br />
 | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |<br />
 +——————+———-+————–+——————+<br />
 | mysql-bin.000014 |       98 | eric         |                  |<br />
 +——————+———-+————–+——————+</p>
  </li>
</ol>

<p>1 row in set (0.01 sec)<br />
其中mysql-bin.000014和98二个值将是slave与master的同步点。<br />
6. 给数据库解锁（当备份完成后） mysql&gt;unlock tables;<br />
7. 编辑mysql的配置文件。Vim /etc/my.cnf 设置这三个参数，没有的添加，有的直接更改即可。<br />
log-bin=mysql-bin<br />
server-id  = 1<br />
binlog-do-db=eric<br />
保存退出。</p>

<h2 id="a-idslaveslavea"><a id="Slave">Slave服务器配置</a></h2>
<ol>
  <li>注意顺序，先重启master-à 然后是slave.</li>
  <li>Slave服务器重启后，登录mysql
 mysql&gt; stop slave;</li>
</ol>

<p>Query OK, 0 rows affected (0.00 sec)</p>

<pre><code>mysql&gt; change master to  
-&gt; master_host='192.168.0.3',  
-&gt; master_user='replication',  
-&gt; master_password='password',  
-&gt; master_log_file='mysql-bin.000014',  
-&gt; master_log_pos=98;   Query OK, 0 rows affected (0.02 sec)  
</code></pre>

<p>mysql&gt; start slave;</p>

<pre><code>Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p>mysql&gt; show slave status\G;</p>

<pre><code>*************************** 1. row ***************************
Slave_IO_State: Waiting for master to send event  
Master_Host: 192.168.0.3  
Master_User: replication  
Master_Port: 3306  
Connect_Retry: 60  
Master_Log_File: mysql-bin.000014  
Read_Master_Log_Pos: 98  
Relay_Log_File: alan-relay-bin.000002  
Relay_Log_Pos: 235  
Relay_Master_Log_File: mysql-bin.000014  
Slave_IO_Running: Yes  
Slave_SQL_Running: Yes  
Replicate_Do_DB:  
Replicate_Ignore_DB:  
Replicate_Do_Table:  
Replicate_Ignore_Table:  
Replicate_Wild_Do_Table:  
Replicate_Wild_Ignore_Table:  
Last_Errno: 0  
Last_Error:  
Skip_Counter: 0  
Exec_Master_Log_Pos: 98  
Relay_Log_Space: 235  
Until_Condition: None  
Until_Log_File:  
Until_Log_Pos: 0  
Master_SSL_Allowed: No  
Master_SSL_CA_File:  
Master_SSL_CA_Path:  
Master_SSL_Cert:  
Master_SSL_Cipher:  
Master_SSL_Key:  
Seconds_Behind_Master: 0  
1 row in set (0.01 sec)  
</code></pre>

<p>ERROR: No query specified<br />
当这个参数都为yes时，证明主从复制成功</p>

<pre><code>Slave_IO_Running: Yes      Slave_SQL_Running: Yes
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Java编程风格指南]]></title>
    <link href="http://kxcoder.github.io/blog/2014/04/16/google-java-style/"/>
    <updated>2014-04-16T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/04/16/google-java-style</id>
    <content type="html"><![CDATA[<p>说明：来自互联网，如有版权问题，请告知本人将其撤下。</p>

<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#SFBasic">源文件基础</a></li>
  <li><a href="#SFStruct">源文件结构</a></li>
  <li><a href="#Format">格式</a></li>
  <li><a href="#Naming">命名约定</a></li>
  <li><a href="#Practice">编程实践</a></li>
  <li><a href="#Javadoc">Javadoc</a></li>
  <li><a href="#End">后记</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，
我们才认为它符合Google的Java编程风格。</p>

<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，
同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，
对于那些不是明确强制要求的，我们尽量避免提供意见。</p>

<!--more-->

<h3 id="section-1">1.1 术语说明</h3>

<p>在本文档中，除非另有说明：</p>

<ol>
  <li>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)</li>
  <li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li>
</ol>

<p>其他的术语说明会偶尔在后面的文档出现。</p>

<h3 id="section-2">1.2 指南说明</h3>

<p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。
示例中的格式选择不应该被强制定为规则。</p>

<h2 id="a-idsfbasica"><a id="SFBasic">源文件基础</a></h2>

<h3 id="section-3">2.1 文件名</h3>

<p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>

<h3 id="utf-8">2.2 文件编码：UTF-8</h3>

<p>源文件编码格式为UTF-8。</p>

<h3 id="section-4">2.3 特殊字符</h3>

<h4 id="section-5">2.3.1 空白字符</h4>

<p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>

<ol>
  <li>所有其它字符串中的空白字符都要进行转义。</li>
  <li>制表符不用于缩进。</li>
</ol>

<h4 id="section-6">2.3.2 特殊转义序列</h4>

<p>对于具有特殊<a href="http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">转义序列</a>的任何字符(\b, \t, \n, \f, \r, ", '及\)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或Unicode(比如<code>\u000a</code>)转义。</p>

<h4 id="ascii">2.3.3 非ASCII字符</h4>

<p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>

<blockquote>
  <blockquote>
    <p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
  </blockquote>
</blockquote>

<p>例如：</p>

<pre><code>String unitAbbrev = "μs";                                 | 赞，即使没有注释也非常清晰
String unitAbbrev = "\u03bcs"; // "μs"                    | 允许，但没有理由要这样做
String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错
String unitAbbrev = "\u03bcs";                            | 很糟，读者根本看不出这是什么
return '\ufeff' + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释
</code></pre>

<blockquote>
  <blockquote>
    <p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，
你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p>
  </blockquote>
</blockquote>

<h2 id="a-idsfstructa"><a id="SFStruct">源文件结构</a></h2>

<p>一个源文件包含(按顺序地)：</p>

<ol>
  <li>许可证或版权信息(如有需要)</li>
  <li>package语句</li>
  <li>import语句</li>
  <li>一个顶级类(<strong>只有一个</strong>)</li>
</ol>

<p>以上每个部分之间用一个空行隔开。</p>

<h3 id="section-7">3.1 许可证或版权信息</h3>

<p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>

<h3 id="package">3.2 package语句</h3>

<p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>

<h3 id="import">3.3 import语句</h3>

<h4 id="import-1">3.3.1 import不要使用通配符</h4>

<p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>

<h4 id="section-8">3.3.2 不要换行</h4>

<p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p>

<h4 id="section-9">3.3.3 顺序和间距</h4>

<p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>

<ol>
  <li>所有的静态导入独立成组</li>
  <li><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)</li>
  <li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li>
  <li><code>java</code> imports</li>
  <li><code>javax</code> imports</li>
</ol>

<p>组内不空行，按字典序排列。</p>

<h3 id="section-10">3.4 类声明</h3>

<h4 id="section-11">3.4.1 只有一个顶级类声明</h4>

<p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>

<p>例外：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>

<h4 id="section-12">3.4.2 类成员顺序</h4>

<p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。
最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，
新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>

<h5 id="section-13">3.4.2.1 重载：永不分离</h5>

<p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>

<h2 id="a-idformata"><a id="Format">格式</a></h2>

<p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>

<h3 id="section-14">4.1 大括号</h3>

<h4 id="section-15">4.1.1 使用大括号(即使是可选的)</h4>

<p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>

<h4 id="k--r-">4.1.2 非空块：K &amp; R 风格</h4>

<p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格
(<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a>):</p>

<ul>
  <li>左大括号前不换行</li>
  <li>左大括号后换行</li>
  <li>右大括号前换行</li>
  <li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>

<p>示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>非空块：K &amp; R 风格 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">return</span> <span class="k">new</span> <span class="nf">MyClass</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">  <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">      <span class="k">try</span> <span class="o">{</span>
</span><span class="line">        <span class="n">something</span><span class="o">();</span>
</span><span class="line">      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ProblemException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">recover</span><span class="o">();</span>
</span><span class="line">      <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line"><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.8.1节给出了enum类的一些例外。</p>

<h4 id="section-16">4.1.3 空块：可以用简洁版本</h4>

<p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally)
，即使大括号内没内容，右大括号也要换行。</p>

<p>示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>空块：可以用简洁版本 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kt">void</span> <span class="nf">doNothing</span><span class="o">()</span> <span class="o">{}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-17">4.2 块缩进：2个空格</h3>

<p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>

<h3 id="section-18">4.3 一行一个语句</h3>

<p>每个语句后要换行。</p>

<h3 id="section-19">4.4 列限制：80或100</h3>

<p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>

<p>例外：</p>

<ol>
  <li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li>
  <li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。</li>
  <li>注释中那些可能被剪切并粘贴到shell中的命令行。</li>
</ol>

<h3 id="section-20">4.5 自动换行</h3>

<p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>

<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>

<blockquote>
  <blockquote>
    <p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
  </blockquote>
</blockquote>

<h4 id="section-21">4.5.1 从哪里断开</h4>

<p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>

<ol>
  <li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。
这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
  <li>如果在<code>赋值运算符</code>处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>
  <li>方法名或构造函数名与左括号留在同一行。</li>
  <li>逗号(,)与其前面的内容留在同一行。</li>
</ol>

<h4 id="section-22">4.5.2 自动换行时缩进至少+4个空格</h4>

<p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>

<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>

<p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>

<h3 id="section-23">4.6 空白</h3>

<h4 id="section-24">4.6.1 垂直空白</h4>

<p>以下情况需要使用一个空行：</p>

<ol>
  <li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。
    <ul>
      <li><strong>例外</strong>：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
    </ul>
  </li>
  <li>在函数体内，语句的逻辑分组间使用空行。</li>
  <li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
  <li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
</ol>

<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>

<h4 id="section-25">4.6.2 水平空白</h4>

<p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>

<ol>
  <li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li>
  <li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>
  <li>在任何左大括号前(<code>{</code>)，两个例外：
    <ul>
      <li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
      <li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>
    </ul>
  </li>
  <li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：
    <ul>
      <li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
      <li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
      <li><code>foreach</code>语句中的分号。</li>
    </ul>
  </li>
  <li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
  <li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
  <li>类型和变量之间：List<string> list。</string></li>
  <li>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</li>
</ol>

<blockquote>
  <blockquote>
    <p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
  </blockquote>
</blockquote>

<h4 id="section-26">4.6.3 水平对齐：不做要求</h4>

<p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>

<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>

<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>水平对齐：不做要求 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// this is fine</span>
</span><span class="line"><span class="kd">private</span> <span class="n">Color</span> <span class="n">color</span><span class="o">;</span> <span class="c1">// this too</span>
</span><span class="line">
</span><span class="line"><span class="kd">private</span> <span class="kt">int</span>   <span class="n">x</span><span class="o">;</span>      <span class="c1">// permitted, but future edits</span>
</span><span class="line"><span class="kd">private</span> <span class="n">Color</span> <span class="n">color</span><span class="o">;</span>  <span class="c1">// may leave it unaligned</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。
这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，
这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
  </blockquote>
</blockquote>

<h3 id="section-27">4.7 用小括号来限定组：推荐</h3>

<p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。
我们没有理由假设读者能记住整个Java运算符优先级表。</p>

<h3 id="section-28">4.8 具体结构</h3>

<h4 id="section-29">4.8.1 枚举类</h4>

<p>枚举常量间用逗号隔开，换行可选。</p>

<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>枚举类 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">private</span> <span class="kd">enum</span> <span class="n">Suit</span> <span class="o">{</span> <span class="n">CLUBS</span><span class="o">,</span> <span class="n">HEARTS</span><span class="o">,</span> <span class="n">SPADES</span><span class="o">,</span> <span class="n">DIAMONDS</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>

<h4 id="section-30">4.8.2 变量声明</h4>

<h5 id="section-31">4.8.2.1 每次只声明一个变量</h5>

<p>不要使用组合声明，比如<code>int a, b;</code>。</p>

<h5 id="section-32">4.8.2.2 需要时才声明，并尽快进行初始化</h5>

<p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。
局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>

<h4 id="section-33">4.8.3 数组</h4>

<h5 id="section-34">4.8.3.1 数组初始化：可写成块状结构</h5>

<p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>数组初始化：可写成块状结构</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
</span><span class="line">  <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
</span><span class="line">  <span class="mi">0</span><span class="o">,</span>
</span><span class="line">  <span class="mi">1</span><span class="o">,</span>
</span><span class="line">  <span class="mi">2</span><span class="o">,</span>
</span><span class="line">  <span class="mi">3</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
</span><span class="line">  <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
</span><span class="line">  <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span>
</span><span class="line">    <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="c">4.8.3.2 非C风格的数组声明</h5>

<p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p>

<h4 id="switch">4.8.4 switch语句</h4>

<p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>

<h5 id="section-35">4.8.4.1 缩进</h5>

<p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>

<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>

<h5 id="fall-through">4.8.4.2 Fall-through：注释</h5>

<p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，
任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Fall-through：注释</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">switch</span> <span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class="line">  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class="line">    <span class="n">prepareOneOrTwo</span><span class="o">();</span>
</span><span class="line">    <span class="c1">// fall through</span>
</span><span class="line">  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class="line">    <span class="n">handleOneTwoOrThree</span><span class="o">();</span>
</span><span class="line">    <span class="k">break</span><span class="o">;</span>
</span><span class="line">  <span class="k">default</span><span class="o">:</span>
</span><span class="line">    <span class="n">handleLargeNumber</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="default">4.8.4.3 default的情况要写出来</h5>

<p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>

<h4 id="annotations">4.8.5 注解(Annotations)</h4>

<p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注解 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="nd">@Override</span>
</span><span class="line"><span class="nd">@Nullable</span>
</span><span class="line"><span class="kd">public</span> <span class="n">String</span> <span class="nf">getNameIfPresent</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注解 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注解 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="nd">@Partial</span> <span class="nd">@Mock</span> <span class="n">DataLoader</span> <span class="n">loader</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>参数和局部变量注解没有特定规则。</p>

<h4 id="section-36">4.8.6 注释</h4>

<h5 id="section-37">4.8.6.1 块注释风格</h5>

<p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... */</code>风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<code>*</code>开始，
并且与前一行的<code>*</code>对齐。以下示例注释都是OK的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>注释 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/*</span>
</span><span class="line"><span class="cm"> * This is          // And so           /* Or you can</span>
</span><span class="line"><span class="cm"> * okay.            // is this.          * even do this. */</span>
</span><span class="line"> <span class="o">*/</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>

<blockquote>
  <blockquote>
    <p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p>
  </blockquote>
</blockquote>

<h4 id="modifiers">4.8.7 Modifiers</h4>

<p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Modifiers </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">protected</span> <span class="kd">private</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kd">synchronized</span> <span class="kd">native</span> <span class="kd">strictfp</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="a-idnaminga"><a id="Naming">命名约定</a></h2>

<h3 id="section-38">5.1 对所有标识符都通用的规则</h3>

<p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p>

<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>

<h3 id="section-39">5.2 标识符类型的规则</h3>

<h4 id="section-40">5.2.1 包名</h4>

<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>

<h4 id="section-41">5.2.2 类名</h4>

<p>类名都以<code>UpperCamelCase</code>风格编写。</p>

<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>

<p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>

<h4 id="section-42">5.2.3 方法名</h4>

<p>方法名都以<code>lowerCamelCase</code>风格编写。</p>

<p>方法名通常是动词或动词短语。</p>

<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。
并不存在唯一正确的方式来命名测试方法。</p>

<h4 id="section-43">5.2.4 常量名</h4>

<p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>

<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，
考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。
只是永远不<code>打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>常量名 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="c1">// Constants</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NUMBER</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">NAMES</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;Ed&quot;</span><span class="o">,</span> <span class="s">&quot;Ann&quot;</span><span class="o">);</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Joiner</span> <span class="n">COMMA_JOINER</span> <span class="o">=</span> <span class="n">Joiner</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="sc">&#39;,&#39;</span><span class="o">);</span>  <span class="c1">// because Joiner is immutable</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">SomeMutableType</span><span class="o">[]</span> <span class="n">EMPTY_ARRAY</span> <span class="o">=</span> <span class="o">{};</span>
</span><span class="line"><span class="kd">enum</span> <span class="n">SomeEnum</span> <span class="o">{</span> <span class="n">ENUM_CONSTANT</span> <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Not constants</span>
</span><span class="line"><span class="kd">static</span> <span class="n">String</span> <span class="n">nonFinal</span> <span class="o">=</span> <span class="s">&quot;non-final&quot;</span><span class="o">;</span>
</span><span class="line"><span class="kd">final</span> <span class="n">String</span> <span class="n">nonStatic</span> <span class="o">=</span> <span class="s">&quot;non-static&quot;</span><span class="o">;</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">mutableCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">ImmutableSet</span><span class="o">&lt;</span><span class="n">SomeMutableType</span><span class="o">&gt;</span> <span class="n">mutableElements</span> <span class="o">=</span> <span class="n">ImmutableSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">mutable</span><span class="o">);</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">MyClass</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class="line"><span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">nonEmptyArray</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;these&quot;</span><span class="o">,</span> <span class="s">&quot;can&quot;</span><span class="o">,</span> <span class="s">&quot;change&quot;</span><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这些名字通常是名词或名词短语。</p>

<h4 id="section-44">5.2.5 非常量字段名</h4>

<p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>

<p>这些名字通常是名词或名词短语。</p>

<h4 id="section-45">5.2.6 参数名</h4>

<p>参数名以<code>lowerCamelCase</code>风格编写。</p>

<p>参数应该避免用单个字符命名。</p>

<h4 id="section-46">5.2.7 局部变量名</h4>

<p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>

<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>

<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>

<h4 id="section-47">5.2.8 类型变量名</h4>

<p>类型变量可用以下两种风格之一进行命名：</p>

<ul>
  <li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
  <li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>

<h3 id="camelcase">5.3 驼峰式命名法(CamelCase)</h3>

<p><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。
有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>

<p>名字从<code>散文形式</code>(prose form)开始:</p>

<ol>
  <li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
  <li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。
    <ul>
      <li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。
 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
    </ul>
  </li>
  <li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：
    <ul>
      <li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
      <li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
    </ul>
  </li>
  <li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>

<p>示例：</p>

<pre><code>Prose form                Correct               Incorrect
------------------------------------------------------------------
"XML HTTP request"        XmlHttpRequest        XMLHTTPRequest
"new customer ID"         newCustomerId         newCustomerID
"inner stopwatch"         innerStopwatch        innerStopWatch
"supports IPv6 on iOS?"   supportsIpv6OnIos     supportsIPv6OnIOS
"YouTube importer"        YouTubeImporter
                          YoutubeImporter*
</code></pre>

<p>加星号处表示可以，但不推荐。</p>

<blockquote>
  <blockquote>
    <p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>
  </blockquote>
</blockquote>

<h2 id="a-idpracticea"><a id="Practice">编程实践</a></h2>

<h3 id="override">6.1 @Override：能用则用</h3>

<p>只要是合法的，就把<code>@Override</code>注解给用上。</p>

<h3 id="section-48">6.2 捕获的异常：不能忽视</h3>

<p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>

<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>捕获的异常 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">try</span> <span class="o">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
</span><span class="line">  <span class="k">return</span> <span class="nf">handleNumericResponse</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NumberFormatException</span> <span class="n">ok</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">  <span class="c1">// it&#39;s not numeric; that&#39;s fine, just continue</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line"><span class="k">return</span> <span class="nf">handleTextResponse</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>例外</strong>：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，
因此在这里就没有必要加注释。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>捕获的异常 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="k">try</span> <span class="o">{</span>
</span><span class="line">  <span class="n">emptyStack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
</span><span class="line">  <span class="n">fail</span><span class="o">();</span>
</span><span class="line"><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchElementException</span> <span class="n">expected</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-49">6.3 静态成员：使用类进行调用</h3>

<p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>静态成员 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">Foo</span> <span class="n">aFoo</span> <span class="o">=</span> <span class="o">...;</span>
</span><span class="line"><span class="n">Foo</span><span class="o">.</span><span class="na">aStaticMethod</span><span class="o">();</span> <span class="c1">// good</span>
</span><span class="line"><span class="n">aFoo</span><span class="o">.</span><span class="na">aStaticMethod</span><span class="o">();</span> <span class="c1">// bad</span>
</span><span class="line"><span class="n">somethingThatYieldsAFoo</span><span class="o">().</span><span class="na">aStaticMethod</span><span class="o">();</span> <span class="c1">// very bad</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="finalizers-">6.4 Finalizers: 禁用</h3>

<p>极少会去重载<code>Object.finalize</code>。</p>

<blockquote>
  <blockquote>
    <p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href="http://books.google.com/books?isbn=8131726592">Effective Java</a>
第7条款：“Avoid Finalizers”，然后不要使用它。</p>
  </blockquote>
</blockquote>

<h2 id="a-idjavadocjavadoca"><a id="Javadoc">Javadoc</a></h2>

<h3 id="section-50">7.1 格式</h3>

<h4 id="section-51">7.1.1 一般形式</h4>

<p>Javadoc块的基本格式如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Javadoc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm"> * Multiple lines of Javadoc text are written here,</span>
</span><span class="line"><span class="cm"> * wrapped normally...</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">method</span><span class="o">(</span><span class="n">String</span> <span class="n">p1</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者是以下单行形式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Javadoc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/** An especially short bit of Javadoc. */</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>

<h4 id="section-52">7.1.2 段落</h4>

<p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。
除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p>

<h4 id="javadoc">7.1.3 Javadoc标记</h4>

<p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。
当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>

<h3 id="section-53">7.2 摘要片段</h3>

<p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>

<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头,
它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>

<blockquote>
  <blockquote>
    <p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>
  </blockquote>
</blockquote>

<h3 id="javadoc-1">7.3 哪里需要使用Javadoc</h3>

<p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>

<h4 id="section-54">7.3.1 例外：不言自明的方法</h4>

<p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>

<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>

<blockquote>
  <blockquote>
    <p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，
就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>
  </blockquote>
</blockquote>

<h4 id="section-55">7.3.2 例外：重载</h4>

<p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>

<h4 id="javadoc-2">7.3.3 可选的Javadoc</h4>

<p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，
那么这个注释应该写成Javadoc，这样更统一更友好。</p>

<h2 id="a-idenda"><a id="End">后记</a></h2>

<p>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html">Google Java Style</a>，
译者<a href="http://weibo.com/hawstein">@Hawstein</a>。</p>
]]></content>
  </entry>
  
</feed>
