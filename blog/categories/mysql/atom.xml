<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mysql | 柯小小西の小水滴]]></title>
  <link href="http://kxcoder.github.io/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://kxcoder.github.io/"/>
  <updated>2015-10-07T02:06:36+08:00</updated>
  <id>http://kxcoder.github.io/</id>
  <author>
    <name><![CDATA[柯小小西]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[线上Mysql死锁问题分析]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/28/Online-Mysql-Deadlock-Analyse/"/>
    <updated>2014-05-28T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/28/Online-Mysql-Deadlock-Analyse</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Problem">死锁问题定位</a></li>
  <li><a href="#Reproduce">问题重现</a></li>
  <li><a href="#Solution">解决方法</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>前段时间，查看线上<code>Tomcat</code>日志，发现多台服务器出现<code>Mysql</code>死锁情况，虽然死锁问题没有影响到正常业务，但是毕竟数据库死锁还是得需要好好分析原因去修复和开发过程中极力需要避免的。服务器上<code>Mysql死锁</code>日志如下：</p>

<!--more-->

<p><img src="http://kxcoder.github.io/images/2014/05/deadlock-log.png" /></p>

<p>由于我们的服务使用了连接池，所以接着让 DBA 查询下<code>Mysql</code>的数据库操作日志信息，如下图所示：</p>

<p><img src="http://kxcoder.github.io/images/2014/05/mysql-log.png" /></p>

<h2 id="a-idproblema"><a id="Problem">死锁问题定位</a></h2>

<p>查看了建表语句，其实很简单：</p>

<p><figure class='code'><figcaption><span>建表SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='mysql'><span class='line'><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">room_rate_plan_id</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="p">(</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">id</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="kt">bigint</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">unsigned</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">value</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="p">,</span>
</span><span class='line'>  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">id</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="p">),</span>
</span><span class='line'>  <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">uniq_value</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">value</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">USING</span> <span class="n">BTREE</span>
</span><span class='line'><span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="kp">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">175663</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>而使用的地方只在一个类代码里用过，使用的方式是<code>select for update</code>，并且该查询事务中包含着，如果不存在，则<code>INSERT INTO room_rate_plan_id (value) VALUES(?)</code>语句，那么，接着就得了解<code>select for update</code>来确定是不是这里导致数据库死锁现象。主要有两篇博客：</p>

<ul>
  <li>
    <p><a href="http://stackoverflow.com/questions/5432370/mysql-innodb-dead-lock-on-select-with-exclusive-lock-for-update">http://stackoverflow.com/questions/5432370/mysql-innodb-dead-lock-on-select-with-exclusive-lock-for-update</a></p>
  </li>
  <li>
    <p><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-deadlocks.html">http://dev.mysql.com/doc/refman/5.0/en/innodb-deadlocks.html</a></p>
  </li>
</ul>

<p><code>SELECT FOR UPDATE</code> 是<code>SELECT</code> 的升级版，其在查询时会上锁。一般地，当数据量特别大时，可能有大量的并发，这些并发会导致在<code>SELECT</code>时，状态已经变更了，因此需要上锁。InnoDB默认是Row-Level Lock，因此<code>SELECT FOR UPDATE</code>只有在<code>WHERE</code> 判断条件内明确指定主键时，才会执行<code>Row lock</code>，否则会<code>lock</code>整个数据表。当有多个请求同时加上<code>for update</code>的意向锁时，如果<code>select</code>没有时，第一个请求会接着<code>insert</code>而去尝试获取排它锁，B锁保持等待；而第二个请求也<code>select</code>为空时，并且刚好第二条请求插入的数据和第一个请求一样的时候，则会导致死锁。</p>

<h2 id="a-idreproducea"><a id="Reproduce">问题重现</a></h2>

<blockquote>
  <blockquote>
    <p>执行下面语句：</p>
  </blockquote>
</blockquote>

<ul>
  <li><code>session 1</code>执行：</li>
</ul>

<p><figure class='code'><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='mysql'><span class='line'><span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class='line'><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">qunar</span><span class="p">.</span><span class="n">room_rate_plan_id</span> <span class="k">where</span> <span class="n">value</span><span class="o">=</span><span class="err">’</span><span class="n">elong_abcd</span><span class="err">’</span><span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
  <li><code>session 2</code>执行：</li>
</ul>

<p><figure class='code'><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='mysql'><span class='line'><span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class='line'><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">qunar</span><span class="p">.</span><span class="n">room_rate_plan_id</span> <span class="k">where</span> <span class="n">value</span><span class="o">=</span><span class="err">’</span><span class="n">elong_abcd</span><span class="err">’</span><span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
  <li>在<code>session 1</code>上执行 <code>insert</code> 语句：</li>
</ul>

<p><figure class='code'><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='mysql'><span class='line'><span class="k">insert</span> <span class="k">into</span> <span class="n">qunar</span><span class="p">.</span><span class="nf">room_rate_plan_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="err">‘</span><span class="n">elong_abcd</span><span class="err">’</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<blockquote>
  <blockquote>
    <p>执行上面的操作，则在<code>Mysql</code>控制台上打出死锁日志信息：</p>
  </blockquote>
</blockquote>

<p><img src="http://kxcoder.github.io/assets/img/2014/5/28/mysql-dead.png" /></p>

<h2 id="a-idsolutiona"><a id="Solution">解决方法</a></h2>

<ol>
  <li>
    <p>采用官网上指出的方法：If you are using locking reads (SELECT … FOR UPDATE or SELECT … LOCK IN SHARE MODE), try using <code>a lower isolation level</code> such as READ COMMITTED.</p>
  </li>
  <li>
    <p>由于<code>select for update</code>只有不存在记录时才会去加一个意向锁，所以可以采用下面方法解决：select—&gt; if(id) is empty —&gt;insert;如果不为空，则select for update。不过这样就多了一次select了。</p>
  </li>
  <li>
    <p>使用<code>insert ignore</code> 插入，然后select ，由于是value是<code>unique key</code>，所以select可以获取正确id，并且还可以不需要添加事务。可能会多一次insert ignore。这种方法之所以这样子，是因为在业务中没有update操作，只有insert和select，并且value是唯一的，这样子就可以只采用select而不需要采用select for update，并且还可以不需要事务，提供效率。</p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>如果采用第3中解决方案，不会出现死锁问题，但是当锁一直被占用时，会出现等待超时，当然，如果不使用事务，则肯定不会有锁的问题了。</p>
  </blockquote>
</blockquote>

<pre><code>* session 1：
    <figure class='code'><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='mysql'><span class='line'>	<span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class='line'>	<span class="k">INSERT</span> <span class="k">IGNORE</span> 	<span class="k">INTO</span> <span class="nf">room_rate_plan_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;elong_abcs&#39;</span><span class="p">);</span>
</span><span class='line'>	<span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="n">room_rate_plan_id</span> <span class="k">where</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;elong_abcs&#39;</span><span class="p">;</span>
</span><span class='line'>	
</span></code></pre></td></tr></table></div></figure>

* session 2：
    <figure class='code'><figcaption><span>执行SQL语句</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='mysql'><span class='line'>	<span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</span><span class='line'>	<span class="k">INSERT</span> <span class="k">IGNORE</span> 	<span class="k">INTO</span> <span class="nf">room_rate_plan_id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;elong_abcs&#39;</span><span class="p">);</span>
</span><span class='line'>	
</span></code></pre></td></tr></table></div></figure>
* 出现超时异常信息：
</code></pre>

<p><img src="http://kxcoder.github.io/images/2014/05/timeout.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql主从复制原理]]></title>
    <link href="http://kxcoder.github.io/blog/2014/04/19/Mysql-Master-Slave-Copy/"/>
    <updated>2014-04-19T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/04/19/Mysql-Master-Slave-Copy</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Begin">Mysql复制介绍</a></li>
  <li><a href="#Framework">复制常用框架</a></li>
  <li><a href="#Master">Master服务器启动mysql</a></li>
  <li><a href="#Slave">Slave服务器配置</a></li>
</ol>

<h2 id="a-idbeginmysqla"><a id="Begin">Mysql复制介绍</a></h2>
<p>分为同步复制和异步复制，实际复制架构中大部分为异步复制。</p>

<p>复制的基本过程如下：</p>

<ol>
  <li>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</li>
  <li>Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程根据请求信息读取制定日志指定位置之后的日志信息，返回给Slave 的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置；</li>
  <li>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；</li>
  <li>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</li>
</ol>

<!--more-->

<p>Mysql为了解决这个风险并提高复制的性能，将Slave端的复制改为两个进程来完成。提出这个改进方案的人是Yahoo!的一位工程师“Jeremy Zawodny”。这样既解决了性能问题，又缩短了异步的延时时间，同时也减少了可能存在的数据丢失量。当然，即使是换成了现在这样两个线程处理以后，同样也还是存在slave数据延时以及数据丢失的可能性的，毕竟这个复制是异步的。只要数据的更改不是在一个事物中，这些问题都是会存在的。如果要完全避免这些问题，就只能用mysql的cluster来解决了。不过mysql的cluster是内存数据库的解决方案，需要将所有数据都load到内存中，这样就对内存的要求就非常大了，对于一般的应用来说可实施性不是太大。</p>

<h2 id="a-idframeworka"><a id="Framework">复制常用框架</a></h2>
<p>Mysql复制环境90%以上都是一个Master带一个或者多个Slave的架构模式，主要用于读压力比较大的应用的数据库端廉价扩展解决方案。因为只要master和slave的压力不是太大（尤其是slave端压力）的话，异步复制的延时一般都很少很少。尤其是自slave端的复制方式改成两个进程处理之后，更是减小了slave端的延时。而带来的效益是，对于数据实时性要求不是特别的敏感度的应用，只需要通过廉价的pc server来扩展slave的数量，将读压力分散到多台slave的机器上面，即可解决数据库端的读压力瓶颈。这在很大程度上解决了目前很多中小型网站的数据库压力瓶颈问题，甚至有些大型网站也在使用类似方案解决数据库瓶颈。</p>

<p><strong>Mysql主从复制配置过程：</strong><br />
环境：  <br />
<code>
master: 192.168.0.3  
Slave: 192.168.0.4  
Mysql版本为5.0.67（编译安装）  
database: eric
</code></p>

<h2 id="a-idmastermastermysqla"><a id="Master">Master服务器启动mysql</a></h2>
<ol>
  <li>mysql –uroot –proot</li>
  <li>创建一个有复制权限的用户，只限slave远程连接访问.
mysql&gt;grant replication slave on <em>.</em> to replication@192.168.0.4 identified by ‘password’;
mysql&gt;flush privileges;</li>
  <li>mysql&gt;flush tables with read lock; #锁定master服务器所有表的写入。</li>
  <li>重新打开一终端，备份要复制的数据库。<br />
Var]#tar zcvf eric.tar.gz eric/    //eric所在路径/opt/mysql/var/eric/即一个库。<br />
]#scp eric.tar.gz 192.168.0.4:/opt/mysql/var/    //将主服务器的库传到slave相应路径下。</li>
  <li>
    <p>返回上一终端。<br />
Mysql&gt;show master status;</p>

    <p>+——————+———-+————–+——————+<br />
 | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |<br />
 +——————+———-+————–+——————+<br />
 | mysql-bin.000014 |       98 | eric         |                  |<br />
 +——————+———-+————–+——————+</p>
  </li>
</ol>

<p>1 row in set (0.01 sec)<br />
其中mysql-bin.000014和98二个值将是slave与master的同步点。<br />
6. 给数据库解锁（当备份完成后） mysql&gt;unlock tables;<br />
7. 编辑mysql的配置文件。Vim /etc/my.cnf 设置这三个参数，没有的添加，有的直接更改即可。<br />
log-bin=mysql-bin<br />
server-id  = 1<br />
binlog-do-db=eric<br />
保存退出。</p>

<h2 id="a-idslaveslavea"><a id="Slave">Slave服务器配置</a></h2>
<ol>
  <li>注意顺序，先重启master-à 然后是slave.</li>
  <li>Slave服务器重启后，登录mysql
 mysql&gt; stop slave;</li>
</ol>

<p>Query OK, 0 rows affected (0.00 sec)</p>

<pre><code>mysql&gt; change master to  
-&gt; master_host='192.168.0.3',  
-&gt; master_user='replication',  
-&gt; master_password='password',  
-&gt; master_log_file='mysql-bin.000014',  
-&gt; master_log_pos=98;   Query OK, 0 rows affected (0.02 sec)  
</code></pre>

<p>mysql&gt; start slave;</p>

<pre><code>Query OK, 0 rows affected (0.00 sec)
</code></pre>

<p>mysql&gt; show slave status\G;</p>

<pre><code>*************************** 1. row ***************************
Slave_IO_State: Waiting for master to send event  
Master_Host: 192.168.0.3  
Master_User: replication  
Master_Port: 3306  
Connect_Retry: 60  
Master_Log_File: mysql-bin.000014  
Read_Master_Log_Pos: 98  
Relay_Log_File: alan-relay-bin.000002  
Relay_Log_Pos: 235  
Relay_Master_Log_File: mysql-bin.000014  
Slave_IO_Running: Yes  
Slave_SQL_Running: Yes  
Replicate_Do_DB:  
Replicate_Ignore_DB:  
Replicate_Do_Table:  
Replicate_Ignore_Table:  
Replicate_Wild_Do_Table:  
Replicate_Wild_Ignore_Table:  
Last_Errno: 0  
Last_Error:  
Skip_Counter: 0  
Exec_Master_Log_Pos: 98  
Relay_Log_Space: 235  
Until_Condition: None  
Until_Log_File:  
Until_Log_Pos: 0  
Master_SSL_Allowed: No  
Master_SSL_CA_File:  
Master_SSL_CA_Path:  
Master_SSL_Cert:  
Master_SSL_Cipher:  
Master_SSL_Key:  
Seconds_Behind_Master: 0  
1 row in set (0.01 sec)  
</code></pre>

<p>ERROR: No query specified<br />
当这个参数都为yes时，证明主从复制成功</p>

<pre><code>Slave_IO_Running: Yes      Slave_SQL_Running: Yes
</code></pre>

]]></content>
  </entry>
  
</feed>
