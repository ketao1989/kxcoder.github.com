<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | 柯小小西の小水滴]]></title>
  <link href="http://kxcoder.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://kxcoder.github.io/"/>
  <updated>2015-10-07T14:43:56+08:00</updated>
  <id>http://kxcoder.github.io/</id>
  <author>
    <name><![CDATA[柯小小西]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nginx 反向代理配置和工作原理]]></title>
    <link href="http://kxcoder.github.io/blog/2015/08/30/nginx-proxy-configure-and-sduty/"/>
    <updated>2015-08-30T18:52:03+08:00</updated>
    <id>http://kxcoder.github.io/blog/2015/08/30/nginx-proxy-configure-and-sduty</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Proxy">Nginx 反向代理配置说明</a></li>
  <li><a href="#ProcessRequest">Nginx 架构和请求处理流程</a></li>
  <li><a href="#ImplementationStudy">Nginx Upstream模块和Location配置</a></li>
  <li><a href="#End">后记</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p><code>Nginx</code>是一款面向性能设计的HTTP服务器，其性能相对于其他服务器表现优异。内部使用异步的事件处理模型，比如linux平台的<code>epoll</code>事件模型，unix平台的<code>kqueue</code>事件模型等。在Nginx源码的<code>src/event/modules</code>目录下，其对各个平台不同的异步模型进行了二次封装。此外，Nginx在代码实现的时候，会考虑到众多细节优化。比如：根据CPU亲缘性来分配进程和事件，避免CPU级的缓存失效；比如字符串比较时，四字节转换为整数来进行快速指令级比较，等等。</p>

<p>本博文主要目的不是Nginx源码分析，所以，对源码及其独特优秀的代码设计不会去详细介绍。</p>

<p>在最近的一些项目中，涉及到nginx的反向代理配置，然后花了一些时间了解下关于Nginx的整体请求处理流程和返现代理的实现机制。</p>

<p>Nginx虽然代码整洁，模块清晰，但是代码量毕竟还是很多，而且注释实在是太少，所以把一些学习的资料和心得整理一下，以便以后查看。</p>

<!--more-->

<h2 id="a-idproxynginx-a"><a id="Proxy">Nginx 反向代理配置说明</a></h2>

<p>反向代理指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接到客户端，此时代理服务器对外就表现为一个服务器，而此种工作模式类似于LVS-NET模型。</p>

<p>反向代理也可以理解为web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加的 一个高速web缓冲服务器，用来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，所有外部网络要访问服务器时的所有请求都要通过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存在本地，以便日后再收到同样的信息请求时，它会将本地缓存里的内容直接发给用户，已减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</p>

<p>了解nginx的反向代理如何实现之前，先看看我们一般配置nginx反向代理的设置：</p>

<p><figure class='code'><figcaption><span>nginx反向代理的设置 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='nginx'><span class='line'><span class="k">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s">&lt;pre&gt;&lt;code&gt;upstream</span> <span class="s">cc_001</span> <span class="p">{</span>
</span><span class='line'>    <span class="kn">server</span> <span class="n">192.168.1.101</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class='line'>    <span class="kn">server</span> <span class="n">192.168.1.102</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kn">healthcheck_enabled</span><span class="p">;</span>
</span><span class='line'>    <span class="kn">healthcheck_delay</span> <span class="mi">3000</span><span class="p">;</span>
</span><span class='line'>    <span class="kn">healthcheck_timeout</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class='line'>    <span class="kn">healthcheck_failcount</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="kn">healthcheck_send</span> <span class="s">&#39;GET</span> <span class="s">/healthcheck.html</span> <span class="s">HTTP/1.0&#39;</span> <span class="s">&#39;Host:</span> <span class="s">local.com&#39;</span> <span class="s">&#39;Connection:</span> <span class="s">close&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">server</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kn">listen</span>       <span class="n">192.168.1.100</span><span class="p">:</span><span class="mi">80</span><span class="p">;</span>
</span><span class='line'>    <span class="kn">server_name</span>  <span class="s">cc.local.com</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kn">proxy_buffers</span> <span class="mi">64</span> <span class="mi">4k</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kn">location</span> <span class="p">=</span> <span class="s">/</span> <span class="p">{</span>
</span><span class='line'>        <span class="kn">proxy_pass</span> <span class="s">http://cc_001/bm/index.htm</span><span class="p">;</span>
</span><span class='line'>        <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
</span><span class='line'>        <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
</span><span class='line'>        <span class="kn">proxy_pass</span> <span class="s">http://cc_001</span><span class="p">;</span>
</span><span class='line'>        <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
</span><span class='line'>        <span class="kn">proxy_set_header</span>   <span class="s">X-Real-IP</span>        <span class="nv">$remote_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="kn">proxy_set_header</span>   <span class="s">X-Forwarded-For</span>  <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>上面的code主要列出来nginx 反向代理基本配置。</p>

<blockquote>
  <blockquote>
    <p>Tips：上面的配置选项都是最最基本的，一般涉及到反向代理都会使用到这些配置。对于其中的设置项，理解起来也很简单。</p>
  </blockquote>
</blockquote>

<p><em>upstream配置块</em></p>

<p>其实在nginx中，<code>upstream</code>是一个非常重要的配置。nginx所有对于动态请求的处理，基本上都需要使用<code>upstream</code>配置模块。nginx的两个很重要的功能，反向代理和负载均衡，都需要通过配置对应的<code>upstream</code>来完成。</p>

<blockquote>
  <blockquote>
    <p>其实在nginx中，有一个基础模块叫handler，这个模块可以接受来自客户端/用户端的请求，然后处理并产生对应的响应内容返回过去。因此，我们那些静态资源，前端页面什么的，都是使用handler模块来完成响应的。但是，众所知周，一般的核心服务都是后台动态产生的，这些资源就不可以方便使用handler去完成内容的生成和响应动作（当然也是可以使用开发自定义handler来完成的，比如各种xxxcgi之流，但是一般还是用来处理静态资源）。</p>

    <p>那么，upstream就出现了。其接收到用户的请求，然后转发到后端服务器拿到对应的响应资源，再返回给请求端。在整个处理过程中，其本身不会产生自己的响应内容，这是和<code>handler</code>模块唯一的区别。</p>

    <p>upstream的特性，决定了在其配置块中，设置一些后端服务器的地址和端口，就ok了。</p>

  </blockquote>
</blockquote>

<p>配置项说明：</p>

<ul>
  <li>
    <p>upstream中的server项：表明后台的一台服务器地址和端口。当客户端有请求到<code>nginx</code>服务器的时候，upstream模块根据这里配置的server，该对应的请求转发到这些server服务上，由这些server来处理请求，然后把响应结果告知upstream模块。</p>
  </li>
  <li>
    <p>healthcheck_enabled项：healthcheck健康监控功能，并不是原生nginx自带的。所以如果使用这个功能，必须要安装第三方插件：<code>ngx_http_healthcheck_module</code>。healthcheck_enabled表示启动健康检查模块功能。</p>
  </li>
  <li>
    <p>healthcheck_delay项：对同一台后端服务器两次检测之间的时间间隔，单位毫秒，默认为1000。</p>
  </li>
  <li>
    <p>healthcheck_timeout项：进行一次健康检测的超时时间，单位为毫秒，默认值2000。</p>
  </li>
  <li>
    <p>healthcheck_failcount项：对一台后端服务器检测成功或失败多少次之后方才确定其为成功或失败，并实现启用或禁用此服务器。</p>
  </li>
  <li>
    <p>healthcheck_send项：为了检测后端服务器的健康状态所发送的检测请求。然后根据各个服务器的响应情况来判断服务器是否存活。上面的配置表面，各个后台服务器上都存在<code>healthcheck.html</code>静态页面，然后nginx会get这个页面，根据是否status为200来判断是否服务器存活。</p>
  </li>
</ul>

<p><em>server配置块</em></p>

<p>在nginx中，不管怎么样的配置，都会有一个server配置块。http服务上支持若干虚拟主机。每个虚拟主机会有一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</p>

<blockquote>
  <blockquote>
    <p>Server其实就是一个虚拟主机。因为在nginx中可以配置多个server，这样就使得nginx可以在一台服务器上配置多个域名。</p>

    <p>在nginx的Server虚拟主机中，它只会处理与之对应的域名请求。并且，如果在listen中设置了ip地址，则该虚拟主机只会处理从该服务器的指定ip端口进来的请求，才会去处理。关于一台服务器设置多个别名ip地址的方式，可以参考博客<a href="http://www.cnblogs.com/mchina/archive/2012/05/21/2511824.html">在Nginx中部署基于IP的虚拟主机</a></p>
  </blockquote>
</blockquote>

<p>配置项说明：</p>

<ul>
  <li>
    <p>listen项：监听ip和端口。当nginx服务器的该ip端口有请求访问，则调用该server的配置来处理该请求。</p>
  </li>
  <li>
    <p>server_name项：域名。nginx对进入该虚拟主机的请求，检查其请求Host头是否匹配设置的server_name，如果是，则继续处理该请求。</p>
  </li>
  <li>
    <p>location块选项：Location在nginx中是一个非常重要的指令。对于HTTP请求，其被用来详细匹配URI和设置的location path。一般这个uri path会是字符串或者正则表达式形式。</p>
  </li>
</ul>

<blockquote>
  <blockquote>
    <p>: 关于location匹配，存在一些语法规则，如下：</p>

    <pre><code>  location [=|~|~*|^~|@] /uri/ { ... }
   =：表示精确匹配，如果找到，立即停止搜索并立即处理此请求。
   ~：表示区分大小写匹配。
   ~*：表示不区分大小写匹配。
   ^~：表示只匹配字符，串不查询正则表达式。
   @：指定一个命名的location，一般只用于内部重定向请求。
</code></pre>
  </blockquote>
</blockquote>

<ul>
  <li>
    <p>location中proxy_pass项：代理转发。配置了该项，当匹配location path的请求进来后，会根据upstream设置，请求后台服务器上的proxy_pass的请求。例如，上面的配置，当有请求<code>cc.local.com</code>时，由于精确匹配<code>=/</code>，则根据proxy_pass配置，则会反向代理，请求<code>192.168.1.101:80/bm/index.htm</code>。</p>
  </li>
  <li>
    <p>location中proxy_set_header项：设置代理请求头。由于经过了反向代理服务器，所以后台服务器不能获取真正的客户端请求地址等信息，这样，就需要把这些ip地址，设置回请求头部中。然后，我们在后台服务上，可以使用<code>request.get("X-Real-IP")</code>或者<code>request.get("X-Forwarded-For")</code>获取真实的请求ip地址。获取host也是如此。具体可以参考博文：<a href="http://gong1208.iteye.com/blog/1559835"> 使用nginx后如何在web应用中获取用户ip及原理解释</a>.</p>
  </li>
</ul>

<h2 id="a-idprocessrequestnginx-a"><a id="ProcessRequest">Nginx 架构和请求处理流程</a></h2>

<p>Nginx架构，在taobao的<a href="http://tengine.taobao.org/book/chapter_02.html">《Nginx开发从入门到精通》</a>电子书中，写的比较详细。这里记录一些核心的细节。</p>

<p>Nginx在启动会以daemon形式在后台运行，采用<code>多进程+异步非阻塞IO事件模型</code>来处理各种连接请求。</p>

<p>Nginx主要包含一个master进行和多个worker进行，一般worker进程个数是根据服务器CPU核数来决定的。如下图：</p>

<p><img src="http://kxcoder.github.io/images/2015/08/nginx_process.png" /></p>

<blockquote>
  <blockquote>
    <p>Notes：从上图中可以很明显地看到，4个worker进程的父进程都是master进程，表明worker进程都是从父进程fork出来的，并且父进程的ppid为1，表示其为daemon进程。</p>

    <p>需要说明的是，在nginx多进程中，每个worker都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p>

  </blockquote>
</blockquote>

<p>下面来介绍一个请求进来，进程模型的处理方式。</p>

<p><em>首先</em>，master进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。</p>

<p><em>其次</em>，根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</p>

<p><em>然后</em>，这个时候有多个worker进程都在监听同样设置的socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的<code>惊群现象</code>。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个<code>accept_mutex</code>类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</p>

<p><em>最后</em>，注册成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。</p>

<blockquote>
  <blockquote>
    <p>进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个worker进程出现异常退出，其他worker进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样子会提高处理效率，并且开发调试也更容易。</p>

    <p>如前文所述，<code>多进程模型+异步非阻塞模型</code>才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。</p>

    <p>关于异步非阻塞IO模型：linux的epoll介绍，可以参考：<a href="http://www.cppblog.com/deane/articles/165218.html">深入了解epoll </a></p>
  </blockquote>
</blockquote>

<h3 id="nginx-">Nginx 连接和请求处理</h3>

<p>上一节介绍了，worker进程会竞争客户端的连接请求，这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠web服务器环境下。</p>

<p>针对这种现象，Nginx采用了一个是否打开accept_mutex选项的值<code>ngx_accept_disabled</code>。标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件。</p>

<blockquote>
  <blockquote>
    <p>ngx_accept_disabled值，nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled。</p>

    <p>当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。</p>
  </blockquote>
</blockquote>

<p>接下来，看看连接处理流程（来自tengine.taobao.org）：</p>

<p><img src="http://kxcoder.github.io/images/2015/08/request_process.png" /></p>

<blockquote>
  <blockquote>
    <p>关于处理流程的说明，参考: <a href="http://tengine.taobao.org/book/chapter_02.html">http://tengine.taobao.org/book/chapter_02.html</a></p>

  </blockquote>
</blockquote>

<h2 id="a-idimplementationstudynginx-upstreamlocationa"><a id="ImplementationStudy">Nginx Upstream模块和Location配置</a></h2>

<p><em>Nginx Upstream</em></p>

<p>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。</p>

<p>从本质上说，upstream属于handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为upstream（上游）。请求并取得响应内容的整个过程已经被封装到nginx内部，所以upstream模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p>

<p><code>upstream</code>模块逻辑实现的十分复杂，对于其具体实现，不分析。</p>

<p><code>upstream</code>模块主要做两件事情：</p>

<ul>
  <li>
    <p>当外部的客户端发送一个http请求后，如果涉及更后台服务，则会创建一个到后端服务的request请求；</p>
  </li>
  <li>
    <p>请求到达后端，然后处理完成后，则upstream会将返回的数据接收过来，然后发送给外部请求的客户端。</p>
  </li>
</ul>

<p><em>Nginx Location</em></p>

<p>首先，介绍下存在的几种Location配置方式：</p>

<p><figure class='code'><figcaption><span>nginx Location配置方式 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='nginx'><span class='line'><span class="k">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s">&lt;p&gt;location</span>  <span class="p">=</span> <span class="s">/</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1"># matches the query / only.</span>
</span><span class='line'>  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">A</span> <span class="s">]</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="s">location</span>  <span class="s">/</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1"># matches any query, since all queries begin with /, but regular</span>
</span><span class='line'>  <span class="c1"># expressions and any longer conventional blocks will be</span>
</span><span class='line'>  <span class="c1"># matched first.</span>
</span><span class='line'>  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">B</span> <span class="s">]</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="s">location</span> <span class="s">/documents/</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1"># matches any query beginning with /documents/ and continues searching,</span>
</span><span class='line'>  <span class="c1"># so regular expressions will be checked. This will be matched only if</span>
</span><span class='line'>  <span class="c1"># regular expressions don’t find a match.</span>
</span><span class='line'>  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">C</span> <span class="s">]</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="s">location</span> <span class="s">^~</span> <span class="s">/images/</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1"># matches any query beginning with /images/ and halts searching,</span>
</span><span class='line'>  <span class="c1"># so regular expressions will not be checked.</span>
</span><span class='line'>  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">D</span> <span class="s">]</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="s">location</span> <span class="p">~</span><span class="sr">*</span> <span class="s">.(gif|jpg|jpeg)</span>$ <span class="p">{</span>
</span><span class='line'>  <span class="c1"># matches any request ending in gif, jpg, or jpeg. However, all</span>
</span><span class='line'>  <span class="c1"># requests to the /images/ directory will be handled by</span>
</span><span class='line'>  <span class="c1"># Configuration D. &lt;br /&gt;</span>
</span><span class='line'>  <span class="kn">[</span> <span class="s">configuration</span> <span class="s">E</span> <span class="s">]</span>
</span><span class='line'><span class="err">}</span><span class="s">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="s">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>示例请求：</p>

<ul>
  <li>/ -&gt; configuration A</li>
  <li>/index.html -&gt; configuration B</li>
  <li>/documents/document.html -&gt; configuration C</li>
  <li>/images/1.gif -&gt; configuration D</li>
  <li>/documents/1.jpg -&gt; configuration E</li>
</ul>

<p>解析匹配规则为：</p>

<ol>
  <li>
    <p>字符串精确匹配到一个带 “=” 号前缀的location，则停止，且使用这个location的配置；</p>
  </li>
  <li>
    <p>字符串匹配剩下的非正则和非特殊location，如果匹配到某个带 “^~” 前缀的location，则停止；</p>
  </li>
  <li>
    <p>正则匹配，匹配顺序为location在配置文件中出现的顺序。如果匹配到某个正则location，则停止，并使用这个location的配置；否则，使用步骤2中得到的具有最大字符串匹配的location配置。</p>
  </li>
</ol>

<blockquote>
  <blockquote>
    <p>Notes：需要注意的是：<code>~ 开头</code>表示区分大小写的正则匹配；而<code>~*  开头</code>表示不区分大小写的正则匹配。<code>!~和!~*</code>分别为区分大小写不匹配及不区分大小写不匹配的正则</p>
  </blockquote>
</blockquote>

<h2 id="a-idenda"><a id="End">后记</a></h2>

<p>Nginx 是一个十分优秀的服务器软件，其内部相当多的设计和实现都非常巧妙和高效。</p>

<p>关于Nginx的一些好的站点有：</p>

<ul>
  <li><a href="http://tengine.taobao.org/book/">http://tengine.taobao.org/book/</a></li>
  <li><a href="http://www.pagefault.info/?cat=7">http://www.pagefault.info/?cat=7</a></li>
  <li><a href="http://nginx.org/en/docs/">http://nginx.org/en/docs/</a></li>
  <li><a href="http://kxcoder.github.io/images/2015/08/nginx_stream.png">http://kxcoder.github.io/images/2015/08/nginx_stream.png</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解软件包的配置、编译与安装]]></title>
    <link href="http://kxcoder.github.io/blog/2014/06/24/Linux-Software-Install-Understand/"/>
    <updated>2014-06-24T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/06/24/Linux-Software-Install-Understand</id>
    <content type="html"><![CDATA[<p>说明：来自互联网，如有版权问题，请告知本人将其撤下。</p>

<p>来源：<a href="http://works.jinbuguo.com/linux/understand_package_install.htm">http://works.jinbuguo.com/linux/understand_package_install.htm</a>l</p>

<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#About">概述</a></li>
  <li><a href="#Make">Makefile 与 make</a></li>
  <li><a href="#Configure">configure</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>从源代码安装过软件的朋友一定对 <code>./configure &amp;&amp; make &amp;&amp; make install</code> 安装三步曲非常熟悉了。然而究竟这个过程中的每一步幕后都发生了些什么呢？本文将带领你一探究竟。深入理解这个过程将有助于你在LFS的基础上玩出自己的花样来。不过需要说明的是本文对 <code>Makefile</code> 和 <code>make</code> 的讲解是相当近视和粗浅的，但是对于理解安装过程来说足够了。</p>

<!--more-->

<h2 id="a-idabouta"><a id="About">概述</a></h2>

<p>用一句话来解释这个过程就是：</p>

<p>根据源码包中 Makefile.in 文件的指示，configure 脚本检查当前的系统环境和配置选项，在当前目录中生成 <code>Makefile</code> 文件(还有其它本文无需关心的文件)，然后 <code>make</code> 程序就按照当前目录中的 Makefile 文件的指示将源代码编译为二进制文件，最后将这些二进制文件移动(即安装)到指定的地方(仍然按照 <code>Makefile</code> 文件的指示)。</p>

<p>由此可见 Makefile 文件是幕后的核心。要深入理解安装过程，必须首先对 <code>Makefile</code> 文件有充分的了解。本文将首先讲述 <code>Makefile</code> 与 <code>make</code> ，然后再讲述 <code>configure</code> 脚本。并且在讲述这两部分内容时，提供了尽可能详细的、可以运用于实践的参考资料。</p>

<h2 id="a-idmakemakefile--makea"><a id="Make">Makefile 与 make</a></h2>

<p>用一句话来概括<code>Makefile</code> 与 <code>make</code> 的关系就是：</p>

<p><code>Makefile</code> 包含了所有的规则和目标，而 <code>make</code> 则是为了完成目标而去解释 <code>Makefiel</code> 规则的工具。</p>

<h3 id="make-">make 语法</h3>

<p>首先看看 <code>make</code> 的命令行语法：</p>

<p><figure class='code'><figcaption><span>Linux make </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;make <span class="o">[</span>options<span class="o">]</span> <span class="o">[</span>targets<span class="o">]</span> <span class="o">[</span><span class="nv">VAR</span><span class="o">=</span>VALUE<span class="o">]</span>…&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p><code>[options]</code>是命令行选项，可以用 <code>make --help</code> 命令查看全部，<code>[VAR=VALUE]</code>是在命令行上指定环境变量，这两个大家都很熟悉，将在稍后详细讲解。而<code>[targets]</code>是什么呢？字面的意思是”目标”，也就是希望本次 make 命令所完成的任务。凭经验猜测，这个<code>[targets]</code>大概可以用”check”,”install”之类(也就是常见的测试和安装命令)。但是它到底是个啥玩意儿？不带任何”目标”的 <code>make</code> 命令是什么意思？为什么在安装 LFS 工具链中的 Perl-5.8.8 软件包时会出现”make perl utilities”这样怪异的命令？要回答这些问题必须首先理解 <code>Makefile</code> 文件中的”规则”。</p>

<h3 id="makefile-">Makefile 规则</h3>

<p>Makefile 规则包含了文件之间的依赖关系和更新此规则目标所需要的命令。</p>

<p>一个简单的 Makefile 规则是这样写的：</p>

<p><figure class='code'><figcaption><span>Linux makefile </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;TARGET : PREREQUISITES
</span><span class='line'>	COMMAND
</span><span class='line'>TARGET&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>规则的目标。也就是可以被 make 使用的”目标”。有些目标可以没有依赖而只有动作(命令行)，比如”clean”，通常仅仅定义一系列删除中间文件的命令。同样，有些目标可以没有动作而只有依赖，比如”all”，通常仅仅用作”终极目标”。</p>

<p><code>PREREQUISITES</code><br />
规则的依赖。通常一个目标依赖于一个或者多个文件。</p>

<p><code>COMMAND</code><br />
规则的命令行。一个规则可以有零个或多个命令行。</p>

<p>OK! 现在你明白[targets]是什么了，原来它们来自于 <code>Makefile</code> 文件中一条条规则的目标(TARGET)。另外，<code>Makefile</code>文件中第一条规则的目标被称为”终极目标”，也就是你省略[targets]参数时的目标(通常为”all”)。</p>

<p>当你查看一个实际的 <code>Makefile</code> 文件时，你会发现有些规则非常复杂，但是它都符合规则的基本格式。此外，<code>Makefile</code> 文件中通常还包含了除规则以外的其它很多东西，不过本文只关心其中的变量。</p>

<h3 id="makefile--1">Makefile 实例</h3>

<p>下面看一个简单的、实际的 <code>Makefile</code>文件：</p>

<p><figure class='code'><figcaption><span>Linux makefile </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CC<span class="o">=</span>gcc
</span><span class='line'><span class="nv">CPPFLAGS</span><span class="o">=</span>
</span><span class='line'><span class="nv">CFLAGS</span><span class="o">=</span>-O2 -pipe
</span><span class='line'><span class="nv">LDFLAGS</span><span class="o">=</span>-s
</span><span class='line'><span class="nv">PREFIX</span><span class="o">=</span>/usr&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;all : prog1 prog2&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;prog1 : prog1.o
</span><span class='line'>	<span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -o prog1 prog1.o&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;prog1.o : prog1.c
</span><span class='line'>	<span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> prog1.c&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;prog2 : prog2.o
</span><span class='line'>	<span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>LDFLAGS<span class="k">)</span> -o prog2 prog2.o&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;prog2.o : prog2.c
</span><span class='line'>	<span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CPPFLAGS<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> prog2.c&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;clean :
</span><span class='line'>	rm -f *.<span class="o">{</span>o,a<span class="o">}</span> prog<span class="o">{</span>1,2<span class="o">}</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;install : prog1 prog2
</span><span class='line'>	<span class="k">if</span> <span class="o">(</span> <span class="nb">test</span> ! -d <span class="k">$(</span>PREFIX<span class="k">)</span>/bin <span class="o">)</span> <span class="p">;</span> <span class="k">then</span> mkdir -p <span class="k">$(</span>PREFIX<span class="k">)</span>/bin <span class="p">;</span> <span class="k">fi</span>
</span><span class='line'>	cp -f prog1 <span class="k">$(</span>PREFIX<span class="k">)</span>/bin/prog1
</span><span class='line'>	cp -f prog2 <span class="k">$(</span>PREFIX<span class="k">)</span>/bin/prog2&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;check <span class="nb">test</span> : prog1 prog2
</span><span class='line'>	prog1 <span class="p">&amp;</span>lt<span class="p">;</span> sample1.ref <span class="p">&amp;</span>gt<span class="p">;</span> sample1.rz
</span><span class='line'>	prog1 <span class="p">&amp;</span>lt<span class="p">;</span> sample2.ref <span class="p">&amp;</span>gt<span class="p">;</span> sample3.rz
</span><span class='line'>	cmp sample1.ok sample1.rz
</span><span class='line'>	cmp sample2.ok sample2.rz&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>从中可以看出，<code>make</code> 与 <code>make all</code> 以及 <code>make prog1 prog2</code> 三条命令其实是等价的。而常用的 <code>make check</code> 和 <code>make install</code> 也找到了归属。同时我们也看到了 Makefile 中的各种变量是如何影响编译的。针对这个特定的 Makefile ，你甚至可以省略安装三步曲中的 make 命令而直接使用<code> make install</code> 进行安装。</p>

<p>同样，为了使用自定义的编译参数编译 prog2 ，我们可以使用 <code>make prog2 CFLAGS="-O3 -march=athlon64"</code> 或 <code>CFLAGS="-O3 -march=athlon64" &amp;&amp; make -e prog2</code> 命令达到此目的。</p>

<h3 id="makefile--2">Makefile 惯例</h3>

<p>下面是Makefile中一些约定俗成的目标名称及其含义：</p>

<p><code>all</code><br />
编译整个软件包，但不重建任何文档。一般此目标作为默认的终极目标。此目标一般对所有源程序的编译和连接使用”-g”选项，以使最终的可执行程序中包含调试信息。可使用 strip 程序去掉这些调试符号。</p>

<p><code>clean</code><br />
清除当前目录下在 make 过程中产生的文件。它不能删除软件包的配置文件，也不能删除 build 时创建的那些文件。</p>

<p><code>distclean</code><br />
类似于”clean”，但增加删除当前目录下的的配置文件、build 过程产生的文件。</p>

<p><code>info</code><br />
产生必要的 Info 文档。</p>

<p><code>check 或 test</code> <br />
完成所有的自检功能。在执行检查之前，应确保所有程序已经被创建(但可以尚未安装)。为了进行测试，需要实现在程序没有安装的情况下被执行的测试命令。</p>

<p><code>install</code><br />
完成程序的编译并将最终的可执行程序、库文件等拷贝到指定的目录。此种安装一般不对可执行程序进行 strip 操作。</p>

<p><code>install-strip</code><br />
和”install”类似，但是会对复制到安装目录下的可执行文件进行 strip 操作。</p>

<p><code>uninstall</code><br />
删除所有由”install”安装的文件。</p>

<p><code>installcheck</code><br />
执行安装检查。在执行安装检查之前，需要确保所有程序已经被创建并且被安装。</p>

<p><code>installdirs</code> <br />
创建安装目录及其子目录。它不能更改软件的编译目录，而仅仅是创建程序的安装目录。</p>

<p>下面是 Makefile 中一些约定俗成的变量名称及其含义：</p>

<p>这些约定俗成的变量分为三类。第一类代表可执行程序的名字，例如 CC 代表编译器这个可执行程序；第二类代表程序使用的参数(多个参数使用空格分开)，例如 CFLAGS 代表编译器执行时使用的参数(一种怪异的做法是直接在 CC 中包含参数)；第三类代表安装目录，例如 prefix 等等，含义简单，下面只列出它们的默认值。</p>

<p><figure class='code'><figcaption><span>Linux makefile </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;AR   函数库打包程序，可创建静态库.a文档。默认是”ar”。
</span><span class='line'>AS   汇编程序。默认是”as”。
</span><span class='line'>CC   C编译程序。默认是”cc”。
</span><span class='line'>CXX  C++编译程序。默认是”g++”。
</span><span class='line'>CPP  C/C++预处理器。默认是”<span class="k">$(</span>CC<span class="k">)</span> -E”。
</span><span class='line'>FC   Fortran编译器。默认是”f77”。
</span><span class='line'>PC   Pascal语言编译器。默认是”pc”。
</span><span class='line'>YACC Yacc文法分析器。默认是”yacc”。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ARFLAGS     函数库打包程序的命令行参数。默认值是”rv”。
</span><span class='line'>ASFLAGS     汇编程序的命令行参数。
</span><span class='line'>CFLAGS      C编译程序的命令行参数。
</span><span class='line'>CXXFLAGS    C++编译程序的命令行参数。
</span><span class='line'>CPPFLAGS    C/C++预处理器的命令行参数。
</span><span class='line'>FFLAGS      Fortran编译器的命令行参数。
</span><span class='line'>PFLAGS      Pascal编译器的命令行参数。
</span><span class='line'>YFLAGS      Yacc文法分析器的命令行参数。
</span><span class='line'>LDFLAGS     链接器的命令行参数。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;prefix      /usr/local
</span><span class='line'>exec_prefix <span class="k">$(</span>prefix<span class="k">)</span>
</span><span class='line'>bindir      <span class="k">$(</span>exec_prefix<span class="k">)</span>/bin
</span><span class='line'>sbindir     <span class="k">$(</span>exec_prefix<span class="k">)</span>/sbin
</span><span class='line'>libexecdir  <span class="k">$(</span>exec_prefix<span class="k">)</span>/libexec
</span><span class='line'>datadir     <span class="k">$(</span>prefix<span class="k">)</span>/share
</span><span class='line'>sysconfdir  <span class="k">$(</span>prefix<span class="k">)</span>/etc
</span><span class='line'>sharedstatedir <span class="k">$(</span>prefix<span class="k">)</span>/com
</span><span class='line'>localstatedir  <span class="k">$(</span>prefix<span class="k">)</span>/var
</span><span class='line'>libdir      <span class="k">$(</span>exec_prefix<span class="k">)</span>/lib
</span><span class='line'>infodir     <span class="k">$(</span>prefix<span class="k">)</span>/info
</span><span class='line'>includedir  <span class="k">$(</span>prefix<span class="k">)</span>/include
</span><span class='line'>oldincludedir  <span class="k">$(</span>prefix<span class="k">)</span>/include
</span><span class='line'>mandir      <span class="k">$(</span>prefix<span class="k">)</span>/man
</span><span class='line'>srcdir      需要编译的源文件所在的目录，无默认值&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<h3 id="make--1">make 选项</h3>

<p>最后说说 make 的命令行选项(以Make-3.81版本为准)：</p>

<p><figure class='code'><figcaption><span>Linux makefile </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-B, --always-make&lt;/code&gt;
</span><span class='line'>无条件的重建所有规则的目标，而不是根据规则的依赖关系决定是否重建某些目标文件。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-C DIR, --directory<span class="o">=</span>DIR&lt;/code&gt;
</span><span class='line'>在做任何动作之前先切换工作目录到 DIR ，然后再执行 make 程序。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;
</span><span class='line'>在 make 执行过程中打印出所有的调试信息。包括：make 认为那些文件需要重建；那些文件需要比较它们的最后修改时间、比较的结果；重建目标所要执行的命令；使用的隐含规则等。使用该选项我们可以看到 make 构造依赖关系链、重建目标过程的所有信息，它等效于”-debug<span class="o">=</span>a”。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;--debug<span class="o">=</span>FLAGS&lt;/code&gt;
</span><span class='line'>    在 make 执行过程中打印出调试信息。FLAGS 用于控制调试信息级别：
</span><span class='line'>    a 输出所有类型的调试信息
</span><span class='line'>    b 输出基本调试信息。包括：那些目标过期、是否重建成功过期目标文件。
</span><span class='line'>    v 除 b 级别以外还包括：解析的 makefile 文件名，不需要重建文件等。
</span><span class='line'>    i 除 b 级别以外还包括：所有使用到的隐含规则描述。
</span><span class='line'>    j 输出所有执行命令的子进程，包括命令执行的 PID 等。
</span><span class='line'>    m 输出 make 读取、更新、执行 makefile 的信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-e, --environment-overrides&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>使用系统环境变量的定义覆盖 Makefile 中的同名变量定义。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-f FILE, --file<span class="o">=</span>FILE, --makefile<span class="o">=</span>FILE&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>将 FILE 指定为 Makefile 文件。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-h, --help&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>打印帮助信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-i, --ignore-errors&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>忽略规则命令执行过程中的错误。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-I DIR, --include-dir<span class="o">=</span>DIR&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>指定包含 Makefile 文件的搜索目录。使用多个”-I”指定目录时，搜索目录按照指定顺序进行。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-j <span class="o">[</span>N<span class="o">]</span>, --jobs<span class="o">[=</span>N<span class="o">]</span>&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>指定并行执行的命令数目。在没有指定”-j”参数的情况下，执行的命令数目将是系统允许的最大可能数目。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-k, --keep-going&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>遇见命令执行错误时不终止 make 的执行，也就是尽可能执行所有的命令，直到出现致命错误才终止。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-l <span class="o">[</span>N<span class="o">]</span>, --load-average<span class="o">[=</span>N<span class="o">]</span>, --max-load<span class="o">[=</span>N<span class="o">]</span>&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>如果系统负荷超过 LOAD<span class="o">(</span>浮点数<span class="o">)</span>，不再启动新任务。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-L, --check-symlink-times&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>同时考察符号连接的时间戳和它所指向的目标文件的时间戳，以两者中较晚的时间戳为准。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-n, --just-print, --dry-run, --recon&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>  只打印出所要执行的命令，但并不实际执行命令。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-o FILE, --old-file<span class="o">=</span>FILE, --assume-old<span class="o">=</span>FILE&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>即使相对于它的依赖已经过期也不重建 FILE 文件；同时也不重建依赖于此文件任何文件。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-p, --print-data-base&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>命令执行之前，打印出 make 读取的 Makefile 的所有数据（包括规则和变量的值），同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 make -qp 命令。查看 make 执行前的预设规则和变量，可使用命令 make -p -f /dev/null 。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-q, --question&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>“询问模式”。不运行任何命令，并且无输出，只是返回一个查询状态。返回状态为 <span class="m">0</span> 表示没有目标需要重建，1 表示存在需要重建的目标，2 表示有错误发生。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-r, --no-builtin-rules&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>取消所有内嵌的隐含规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时还会取消所有支持后追规则的隐含后缀列表，同样我们也可以在 Makefile 中使用”.SUFFIXES”定义我们自己的后缀规则。此选项不会取消 make 内嵌的隐含变量。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-R, --no-builtin-variables&lt;/code&gt; &lt;br /&gt;
</span><span class='line'>取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意，此选项同时打开了”-r”选项。因为隐含规则是以内嵌的隐含变量为基础的。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-s, --silent, --quiet&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>不显示所执行的命令。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-S, --no-keep-going, --stop&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>取消”-k”选项。在递归的 make 过程中子 make 通过 MAKEFLAGS 变量继承了上层的命令行选项。我们可以在子 make 中使用”-S”选项取消上层传递的”-k”选项，或者取消系统环境变量 MAKEFLAGS 中的”-k”选项。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-t, --touch&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>更新所有目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-v, --version&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>打印版本信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-w, --print-directory&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>在 make 进入一个目录之前打印工作目录。使用”-C”选项时默认打开这个选项。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;--no-print-directory &lt;/code&gt;
</span><span class='line'>取消”-w”选项。可以是用在递归的 make 调用过程中，取消”-C”参数将默认打开”-w”。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;-W FILE, --what-if<span class="o">=</span>FILE, --new-file<span class="o">=</span>FILE, --assume-new<span class="o">=</span>FILE&lt;/code&gt;&lt;br /&gt;
</span><span class='line'>设定 FILE 文件的时间戳为当前时间，但不改变文件实际的最后修改时间。此选项主要是为实现了对所有依赖于 FILE 文件的目标的强制重建。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;code&gt;--warn-undefined-variables &lt;/code&gt;
</span><span class='line'>在发现 Makefile 中存在对未定义的变量进行引用时给出告警信息。此功能可以帮助我们调试一个存在多级套嵌变量引用的复杂 Makefile 。但是：我们建议在书写 Makefile 时尽量避免超过三级以上的变量套嵌引用。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<h2 id="a-idconfigureconfigurea"><a id="Configure">configure</a></h2>

<p>此阶段的主要目的是生成 Makefile 文件，是最关键的运筹帷幄阶段，基本上所有可以对安装过程进行的个性化调整都集中在这一步。</p>

<p>configure 脚本能够对 Makefile 中的哪些内容产生影响呢？基本上可以这么说：所有内容，包括本文最关心的 Makefile 规则与 Makefile 变量。那么又是哪些因素影响着最终生成的 Makefile 文件呢？答曰：系统环境和配置选项。</p>

<p>配置选项的影响是显而易见的。但是”系统环境”的概念却很宽泛，包含很多方面内容，不过我们这里只关心环境变量，具体说来就是将来会在 Makefile 中使用到的环境变量以及与 Makefile 中的变量同名的环境变量。</p>

<h3 id="configure-">通用 configure 语法</h3>

<p>在进一步讲述之前，先看看 configure 脚本的语法，一般有两种：</p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;configure <span class="o">[</span>OPTIONS<span class="o">]</span> <span class="o">[</span><span class="nv">VAR</span><span class="o">=</span>VALUE<span class="o">]</span>…&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;configure <span class="o">[</span>OPTIONS<span class="o">]</span> <span class="o">[</span>HOST<span class="o">]</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>不管是哪种语法，我们都可以用 <code>configure --help</code> 查看所有可用的<code>[OPTIONS]</code>，并且通常在结尾部分还能看到这个脚本所关心的环境变量有哪些。在本文中将对这两种语法进行合并，使用下面这种简化的语法：</p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;configure <span class="o">[</span>OPTIONS<span class="o">]</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>这种语法能够被所有的 <code>configure</code> 脚本所识别，同时也能通过设置环境变量和使用特定的<code>[OPTIONS]</code>完成上述两种语法的一切功能。</p>

<h3 id="configure--1">通用 configure 选项</h3>

<p>虽然每个软件包的 configure 脚本千差万别，但是它们却都有一些共同的选项，也基本上都遵守相同的选项语法。</p>

<p><strong>脚本自身选项</strong></p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–help&lt;br /&gt;
</span><span class='line'>显示帮助信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–version&lt;br /&gt;
</span><span class='line'>显示版本信息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–cache-file<span class="o">=</span>FILE&lt;br /&gt;
</span><span class='line'>在FILE文件中缓存测试结果<span class="o">(</span>默认禁用<span class="o">)</span>。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–no-create&lt;br /&gt;
</span><span class='line'>configure脚本运行结束后不输出结果文件，常用于正式编译前的测试。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–quiet, –silent&lt;br /&gt;
</span><span class='line'>不显示脚本工作期间输出的”checking …“消息。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p><strong>目录选项</strong></p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–srcdir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>源代码文件所在目录，默认为configure脚本所在目录或其父目录。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–prefix<span class="o">=</span>PREFIX&lt;br /&gt;
</span><span class='line'>体系无关文件的顶级安装目录PREFIX ，默认值一般是 /usr/local 或 /usr/local/pkgName&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–exec-prefix<span class="o">=</span>EPREFIX&lt;br /&gt;
</span><span class='line'>体系相关文件的顶级安装目录EPREFIX ，默认值一般是 PREFIX&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–bindir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>用户可执行文件的存放目录DIR ，默认值一般是 EPREFIX/bin&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–sbindir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>系统管理员可执行目录DIR ，默认值一般是 EPREFIX/sbin&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–libexecdir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>程序可执行目录DIR ，默认值一般是 EPREFIX/libexec&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–datadir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>通用数据文件的安装目录DIR ，默认值一般是 PREFIX/share&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–sysconfdir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>只读的单一机器数据目录DIR ，默认值一般是 PREFIX/etc&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–sharedstatedir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>可写的体系无关数据目录DIR ，默认值一般是 PREFIX/com&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–localstatedir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>可写的单一机器数据目录DIR ，默认值一般是 PREFIX/var&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–libdir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>库文件的安装目录DIR ，默认值一般是 EPREFIX/lib&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–includedir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>C头文件目录DIR ，默认值一般是 PREFIX/include&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–oldincludedir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>非gcc的C头文件目录DIR ，默认值一般是 /usr/include&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–infodir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>Info文档的安装目录DIR ，默认值一般是 PREFIX/info&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–mandir<span class="o">=</span>DIR&lt;br /&gt;
</span><span class='line'>Man文档的安装目录DIR ，默认值一般是 PREFIX/man&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p><strong>体系结构选项</strong></p>

<p>玩交叉编译的朋友对这些选项已经很熟悉了，对于不使用交叉编译的朋友也不必担心，不要理它们就可以了。</p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–build<span class="o">=</span>BUILD&lt;br /&gt;
</span><span class='line'>工具链当前的运行环境，默认是 config.guess 脚本的输出结果。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–host<span class="o">=</span>HOST&lt;br /&gt;
</span><span class='line'>编译出的二进制代码将要运行在HOST上，默认值是BUILD。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–target<span class="o">=</span>TARGET&lt;br /&gt;
</span><span class='line'>编译出的工具链所将来生成的二进制代码要在TARGET上运行，这个选项仅对工具链<span class="o">(</span>也就是GCC和Binutils两者<span class="o">)</span>有意义。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p><strong>特性选项</strong></p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–enable-FEATURE&lt;br /&gt;
</span><span class='line'>启用FEATURE特性&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–disable-FEATURE&lt;br /&gt;
</span><span class='line'>禁用FEATURE特性&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–with-PACKAGE<span class="o">[=</span>DIR<span class="o">]</span>&lt;br /&gt;
</span><span class='line'>启用附加软件包PACKAGE，亦可同时指定PACKAGE所在目录DIR&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;–without-PACKAGE&lt;br /&gt;
</span><span class='line'>禁用附加软件包PACKAGE&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p><strong>通用环境变量</strong></p>

<p>除了上述通用的选项外，下列环境变量影响着最终生成的 Makefile 文件：</p>

<p><figure class='code'><figcaption><span>Linux configure </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CPP&lt;br /&gt;
</span><span class='line'>C预处理器命令&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CXXCPP&lt;br /&gt;
</span><span class='line'>C++预处理器命令&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CPPFLAGS&lt;br /&gt;
</span><span class='line'>C/C++预处理器命令行参数&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CC&lt;br /&gt;
</span><span class='line'>C编译器命令&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CFLAGS&lt;br /&gt;
</span><span class='line'>C编译器命令行参数&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CXX&lt;br /&gt;
</span><span class='line'>C++编译器命令&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;CXXFLAGS&lt;br /&gt;
</span><span class='line'>C++编译器命令行参数&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;LDFLAGS&lt;br /&gt;
</span><span class='line'>连接器命令行参数&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>至于设置这些环境变量的方法，你可以将它们 <code>export</code> 为全局变量在全局范围内使用，也可以在命令行上使用 <code>[VAR=VALUE]... configure [OPTIONS]</code> 的语法局部使用。此处就不详细描述了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu Chrome启动失败解决方法]]></title>
    <link href="http://kxcoder.github.io/blog/2014/06/10/Ubuntu-Chrome-Start-Fail-Resolve/"/>
    <updated>2014-06-10T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/06/10/Ubuntu-Chrome-Start-Fail-Resolve</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Chrome">Chrome启动失败解决方法</a></li>
  <li><a href="#Finally">小结</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>使用<code>Ubuntu</code>系统时，由于系统是默认安装的，所以机器名没有修改成一个合适的名字。在<code>Ubuntu</code>下通过命令<code>sudo vim /etc/hostname</code>来修改成自己想要的命令，然后注销用户，重新进入系统。</p>

<p>接着，就出现了一个很奇怪的问题，我的桌面上的chrome图标不能点击进入，一直都是无响应状态，但是其他浏览器，比如自带的<code>Firefox</code>就可以正常启动和使用。</p>

<h2 id="a-idchromechromea"><a id="Chrome">Chrome启动失败解决方法</a></h2>

<p>点击<code>chrome</code>图标不管用，并且看不到任何出错信息，无法定位问题出在哪里。只好，从<code>终端</code>使用<code>google-chrome</code>命令来启动<code>chrome</code>浏览器客户端了。于是，出现以下错误信息：</p>

<!--more-->

<p><figure class='code'><figcaption><span>Linux install chrome </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ketao@ketao-Latitude:~<span class="nv">$ </span>google-chrome&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="o">[</span>5901:5901:0610/183033:ERROR:process_singleton_linux.cc<span class="o">(</span>309<span class="o">)]</span> 其他计算机 <span class="o">(</span>ketao-Latitude-E5430-non-vPro<span class="o">)</span> 的另一个 Google Chrome 进程 <span class="o">(</span>7578<span class="o">)</span> 好像正在使用此个人资料。Chrome 已锁定此个人资料以防止其受损。如果您确定其他进程目前未使用此个人资料，请为其解锁并重新启动 Chrome。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="o">[</span>5901:5901:0610/183033:ERROR:simple_message_box_views.cc<span class="o">(</span>208<span class="o">)]</span> Unable to show a dialog outside the UI thread message loop: Google Chrome - 其他计算机 <span class="o">(</span>ketao-Latitude-E5430-non-vPro<span class="o">)</span> 的另一个 Google Chrome 进程 <span class="o">(</span>7578<span class="o">)</span> 好像正在使用此个人资料。Chrome 已锁定此个人资料以防止其受损。如果您确定其他进程目前未使用此个人资料，请为其解锁并重新启动 Chrome。&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<blockquote>
  <blockquote>
    <p>Note：显然，上面的错误信息告诉我们，尼玛，<code>chrome</code>会记录我们在计算机上的操作数据在本地，然后我们修改主机名后，导致老数据被锁住了，这样新的主机名下chrome无法获取用户对应的浏览器数据，因此chrome无法正常启动，并且在UI上还无法看到相关错误，导致假死现象出现。</p>
  </blockquote>
</blockquote>

<h3 id="section-1">解决方法：</h3>

<p>先把本机上的<code>chrome</code>卸载掉，当然这不会把那些被锁定的数据也一并删除掉，不然我也不会写一篇博客记录下。因此，接下来，你需要删除掉自个目录下的残留的<code>chrome</code>用户数据。</p>

<p>在当前用户目录下面执行命令：</p>

<p><figure class='code'><figcaption><span>Linux install chrome </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;ketao@ketao-Latitude:~<span class="nv">$ </span><span class="nb">cd</span> .config/
</span><span class='line'>ketao@ketao-Latitude:~/.config<span class="nv">$ </span>ls
</span><span class='line'>chromium        gedit             monitors.xml     Trolltech.conf
</span><span class='line'>compiz-1        gnome-session     nautilus         ubuntu-ui-toolkit
</span><span class='line'>dconf           google-chrome     pulse            update-notifier
</span><span class='line'>enchant         gtk-2.0           ReText project   upstart
</span><span class='line'>evolution       gtk-3.0           software-center  user-dirs.dirs
</span><span class='line'>fcitx           ibus              SogouPY          user-dirs.locale
</span><span class='line'>fcitx-qimpanel  libaccounts-glib  SogouPY.users    VirtualBox
</span><span class='line'>ketao@ketao-Latitude:~/.config<span class="nv">$ </span>rm -rf chromium/
</span><span class='line'>ketao@ketao-Latitude:~/.config<span class="nv">$ </span>rm -rf google-chrome/
</span></code></pre></td></tr></table></div></figure></p>

<p>然后，重装<code>chrome</code>浏览器，安装成功之后，就可以启动<code>chrome</code>了。</p>

<h2 id="a-idfinallya"><a id="Finally">小结</a></h2>

<p>一般，如果程序出现问题，通过重装都无法解决的，都是应用在用户目录下面添加来一些配置文件，并且这些文件在应用卸载之后并不会删除，所以会出现重装失败的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu Subversion软件安装和配置]]></title>
    <link href="http://kxcoder.github.io/blog/2014/06/04/Ubuntu-Software-Configure-and-Install/"/>
    <updated>2014-06-04T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/06/04/Ubuntu-Software-Configure-and-Install</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Subversion">subversion安装和配置</a></li>
  <li><a href="#Finally">小结</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p>最近，系统从 <code>windows</code>切换到<code>Ubuntu</code>，一些开发软件需要重新安装和配置。但是，众所周知，<code>windows</code>上的开发软件客户端比<code>ubuntu</code>等linux系系统使用要便捷和傻瓜得多，所以切换到<code>ubuntu</code>有很多软件需要安装，但是这些软件需要进行代码编译，就在这里记录下。</p>

<h2 id="a-idsubversionsubversiona"><a id="Subversion">subversion安装和配置</a></h2>

<p>一般，如果对<code>subversion</code>的版本不限制，那些直接使用<code>sudo apt-get install subversion</code>命令就可以安装来，但是如果对版本有要求，比如由于<code>svn</code>的1.8版本在很多<code>svn</code>服务器端不被支持，所以需要安装低于1.8的svn客户端。这就需要我们在本地编译完了之后再安装。</p>

<!--more-->

<h3 id="subversion">2.1 subversion源码下载</h3>

<p>点击进入下载页面：<a href="http://subversion.apache.org/download/#supported-releases">http://subversion.apache.org/download/#supported-releases</a> , 选择当前最新的<code>1.7</code>的子版本下载；</p>

<p>或者，也可以直接在终端使用命令：<code>wget http://apache.fayea.com/apache-mirror/subversion/subversion-1.7.17.tar.gz</code>下载。</p>

<h3 id="subversion-">2.2 subversion 源码编译准备</h3>

<p>在<code>Linux</code>编译安装<code>subversion</code>需要事先准备很多的工作，安装很多相关的工具包，否则代码无法编译通过。因此，在安装<code> subversion</code>之前，需要先做一些准备工作。</p>

<h3 id="autoconf--libtool">2.2.1 安装 autoconf 和 libtool</h3>

<p>编译<code>subversion</code>首先需要安装<code>autoconf</code>和<code>libtool</code>两个工具，如果你的电脑上没有安装这两个工具包，很简单，直接执行安装命令就可以来了：</p>

<pre><code>1.  sudo apt-get install autoconf

2.  sudo apt-get install libtool
</code></pre>

<p>但是，如果你就接下来运行<code>./configure</code>命令，则会出现下面错误:</p>

<p><figure class='code'><figcaption><span>Linux install software </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='kconfig'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;configure: Apache Portable Runtime <span class="p">(</span>APR) library configuration
</span><span class='line'>checking for APR… no
</span><span class='line'>configure: WARNING: APR not found
</span><span class='line'>The Apache Portable Runtime <span class="p">(</span>APR) library cannot be found.
</span><span class='line'>Please install APR on this system and supply the appropriate
</span><span class='line'>–with-apr <span class="k">option</span> to ‘configure’&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;or&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;get it with SVN and put it in a subdirectory of this <span class="k">source</span>:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;svn co \
</span><span class='line'>    http://svn.apache.org/repos/asf/apr/apr/branches/1.3.x \
</span><span class='line'>    apr&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Run that right here in the top level of the Subversion tree.
</span><span class='line'>Afterwards, run apr/buildconf in that subdirectory and
</span><span class='line'>then run configure again here.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Whichever of the above you do, you probably need to do
</span><span class='line'>something similar for apr-util, either providing both
</span><span class='line'>–with-apr and –with-apr-util to ‘configure’, or
</span><span class='line'>getting both from SVN with:&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;svn co \
</span><span class='line'>    http://svn.apache.org/repos/asf/apr/apr-util/branches/1.3.x \
</span><span class='line'>    apr-util&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;configure: error: no suitable apr found&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<h3 id="apr">2.2.2 安装 APR</h3>

<p>因此，你还需要<code>APR</code>,首先，在安装<code>apr</code>之前需要<code>sqlite-autoconf</code>，因此<code>subversion</code>需要使用<code>sqlite</code>来存储数据。</p>

<ol>
  <li>sqlite-autoconf：<a href="http://www.sqlite.org/2014/sqlite-autoconf-3080403.tar.gz">http://www.sqlite.org/2014/sqlite-autoconf-3080403.tar.gz</a></li>
</ol>

<p>解压缩文件，然后在<code>subversion-1.7.17</code>目录下面，新建一个目录<code>sqlite-amalgamation</code>，然后在目录下面，从解压缩后的<code>sqlite-autoconf</code>目录里面复制一个文件<code>sqlite3.c</code>到该新建目录中。</p>

<blockquote>
  <blockquote>
    <p>Note：需要注意的是，新建目录名必须为<code>sqlite-amalgamation</code>，虽然下载的文件是<code>sqlite-autoconf</code>，这主要是因为<code>sqlite-autoconf</code>工具是由<code>sqlite-amalgamation</code>来的，后来改了名字了，但是<code>subversion</code>编译的时候，并没有改变相应代码配置，所以还是需要用原来的命名。</p>
  </blockquote>
</blockquote>

<p>接下来，就可以下载apr.tar.gz和apr-util.tar.gz两个源码包：</p>

<ol>
  <li>
    <p>apr：<a href="http://mirrors.cnnic.cn/apache//apr/apr-1.5.1.tar.gz">http://mirrors.cnnic.cn/apache//apr/apr-1.5.1.tar.gz</a></p>
  </li>
  <li>
    <p>apr-util：<a href="http://mirrors.cnnic.cn/apache//apr/apr-util-1.5.3.tar.gz">http://mirrors.cnnic.cn/apache//apr/apr-util-1.5.3.tar.gz</a></p>
  </li>
</ol>

<p>解压缩完了之后，分别在<code>subversion-1.7.17</code>目录下面新建<code>apr</code>目录和<code>apr-util</code>目录，然后把解压缩后的内容复制到对应的新建目录中，分别执行<code>./buildconf</code></p>

<blockquote>
  <blockquote>
    <p>Note：这里的目录名字不能改变，必须为<code>apr</code>和<code>apr-util</code>，否则会编译失败。</p>
  </blockquote>
</blockquote>

<p>当然，在这里运行<code>./configure</code>还是会出现问题，错误如下：</p>

<p><figure class='code'><figcaption><span>Linux install software </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;checking zlib.h usability… no
</span><span class='line'>checking zlib.h presence… no
</span><span class='line'>checking <span class="k">for</span> zlib.h… no
</span><span class='line'>configure: error: subversion requires zlib&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<h3 id="zlib">2.2.3 安装 zlib</h3>

<p>好吧，这里还需要<code>zlib</code>库，所以接下来，还需要下载<code>zlib</code>源码包：</p>

<ol>
  <li>zlib：<a href="http://cznic.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz">http://cznic.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz</a></li>
</ol>

<p>然后解压缩，在<code>subversion-1.7.17</code>目录下面，新建一个<code>zlib</code>目录，然后把解压缩的内容复制到该目录下，执行<code>./configure --shared</code>，然后在<code>make</code>，OK了。</p>

<h3 id="neon">2.2.4 安装 neon</h3>

<p>如果不安装<code>neon</code>库，在使用<code>svn co http://...</code> 的时候，则会出现错误。</p>

<p><figure class='code'><figcaption><span>Linux install software </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;svn: E170000: Unrecognized URL scheme <span class="k">for</span> http…&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<p>因此，我们需要安装<code>neon</code>库来提供<code>HTTP</code>库给svn工具使用。在安装<code>neon</code>前需要安装<code>libxml2</code>和<code>libxml2-dev</code>，直接使用<code>sudo apt-get install </code>安装就可以了。</p>

<p>然后，下载neon，地址为：<a href="http://www.webdav.org/neon/neon-0.30.0.tar.gz">http://www.webdav.org/neon/neon-0.30.0.tar.gz</a>，解压缩之后，进入目录，执行<code>./configure</code>、<code>make</code>、<code>sudo make install</code>。</p>

<h3 id="subversion-1">2.3 subversion源码编译安装</h3>

<p>准备工作做好了之后，就可以开始编译安装了。</p>

<p><figure class='code'><figcaption><span>Linux install software </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;./configure –with-neon<span class="o">=</span>/usr/local <span class="nv">CPPFLAGS</span><span class="o">=</span>”-I/home/ketao/java/subversion-1.7.17/zlib/ -L/home/ketao/java/subversion-1.7.17/zlib/”
</span><span class='line'>make
</span><span class='line'>make install
</span></code></pre></td></tr></table></div></figure></p>

<blockquote>
  <blockquote>
    <p>Note：网上嗖的时候，说是<code>./configure CPPFLAGS="-Izlib/ -Lzlib/"</code>就可以，但是在执行的时候出现问题，找不到<code>zlib</code>目录，所以需要写绝对路径。</p>
  </blockquote>
</blockquote>

<p>接下来，你可以在终端执行命名，查看安装版本是否正确。</p>

<p><figure class='code'><figcaption><span>Linux install software </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;svnversion –version
</span></code></pre></td></tr></table></div></figure>
然后会出现：</p>

<p><figure class='code'><figcaption><span>Linux install software </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;svnversion, version 1.7.17 <span class="o">(</span>r1591372<span class="o">)</span>
</span><span class='line'>   compiled Jun  <span class="m">4</span> 2014, 17:39:27&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2014</span> The Apache Software Foundation.
</span><span class='line'>This software consists of contributions made by many people<span class="p">;</span> see the NOTICE
</span><span class='line'>file <span class="k">for</span> more information.
</span><span class='line'>Subversion is open <span class="nb">source </span>software, see http://subversion.apache.org/&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></p>

<h2 id="a-idfinallya"><a id="Finally">小结</a></h2>

<p>Linux下面安装软件，通过编译安装实在是比较复杂，有时候，涉及到多个类库，需要一个个去下载编译安装，比较麻烦。所以，一般情况下，推荐使用<code>apt-get install </code>来打包安装。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Awk 使用学习笔记]]></title>
    <link href="http://kxcoder.github.io/blog/2014/05/30/Linux-Awk-Study-Note/"/>
    <updated>2014-05-30T22:21:35+08:00</updated>
    <id>http://kxcoder.github.io/blog/2014/05/30/Linux-Awk-Study-Note</id>
    <content type="html"><![CDATA[<h2 id="section">目录</h2>

<ol>
  <li><a href="#Intro">前言</a></li>
  <li><a href="#Console">Awk命令行</a></li>
  <li><a href="#Script">Awk脚本程序</a></li>
  <li><a href="#Recommend">推荐教程</a></li>
</ol>

<h2 id="a-idintroa"><a id="Intro">前言</a></h2>

<p><code>linux Awk</code> 脚本语言，算来也有很长的一段历史了。在如今各种更全更简单的脚本语言遍地生成的年代，关注<code>Awk</code>的新人越来越少了。最近，在项目组同事的影响下，去学习了下<code>Awk</code>的基本使用方法。</p>

<blockquote>
  <blockquote>
    <p>Note：本文只是学习笔记，很多示例和描述都来自最后推荐的文章里面。</p>
  </blockquote>
</blockquote>

<p>起意写关于<code>Awk</code>学习笔记的主要原因是，学习皓哥的<a href="http://coolshell.cn/articles/9070.html">AWK 简明教程</a> 完了之后，完全还是云里雾里的，不知所以然。所以，找了个<a href="http://www.aslibra.com/doc/awk.htm">AWK 手册</a>好好学习。但是，对于前者介绍太多浅，初学者对于<code>Awk</code>使用没有任何概念；后者又过于长，不方便我去查资料，所以合计起来，就写一个学习总结罢了。</p>

<!--more-->

<h2 id="a-idconsoleawka"><a id="Console">Awk命令行</a></h2>

<p>关于<code>Awk</code>的历史，语言优势什么的，就不浪费时间介绍了。</p>

<h3 id="awk-">2.1 Awk 程序结构</h3>

<p>首先，我们在服务器上查看日志信息，大部分时候都希望使用一行命令搞定问题，因此，显然命令行方式使用<code>Awk</code>是很频繁的事情。</p>

<p><figure class='code'><figcaption><span>awk语法</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">awk</span> <span class="err">‘</span><span class="nx">awk</span><span class="err">程序主体’</span> <span class="p">[</span><span class="err">操作的文本</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>在写一个<code>awk</code>脚本之前，首先需要的是了解 <code>awk</code>程序组成结构，如果你不了解它的程序一般的结构，那么你去看皓哥或者其他人写的入门级<code>Awk</code>小程序，你也无法真正去了解或者深入。</p>

<pre><code>Pattern1 {Actions1}
Pattern2 { Actions2 }
......
Pattern3 { Actions3 }
</code></pre>

<blockquote>
  <blockquote>
    <p>Note：<code>Pattern （模式）</code>，如同正则一样，就是判断<code>Pattern</code>是否满足，如果满足，则执行就下来的<code>Actions</code>动作行为。<code>awk</code>提供的比较运算符和<code>C</code>语言一样，不过新加了 ` ~ <code>(匹配) 及 </code> !~ `(不匹配) 二个关系运算符.</p>
  </blockquote>
</blockquote>

<pre><code>其用法与涵义如下:
若 A 为一字符串, B 为一正则表达式(Regular Expression)
A ~ B 判断 字符串A 中是否 包含 能匹配(match)B表达式的子字符串.
A !~ B 判断 字符串A 中是否 不包含 能匹配(match)B表达式的子字符串.
</code></pre>

<blockquote>
  <blockquote>
    <p>Note：<code>Action</code>，就是动作，但是需要指出的是，一个<code>Pattern</code>所对应的<code>Action</code>应该要放进<code>{ }</code>内。当然，存在一种情况，就是没有<code>Pattern</code>,直接就是<code>{Action}</code>，这表示，“无条件执行指定的Action动作”。</p>
  </blockquote>
</blockquote>

<p>了解了<code>awk</code>程序的基本结构，下面给一个简单示例：</p>

<p><figure class='code'><figcaption><span>awk语法</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">awk</span> <span class="err">‘</span> <span class="o">$</span><span class="mi">0</span><span class="err">&amp;</span><span class="nx">gt</span><span class="p">;</span><span class="mi">1</span> <span class="p">{</span><span class="kr">print</span> <span class="err">“</span><span class="nx">hello</span> <span class="nx">world</span><span class="err">”</span><span class="p">}</span><span class="err">’</span>
</span></code></pre></td></tr></table></div></figure></p>

<blockquote>
  <blockquote>
    <p>这个程序意思就是：<code>$0&gt;1</code>模式成立，则打印后面的<code>hello world</code>，在console上输入3，回车，则会打印<code>hello world</code>；如果输入0，则不会打印该消息。</p>
  </blockquote>
</blockquote>

<h3 id="awk--1">2.2 Awk 程序说明</h3>

<p>首先，需要了解<code>$0</code>这种格式： <code>$0</code>表示<code>awk</code>所读入的一行字符串；<code>$1</code>则表示所读入的字符串的第一个数据，默认安装<code>空格/tab</code>来分隔；<code>$2</code>则表示所读入的字符串的第二个数据；以此类推…..</p>

<p>其次，这个程序是从控制台，或者文本中读取变量值（需要在后面写操作的文本名）。如果你测试了这个小脚本，你会发现，它会一直读，知道遇到<code>ctrl+d</code>或者<code>EOF</code>才会结束。但是，如果你初始化一些变量或者其他只需要执行一次的逻辑，怎么办呢？你需要<code>BEGIN</code>和<code>END</code>。</p>

<pre><code>1. BEGIN ：程序一开始执行时执行的，仅被执行一次。
2. END	 ：程序处理完所有数据即将返回的时候，执行一次。
</code></pre>

<p>比如上面的程序，可以写成：</p>

<p><figure class='code'><figcaption><span>awk示例</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">awk</span> <span class="err">‘</span> <span class="nx">BEGIN</span><span class="p">{</span><span class="nx">n</span><span class="o">=</span><span class="mi">3</span><span class="p">}</span> <span class="o">$</span><span class="mi">0</span><span class="err">&amp;</span><span class="nx">gt</span><span class="p">;</span><span class="mi">1</span> <span class="err">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="err">&amp;</span><span class="nx">amp</span><span class="p">;</span> <span class="err">–</span><span class="nx">n</span><span class="err">&amp;</span><span class="nx">gt</span><span class="p">;</span><span class="mi">0</span> <span class="p">{</span><span class="kr">print</span> <span class="err">“</span><span class="nx">hello</span> <span class="nx">world</span><span class="err">”</span><span class="p">}</span> <span class="nx">END</span><span class="p">{</span><span class="kr">print</span> <span class="err">“</span><span class="nx">EXIT</span> <span class="nx">AWK</span> <span class="nx">TEST</span><span class="err">”</span><span class="p">}</span><span class="err">’</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>执行完了结果如下：</p>

<pre><code>[tao.ke@l-rtools1.ops.cn6 ~]$ awk ' BEGIN{n=3} $0&gt;1 &amp;&amp; --n&gt;0 {print "hello world"} END{print "EXIT AWK TEST"}'         
3
hello world
2
hello world
1
0 #（在这里的时候输入 ctrl+d）
EXIT AWK TEST
</code></pre>

<p>最后，说说<code>Awk</code>中使用<code>linux shell</code>命令。和<code>linux</code>一样，使用<code>|</code>来操作管道流，使用<code>""</code>标识<code>linux</code>命令。</p>

<p><figure class='code'><figcaption><span>awk示例</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='awk'><span class='line'><span class="nx">awk</span> <span class="err">‘</span> <span class="nx">BEGIN</span><span class="p">{</span><span class="k">while</span><span class="p">(</span><span class="err">“</span><span class="nx">who</span><span class="err">”|</span><span class="kr">getline</span><span class="p">){</span><span class="kr">print</span> <span class="o">$</span><span class="mi">0</span><span class="p">}}</span> <span class="err">‘</span><span class="o">&lt;</span><span class="nx">br</span> <span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<blockquote>
  <blockquote>
    <p>这里可以打印出，所有的登陆在系统上的用户。	关于<code>while</code>的使用，和<code>c</code>语言一样；此外，其他控制语言<code>if</code>、<code>do-while</code>、<code>for</code>，也和<code>c</code>一样。需要说明的是，<code>for</code>可以使用类似<code>foreach</code>的形式，具体见下一节。</p>
  </blockquote>
</blockquote>

<h2 id="a-idscriptawka"><a id="Script">Awk脚本程序</a></h2>

<p>–待续</p>

<h2 id="a-idrecommenda"><a id="Recommend">推荐教程</a></h2>

<ul>
  <li>
    <p>awk手册，<a href="http://www.aslibra.com/doc/awk.htm">http://www.aslibra.com/doc/awk.htm</a></p>
  </li>
  <li>
    <p>AWK 简明教程，<a href="http://coolshell.cn/articles/9070.html">http://coolshell.cn/articles/9070.html</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
</feed>
